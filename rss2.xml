<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Single Wang&#39;s Blog</title>
    <link>http://singlewang.top/</link>
    
    <atom:link href="http://singlewang.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>智者不入爱河，愚者重蹈覆辙</description>
    <pubDate>Tue, 03 May 2022 12:57:20 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>c++遇到的bug-1</title>
      <link>http://singlewang.top/2022/05/03/cpp/cpp-bug/c++bug-1/</link>
      <guid>http://singlewang.top/2022/05/03/cpp/cpp-bug/c++bug-1/</guid>
      <pubDate>Tue, 03 May 2022 12:54:00 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;&lt;code&gt;reference to local variable ‘c’ returned [-Wreturn-local-addr]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;函数的返回值为函数内部定义变量的引用，但函数在调用完毕后，函数内部定义的变量空间被</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li><code>reference to local variable ‘c’ returned [-Wreturn-local-addr]</code></li></ol><p>函数的返回值为函数内部定义变量的引用，但函数在调用完毕后，函数内部定义的变量空间被释放，无法访问，从而造成的错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix&amp; Matrix::<span class="keyword">operator</span>+(<span class="type">const</span> Matrix&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix result;</span><br><span class="line"><span class="comment">//其他操作</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>改正方法一</strong></em>：给返回变量定义加上static限定符，保证在函数调用完后不释放空间<br>Matrix&amp; Matrix::operator+(const Matrix&amp; rhs)<br>{<br>    static Matrix result;<br>    &#x2F;&#x2F;其他操作<br>    return result;<br>}</p><p><em><strong>改正方法二</strong></em>：去掉返回值的引用，保证函数外部无法访问返回值的空间，只能得到其内容<br>Matrix Matrix::operator+(const Matrix&amp; rhs)<br>{<br>    static Matrix result;<br>    &#x2F;&#x2F;其他操作<br>    return result;<br>}</p><ol start="2"><li><p>LNK2019<br>即使包含了头文件依然会报无法解析的命令,原因可能是没添加相应的.lib文件</p></li><li><p>不允许指针指向不完整的类类型<br>一般是没有包含相应的头文件</p></li></ol>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/cpp/">C++</category>
      
      <category domain="http://singlewang.top/categories/cpp/cpp-bug/">C++BUG</category>
      
      
      <category domain="http://singlewang.top/tags/cpp/">cpp</category>
      
      <category domain="http://singlewang.top/tags/bug/">bug</category>
      
      
      <comments>http://singlewang.top/2022/05/03/cpp/cpp-bug/c++bug-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>git学习</title>
      <link>http://singlewang.top/2022/05/03/git%E5%AD%A6%E4%B9%A0/</link>
      <guid>http://singlewang.top/2022/05/03/git%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Tue, 03 May 2022 12:51:00 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;初始化一个git目录    &lt;code&gt;git init&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加文件到Git仓库，分两步：&lt;br&gt; 使用命令&lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt;，注意，可反复多次使用，添加多个文件；&lt;br&gt; 使用命令&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>初始化一个git目录    <code>git init</code></li><li>添加文件到Git仓库，分两步：<br> 使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；<br> 使用命令<code>git commit -m &lt;message&gt;</code>提交完成。-m后面输入的是本次提交的说明</li><li>要随时掌握工作区的状态，使用<code>git status</code>命令。<br> 如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li><li>添加远程库<code>git remote add origin git@github.com:SimpleWang0118/C-Game.git</code><br> 添加后，远程库的名字就是<code>origin</code><br> 把本地库的所有内容推送到远程库上（第一次）<code>git push -u origin master</code><br> 只要本地作了提交，就可以通过命令 <code>git push origin master</code>推送至远程库上</li><li>查看远程库信息<code>git remote -v</code></li><li>删除远程库<code>eg git remote rm origin</code></li><li><code>git commit</code>提示<code>Your branch is up-to-date with &#39;origin/master&#39;</code><br> 首先建立一个分支：<code>git branch new branch</code><br> 然后检查分支是否创建成功: <code>git branch</code> *代表的是当前你所在的工作分支<br> 然后切换到你的新分支: <code>git checkout newbranch</code><br> 然后将你的改动提交到新分支上: git add .     git commit -m “18.03.01”<br> 然后切换到主分支:<code>git checkout master</code><br> 然后将新分支提交的改动合并到主分支上:<code>git merge newbranch</code><br> 然后就可以push代码了:<code>git push -u origin master</code><br> 最后还可以删除这个分支:<code>git branch -D newbranch</code></li></ol>]]></content:encoded>
      
      
      
      <category domain="http://singlewang.top/tags/git/">git</category>
      
      <category domain="http://singlewang.top/tags/github/">github</category>
      
      
      <comments>http://singlewang.top/2022/05/03/git%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>刷机教程</title>
      <link>http://singlewang.top/2022/05/03/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</link>
      <guid>http://singlewang.top/2022/05/03/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</guid>
      <pubDate>Tue, 03 May 2022 08:34:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;1、首先解锁手机BL锁，进入开发者选项，然后需要到相应的手机官网下载解锁工具。&lt;br&gt;2、安装对应手机的rec软件，之后进入rec，先双清，即首先清除数据，再格式化&lt;br&gt;3、下载对应的系统压缩包&lt;br&gt;4、在rec软件中安装压缩包即可。&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>1、首先解锁手机BL锁，进入开发者选项，然后需要到相应的手机官网下载解锁工具。<br>2、安装对应手机的rec软件，之后进入rec，先双清，即首先清除数据，再格式化<br>3、下载对应的系统压缩包<br>4、在rec软件中安装压缩包即可。</p>]]></content:encoded>
      
      
      
      <category domain="http://singlewang.top/tags/%E5%88%B7%E6%9C%BA/">刷机</category>
      
      
      <comments>http://singlewang.top/2022/05/03/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux内核协议栈-cp2</title>
      <link>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp2/</link>
      <guid>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp2/</guid>
      <pubDate>Tue, 03 May 2022 08:34:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;2-系统初始化&quot;&gt;&lt;a href=&quot;#2-系统初始化&quot; class=&quot;headerlink&quot; title=&quot;2.系统初始化&quot;&gt;&lt;/a&gt;2.系统初始化&lt;/h2&gt;&lt;h3 id=&quot;2-1-系统初始化流程简介&quot;&gt;&lt;a href=&quot;#2-1-系统初始化流程简介&quot; class</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="2-系统初始化"><a href="#2-系统初始化" class="headerlink" title="2.系统初始化"></a>2.系统初始化</h2><h3 id="2-1-系统初始化流程简介"><a href="#2-1-系统初始化流程简介" class="headerlink" title="2.1 系统初始化流程简介"></a>2.1 系统初始化流程简介</h3><p>在系统启动过程中，我们要关注这几个方面： </p><ol><li>中断系统及调度系统 </li><li>文件系统的初始化 </li><li>设备管理系统的初始化</li><li>网络协议的初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kernel_thread</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> * arg, <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br></pre></td></tr></table></figure><p><code>kernel_thread</code>创建一个线程，定义在arch&#x2F;i386&#x2F;kernel&#x2F;process.c中，Linux 的内核线程是没有虚拟存储空间的进程，它们运行在内核中，直接使用物理地址空间。</p><h3 id="2-2内核文件解读"><a href="#2-2内核文件解读" class="headerlink" title="2.2内核文件解读"></a>2.2内核文件解读</h3><h4 id="2-2-1ELF文件格式"><a href="#2-2-1ELF文件格式" class="headerlink" title="2.2.1ELF文件格式"></a>2.2.1ELF文件格式</h4><p>ELF 是*nix 系统上可执行文件的标准格式，它取代了out格式的可执行文件，原因在于它的可扩展性。<br>ELF文件有三种不同的形式：</p><ol><li>Relocatable：由编译器和汇编器生成，由 linker 处理它。 </li><li>Executable：所有的重定位和符号解析都完成了，也许共享库的符号要在运行时刻解析。</li><li>Shared Object：包含 linker 需要的符号信息和运行时刻所需的代码。</li></ol><p>ELF 文件有双重性质：一方面，编译器、汇编器、连接器都把它看作是逻辑段（sections）的集合， 另一方面 loader 把它看作段（segments）的集合。Section 是给 linker 做进一步处理的，而 segments 是被映射到内存中去的。</p><p>一个 segment 可以由几个 sections 组成。为了定位不同 segment&#x2F;section，可执行文件用一个 table 来记录各个 segment&#x2F;section 的位置和描述。</p><h4 id="2-2-2Link-Scripts知识"><a href="#2-2-2Link-Scripts知识" class="headerlink" title="2.2.2Link Scripts知识"></a>2.2.2Link Scripts知识</h4><p>为什么我们编出来的代码肯定是在用户地址空间运行，而内核编出来的代码 却一定是运行在内核空间？<br>主要是因为链接器的作用。不能简单地认为链接器仅仅完成将各 obj 文件拼在一起的任务，而且它还指定每个段被装入内存的真正地址。</p><p>可以用<code>ld -verbose</code>查看<code>ld script</code></p><h3 id="2-3中断及任务调度管理"><a href="#2-3中断及任务调度管理" class="headerlink" title="2.3中断及任务调度管理"></a>2.3中断及任务调度管理</h3><h4 id="2-3-1中断及软中断模型"><a href="#2-3-1中断及软中断模型" class="headerlink" title="2.3.1中断及软中断模型"></a>2.3.1中断及软中断模型</h4><p>Linux 支持 CPU 的外部硬件中断和内部中断。&#x3D;&#x3D;内部中断包含系统调用陷入和异常&#x3D;&#x3D;，在一般的嵌入式操作系统（比如 VxWorks）中是没有系统调用这个概念的。</p><ul><li>&#x3D;&#x3D;系统调用&#x3D;&#x3D;就是软件有计划地调用 CPU 提供的特殊指令，触发 CPU 内部产生一个中断，于是完成一次核内核外运行空间的切换，具体可以参考许多书籍。</li><li>&#x3D;&#x3D;异常&#x3D;&#x3D;就是软件无意的执行了一个非法指令（比如除 0）从而造成 CPU 内部引发一次中断。</li></ul><p>&#x3D;&#x3D;外部中断&#x3D;&#x3D;特指外部设备发出的中断信号。但这几种中断的 CPU 处理过程基本相同，即：在执行完当 前指令后，或在执行当前指令期间，根据中断源所提供的“中断向量”，在内存中找到相应的 ISR（中断<br>服务例程）然后调用之。</p><h5 id="2-3-1-1中断系统和软中断"><a href="#2-3-1-1中断系统和软中断" class="headerlink" title="2.3.1.1中断系统和软中断"></a>2.3.1.1中断系统和软中断</h5><p>IRQ 是设备相关的号码，一般生产厂商都会使自己的设备分配到一个合适的号码。<br>&#x3D;&#x3D;中断向量&#x3D;&#x3D;就是操作系统中关于如何处理中断的内存组织结构，它们之间存在某种映射关系，这种关系是由CPU体系结构以及操作系统决定的。</p><blockquote><p>中断向量号0x80是系统调用号</p></blockquote><p>软中断是在处理完所有的中断之后才会处理的。目前linux内核中定义了6种软中断。在<code>start_kernel</code>函数中调用的<code>softirp_init</code>只初始化了两个。</p><p>Tasklet机制是一种比较特殊的软中断。指一小段可以执行的代码。通常以函数的形式出现。从某种程度上讲tasklet机制是linux内核对BH机制的一种扩展。它呈现出以下两个特点:</p><ol><li>与一般的软中断不同，某一段 tasklet 代码在某个时刻只能在一个 CPU 上运行，而不像一般的软 中断服务函数（即 softirq_action 结构中的 action 函数指针）那样在同一时刻可以被多个 CPU 并发地执行。</li><li>与BH机制不同，不同的 tasklet 代码在同一时刻可以在多个 CPU上并发地执行，而不像BH机制 那样必须严格地串行化执行（也即在同一时刻系统中只能有一个 CPU 执行BH函数）。</li></ol><h3 id="2-4虚拟文件系统"><a href="#2-4虚拟文件系统" class="headerlink" title="2.4虚拟文件系统"></a>2.4虚拟文件系统</h3><p>VFS（虚拟文件系统）在 Linux 及Unix 家族中是非常重要的概念，可以说它是操作系统的骨架。VFS 只存在与内存中，它在系统启动时被创建，系统关闭时注销。<br>&#x3D;&#x3D;VFS 的作用就是屏蔽各类文件系统的差异， 给用户、应用程序、甚至 Linux 其他管理模块提供统一的接口集合。&#x3D;&#x3D;</p><p>VFS 描述文件系统使用超级块和 inode 的方式，所谓超级块就是对所有文件系统的管理机构，每种 文件系统都要把自己的信息挂到 <code>super_blocks</code> 这么一个全局链表上。内核中是分成 2 个步骤完成：首先 每个文件系统必须通过 <code>register_filesystem</code> 函数将自己的 <code>file_system_type</code> 挂接到 <code>file_systems</code> 这个全局变量上，然后调用 <code>kern_mount</code> 函数把自己的文件相关操作函数集合表挂到 <code>super_blocks</code> 上。</p><h3 id="2-5网络协议栈各部分初始化"><a href="#2-5网络协议栈各部分初始化" class="headerlink" title="2.5网络协议栈各部分初始化"></a>2.5网络协议栈各部分初始化</h3><p>初始化大致的顺序：</p><ol><li>core_initcall:sock_init()</li><li>fs_initcall:inet_init()</li><li>subsys_initcall:net_dev_init()</li><li>device_initcall:设备驱动初始化</li></ol><h4 id="2-5-1网络基础系统初始化"><a href="#2-5-1网络基础系统初始化" class="headerlink" title="2.5.1网络基础系统初始化"></a>2.5.1网络基础系统初始化</h4><p>第一个步骤使用<code>core_initcall</code>初始化宏修饰<code>sock_init</code>函数，此函数知识分配一些内存空间，以及创建一个sock_fs_type的二年间系统。</p><blockquote><p>基本的socket初始化必须在每一个TCP&#x2F;IP成员协议能注册到socket层之前完成。</p></blockquote><p>当执行<code>do_initcalls</code>时才是真正初始化那些特定协议。</p><h4 id="2-5-2网络内存管理"><a href="#2-5-2网络内存管理" class="headerlink" title="2.5.2网络内存管理"></a>2.5.2网络内存管理</h4><h5 id="2-5-2-1-sk-buff结构"><a href="#2-5-2-1-sk-buff结构" class="headerlink" title="2.5.2.1 sk_buff结构"></a>2.5.2.1 sk_buff结构</h5><p>数据包在应用层称为data，在TCP层成为segment，在IP层称为packet，在数据链路层称为frame。Linux内核中<code>sk_buff&#123;&#125;</code>存放网络接收到或需要发送的数据，因此其必须要有足够的扩展性。<br>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 <code>skb-&gt;data</code> 的值，来逐步剥离协议首部；<br>而要发送报文时，各协议创建<code>sk_buff&#123;&#125;</code>，在经过各下层协议时，通过减少 <code>skb-&gt;data</code><br>的值来增加协议首部。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span>&#123;</span></span><br><span class="line">    <span class="comment">/*这两个成员必须放在前面*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    _u32    qlen;<span class="comment">/*该sk_buff_head引导的一个链表的节点的个数*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当接收一个报文时，创建一个<code>sk_buff&#123;&#125;</code>(sk_buff的内容过多，暂不列出),然后更具地址类型指定该skb实际属于哪一种的报文类型，然后上层协议栈采取相应的处理方式处理该skb。</p><p>其中<code>len</code>是指数据包全部数据的长度，包括<code>data</code>指向的数据和end后面的分片的数据的总长，而<code>data_len</code>只包括分片的数据的长度。<code>truesize</code>的最终值时<code>len+sizof(struct sk_buff)</code>。</p><p>两个后备高速缓存的区别：</p><ul><li><code>skbuff_head_cache</code> 在创建时指定的单位内存区域的大小是<code>sizeof(struct sk_buff)</code>，可以容纳任意数目的<code>struct sk_buff</code>。</li><li><code>skbuff_fclone_cache</code>在创建时指定的单位内存区域大小时<code>2*sizeof(struct sk_buff)+sizeof(atomic_t)</code>。</li></ul><p>创建一个套接字缓冲区，最常用的操作是<code>alloc_skb</code>。它是在<code>skbuff_head_cache</code>中创建。</p><blockquote><p>GSO(Generic Segmentation Offload):<br>协议栈的效率提高的一个策略：尽可能晚的推迟分段，最理想的是在网卡驱动里分段，在网卡驱动里把大包拆开，组成SG list，或在一块预先分配好的内存中重组分段，然后交给网卡。</p></blockquote><h5 id="2-5-2-2-内存管理函数"><a href="#2-5-2-2-内存管理函数" class="headerlink" title="2.5.2.2 内存管理函数"></a>2.5.2.2 内存管理函数</h5><p>在<code>sk_buff&#123;&#125;</code>中的 4 个指针 data、head、tail、end 初始化的时候，data、head、tail 都是指向申请到的 数据区的头部，end 指向数据区的尾部。一般都是通过 data 和 tail 来获得在 sk_buff中 可用的数据区的开始和结尾。而 head 和 end 就表示 sk_buff中存在的数据包最大可扩展的空间范围。</p><p> skb_clone 和 skb_copy 的区别：</p><ul><li>前者基本在 <code>skbuff_fclone_cache</code> 中分配内存，除非 一定要对一个不是可以被克隆的对象进行克隆，那么才会在 <code>skbuff_head_cache</code> 中分配内存，而且只是 <code>sk_buff&#123;&#125;</code>结构的复制，没有涉及到真正数据区（data）的复制；</li><li>后者必定在 <code>skbuff_head_cache</code> 中进行，<br>不仅复制 <code>sk_buff&#123;&#125;</code>，而且复制了数据区。</li></ul><h4 id="2-5-3-网络文件系统初始化"><a href="#2-5-3-网络文件系统初始化" class="headerlink" title="2.5.3 网络文件系统初始化"></a>2.5.3 网络文件系统初始化</h4><p>在 <code>linux</code> 系统中，<code>socket</code> 属于文件系统的一部分，网络通信可以被看作对文件的读取。这种特殊的文件系统叫 <code>sockfs</code>。</p><p>初始化文件系统，首先是调用 <code>register_filesystem(&amp;sock_fs_type)</code>;把文件系统类型注册到 <code>file_systems</code> 链表上，然后调用 <code>kern_mount(&amp;sock_fs_type)</code>;把该文件系统注册到 <code>super_blocks</code> 上。</p><p>在系统初始化的时候要通过 <code>kern_mount</code> 安装此文件系统。所谓创建一个套接字就是在 <code>sockfs</code>文件系统中创建一个特殊文件。</p><h4 id="2-5-4-网络协议初始化"><a href="#2-5-4-网络协议初始化" class="headerlink" title="2.5.4 网络协议初始化"></a>2.5.4 网络协议初始化</h4><p>初始化第二个大步骤就是使用 <code>fs_initcall</code> 初始化宏修饰 <code>inet_init</code> 函数，它初始化和协议本身相关的东西。这一步才真正设计到“栈”的概念。在这之前，必须要知道两个概念–地址族和套接字类型。Linux 将不同的地址族抽象统一为 BSD 套接字接口，应用程序关心的只是BSD套接字接口，通过参数来指定所使用的套接字地址族。</p><p>Linux 内核中为了支持多个地址族，定义了这么一个变量：<code>static struct net_proto_family *net_families[NPROTO]</code>，NPROTO 等于 32，也就是说 Linux 内核支持最多 32 种地址族。</p><p>我们常用的就是 PF_UNIX（1）、PF_INET（2）、PF_NETLINK（16），Linux 还有一个自有的 PF_PACKET（17）。</p><blockquote><p>网络协议的初始化是在网络设备的初始化之前完成的，在 Linux 系统中并不是说网络设备不存在就不需要网络协议了，而是在没有网络设备存在的时候，照样可以完成网络的工作，只不过网络系统物理上只存在于本机一台机器中而已。</p></blockquote><p>一进入初始化就调用 <code>proto_register</code>3次，先后为 tcp、udp、raw的 <code>proto&#123;&#125;</code>结构申请空间并将其挂到一 个全局链表 <code>proto_list</code> 上。这三个 proto 全局变量非常重要，是连接传输层和 IP 层的纽带。</p><p><code>sock_register</code>函数，它把 <code>inet_family_ops</code> 塞入 <code>net_families</code> 数组中，这个 <code>inet_family_ops</code>是如下定义的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> =</span> &#123; </span><br><span class="line">    .family = PF_INET, </span><br><span class="line">    .create = inet_create, </span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户创建 socket 时，先指定 INET 地址族，在指定套接字 类型。换句话说这是数据流发送的流向。</p><p>socket层必须区分哪一个用户应该接收这个包，这叫做<em><strong>socket解复用</strong></em>。</p><p>之后就是初始化第二个方面的必要步骤:注册接收函数<br>Linux 区分永久和非永久协议。永久协议包括像UDP和TCP，这是TCP&#x2F;IP 协议实现的基本部分，去掉一个永久协议是不允许的。所以，UDP和TCP是不能unregistered。此机制由2个函数和一个维护注册协议的数据结构组成。一个负责注册协议，另一个负责注销。每一个注册的协议都放在一个表里，叫<br><em><strong>协议切换表</strong></em>。</p><p>对于发送过程，直接调用IP层函数，而对于内核接收过程则分为2层：上层需要一个接收函数解复用传输协议报文，下层需要一个接收函数解复用网络层报文。报文从设备层送到上层之前，必须区分是IP报文还是ARP报文。</p><p>标识一个套接字的三元组:&lt;地址族，类型，具体协议&gt;。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核协议栈</category>
      
      
      <category domain="http://singlewang.top/tags/kernal/">kernal</category>
      
      <category domain="http://singlewang.top/tags/linux/">linux</category>
      
      <category domain="http://singlewang.top/tags/%E5%86%85%E6%A0%B8/">内核</category>
      
      
      <comments>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux内核协议栈-cp1</title>
      <link>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp1/</link>
      <guid>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp1/</guid>
      <pubDate>Tue, 03 May 2022 07:55:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;linux内核协议栈&quot;&gt;&lt;a href=&quot;#linux内核协议栈&quot; class=&quot;headerlink&quot; title=&quot;linux内核协议栈&quot;&gt;&lt;/a&gt;linux内核协议栈&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;1-协议栈概述&quot;&gt;&lt;a href=&quot;#1-协议栈概述&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="linux内核协议栈"><a href="#linux内核协议栈" class="headerlink" title="linux内核协议栈"></a>linux内核协议栈</h1><hr><h2 id="1-协议栈概述"><a href="#1-协议栈概述" class="headerlink" title="1.协议栈概述"></a>1.协议栈概述</h2><hr><h3 id="1-1操作系统及网络协议介绍"><a href="#1-1操作系统及网络协议介绍" class="headerlink" title="1.1操作系统及网络协议介绍"></a>1.1操作系统及网络协议介绍</h3><hr><h4 id="1-1-1linux操作系统架构简介"><a href="#1-1-1linux操作系统架构简介" class="headerlink" title="1.1.1linux操作系统架构简介"></a>1.1.1linux操作系统架构简介</h4><p>linux是一款大内核操作系统。</p><p>操作系统内核可能是微内核，也可能是大内核（后者有时称之为宏内核Macrokernel）。按照类似封装 的形式，这些术语定义如下:</p><ul><li>微内核（Microkernel kernel）――在微内核中，大部分内核都作为独立的进程在特权状态下运行， 它们通过消息传递进行通讯。微内核设计的一个优点是在不影响系统其它部分的情况下，用更高效的实现代替现有文件系统 模块的工作将会更加容易。我们甚至可以在系统运行时将开发出的新系统模块或者需要替换现有模块的 模块直接而且迅速的加入系统。另外一个优点是不需要的模块将不会被加载到内存中，因此微内核就可<br>以更有效的利用内存。</li><li>大内核（Monolithic kernel）――大内核是一个很大的进程。它的内部又可以被分为若干模块（或者是层次或其它）。但是在运行的时候，它是一个独立的二进制大映象。其模块间的通讯是通过直接调用其它模块中的函数实现的，而不是消息传递。</li></ul><blockquote><p>除了嵌入式，没有一款商用的操作系统是以真正学术上的微内核形式存在。</p></blockquote><h4 id="1-1-2网络协议发展介绍"><a href="#1-1-2网络协议发展介绍" class="headerlink" title="1.1.2网络协议发展介绍"></a>1.1.2网络协议发展介绍</h4><p>IP网络的优点，简单，IP协议栈的中心在于，使用IP协议将数据包发送到任何网络，数据包到达的时间可以不同。</p><p>事实上的网络协议栈实现基本采用TCP&#x2F;IP的4层架构，从底往上分别是：链路层，网络层，传输层，应用层。<br>但是在实际开发人员的眼中，却是五层，即在链路层之下还有一个物理层。</p><p>将链路层简称为2层或L2，网络层简称为3层或L3，而传输层即为4层或L4。</p><p>应用程序是可以绕过TCP层而直接与IP层协作，比如我们常用的 ping 命令。</p><h4 id="1-1-3基本的数据结构和计算机术语"><a href="#1-1-3基本的数据结构和计算机术语" class="headerlink" title="1.1.3基本的数据结构和计算机术语"></a>1.1.3基本的数据结构和计算机术语</h4><ul><li><p>链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ist_head 结构包含两个指向list_head结构的指针prev和next，通常它都组织成双循环链表。在 Linux内核链表中，不是在链表结构中包含数据，而是在数据结构中包含链表节点。</p></li><li><p>由链表节点到数据项变量<br>如何通过这个 list_head 成员访问到它的所有者呢？Linux 为此提供了一个 list_entry(ptr, type, member)宏，<br>ptr 是指向该数据中 list_head 成员的指针<br>type 是数据项的类型<br>member 则是数据项</p></li><li><p>hlist<br>hlist 是 hash list的简称，即用拉链法实现的 hash 数据结构。它由 2 部分组成：hash 数组和冲突链。当节点第一次要插入 hash 表的时候，它必定是先插入 hash 数组中，而以后要插入的节点如果发生了冲突，则可以挂在数组后面，形成一条链表。当然也可以插入数组，原先在数组中的节点被挤出来形成一条链表。</p></li></ul><p>也许Linux链表设计者认为双头（next、prev）的双链表对于HASH表来说”过于浪费”，因而另行设计了一套用于HASH表应用的 hlist 数据结构——单指针表头双循环链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span>, **<span class="title">pprev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核协议栈</category>
      
      
      <category domain="http://singlewang.top/tags/kernal/">kernal</category>
      
      <category domain="http://singlewang.top/tags/linux/">linux</category>
      
      <category domain="http://singlewang.top/tags/%E5%86%85%E6%A0%B8/">内核</category>
      
      
      <comments>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk</title>
      <link>http://singlewang.top/2022/05/03/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6/</link>
      <guid>http://singlewang.top/2022/05/03/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6/</guid>
      <pubDate>Tue, 03 May 2022 07:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;传统网络设备驱动包处理的流程可以概括如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据包到达网卡设备&lt;/li&gt;
&lt;li&gt;网卡设备依据配置进行DMA操作&lt;/li&gt;
&lt;li&gt;网卡发送中断，唤醒处理器&lt;/li&gt;
&lt;li&gt;驱动软件填充读写缓冲区数据结构&lt;/li&gt;
&lt;li&gt;数据报文到达内核协议栈</description>
        
      
      
      
      <content:encoded><![CDATA[<p>传统网络设备驱动包处理的流程可以概括如下:</p><ul><li>数据包到达网卡设备</li><li>网卡设备依据配置进行DMA操作</li><li>网卡发送中断，唤醒处理器</li><li>驱动软件填充读写缓冲区数据结构</li><li>数据报文到达内核协议栈，进行高层处理</li><li>如果最终应用在用户态，数据从内核搬移到用户态</li><li>如果最终应用在内核态，在内核继续进行</li></ul>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      
      <comments>http://singlewang.top/2022/05/03/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux命令</title>
      <link>http://singlewang.top/2022/05/03/linux/linux-command/linux%E5%91%BD%E4%BB%A4/</link>
      <guid>http://singlewang.top/2022/05/03/linux/linux-command/linux%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Tue, 03 May 2022 03:24:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;.    #当前文件夹&lt;br&gt;..   #上一级文件夹&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;tar&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;tar -zxvf             解压缩&lt;br&gt;tar -zcv</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>.    #当前文件夹<br>..   #上一级文件夹</p></blockquote><hr><p><em><strong>tar</strong></em><br>tar -zxvf             解压缩<br>tar -zcvf             压缩</p><blockquote><p>解压tar.xz文件时<br>xz -d xxx.tar.xz 之后会得到xxx.tar文件<br>再执行tar -xvf xxx.tar即可</p></blockquote><p><em>~&#x2F;.bash_history 记录了所有的历史命令</em><br>执行history中的某一句，只需用！加行号<br><code>!1322</code></p><hr><p><em><strong>find</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find ./home/wang -name test.txt  在/home/wang路径下寻找test.txt文件</span><br><span class="line"></span><br><span class="line">find ./home/wang -name <span class="string">&quot;*.c&quot;</span> 在/home/wang路径下寻找所有后缀为.c的文件</span><br></pre></td></tr></table></figure><hr><p><em><strong>grep</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep -i -n &quot;hello&quot; ./*.cpp 在当前文件夹下所有的.cpp文件中查找hello字符串，-n 并且打印行号，-i 不区分大小写</span><br><span class="line">grep -r &quot;include&quot; ./*.cpp 在当前文件夹下所有的.cpp文件中查找include字符串，-r 并且打印文件路径</span><br><span class="line">ls | grep -n &#x27;.c$&#x27;  列出所有的.c文件</span><br><span class="line">grep shell ed.md 在文件ed.md中查找所有的单词shell</span><br></pre></td></tr></table></figure><hr><p><em><strong>环境变量</strong></em><br>查看全局变量 <code>env</code> 或者 <code>printenv</code><br><code>export PATH=$PATH:/home/wang</code>        将某个路径添加到环境变量中，只能生效一次，待重启之后依然需要重新添加<br><code>echo</code> 显示变量的值<br><code>echo $PATH</code> 取出变量PATH的内容</p><hr><p><em><strong>vim</strong></em><br>vim常用命令：<br><code>yy</code> 复制光标所指的当前行<br><code>nyy</code> 复制光标所指的一行往下n行<br><code>p</code> 粘贴在光标以下<br><code>P</code> 粘贴在光标以上<br><code>dd</code> 删除光标所指的一行<br><code>ndd</code> 删除光标所指的往下n行<br><code>set nu</code> 显示行号</p><hr><blockquote><p>反单引号&#96;&#96;&#96;这个符号代表的意义为何？<br>在一串指令中，在”&#96;”之内的指令会被先执行，而其执行出来的结果将作为外部的输入信息</p></blockquote><hr><p><code>uname -a</code> 查看当前内核版本</p><p><code>?</code>代表一个字符<br><code>*</code> 代表零个或多个字符</p><hr><p><em><strong>进程</strong></em><br><code>ps</code>                查看进程<br><code>top</code>               显示实时进程<br><code>kill 3445</code>(端口号)  结束进程 </p><p><code>ctrl+c</code>             中断进程<br><code>ctrl+z</code>              暂停进程 </p><hr><p><code>rmdir</code> 删除目录<br><code>rm -rf</code> 强制删除目录，即使目录下面有文件<br>要想同时创建多个目录和子目录，需要加入-p参数<br><code>mkdir -p new_dir/sub_dir/under_dir</code><br><code>tree</code> 目录以树的形式列出目录中的所有文件<br><code>file</code>  查看文件类型<br><code>cat file1</code> 显示文件内容<br><code>cat -n file1</code> 给显示的文件内容加上行号<br><code>cat -b file</code>   只给文件中有内容的加上行号</p><p><code>du</code>显示当前目录下所有的文件、目录、子目录的磁盘使用情况:</p><ul><li>-c  显示所有已列出文件的大小</li><li>-h 以易读形式显示</li><li>-s 显示每个输出参数的总计</li></ul><hr><p><em><strong>挂载</strong></em><br>要手动在虚拟目录中挂载设备，需要以root用户身份登录，或是以root用户身份运行sudo命<br>令。下面是手动挂载媒体设备的基本命令：<br><code>mount -t type device directory</code></p><blockquote><p>&#x3D;&#x3D;文件类型&#x3D;&#x3D;：<br><em>vfat</em>：Windows长文件系统。<br><em>ntfs</em>：Windows NT、XP、Vista以及Windows 7中广泛使用的高级文件系统。<br><em>iso9660</em>：标准CD-ROM文件系统。</p></blockquote><p>手动将U盘&#x2F;dev&#x2F;sdb1挂载到&#x2F;media&#x2F;disk，可用下面的命令：<br><code>mount -t vfat /dev/sdb1 /media/disk</code></p><ul><li>从Linux系统上移除一个可移动设备时，不能直接从系统上移除，而应该先卸载。</li><li>Linux上不能直接弹出已挂载的CD。如果你在从光驱中移除CD时遇到麻烦，通常是因为该CD还挂载在虚拟目录里。先卸载它，然后再去尝试弹出。</li></ul><p><code>df -h</code> 查看所有已挂载磁盘的使用情况，-h把磁盘空间以易读的形式显示</p><hr><p><em><strong>sort</strong></em><br><code>sort</code> 按指定的默认语言的排序规则对文件中的数据进行排序</p><ul><li>-d 仅考虑空白和字母</li><li>-n 按字符串数值排序</li><li>-u 消除输出中重复的行</li><li>-r 逆序排列</li><li>-o 指定输出文件</li></ul><hr>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-command/">Linux命令</category>
      
      
      <category domain="http://singlewang.top/tags/Linux/">Linux</category>
      
      <category domain="http://singlewang.top/tags/Linux%E5%91%BD%E4%BB%A4/">Linux命令</category>
      
      
      <comments>http://singlewang.top/2022/05/03/linux/linux-command/linux%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DPDK基础</title>
      <link>http://singlewang.top/2022/04/29/dpdk/dpdk-base/dpdk/</link>
      <guid>http://singlewang.top/2022/04/29/dpdk/dpdk-base/dpdk/</guid>
      <pubDate>Fri, 29 Apr 2022 03:12:00 GMT</pubDate>
      
        
        
      <description>&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#-dpdk%E5%AD%A6%</description>
        
      
      
      
      <content:encoded><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#-dpdk%E5%AD%A6%E4%B9%A0"># DPDK学习</a></li><li><a href="#-1dpdk%E7%AE%80%E4%BB%8B">## 1.DPDK简介</a></li><li><a href="#-11dpdk%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84">### 1.1DPDK软件架构</a><ul><li><a href="#111%E5%BA%95%E9%83%A8%E5%86%85%E6%A0%B8%E6%80%81">1.1.1底部内核态</a></li><li><a href="#2%E4%B8%8A%E5%B1%82%E7%94%A8%E6%88%B7%E6%80%81">2上层用户态</a></li><li><a href="#12%E5%B7%A8%E9%A1%B5%E6%8A%80%E6%9C%AF">1.2巨页技术</a></li><li><a href="#13%E8%BD%AE%E8%AF%A2%E6%8A%80%E6%9C%AF">1.3轮询技术</a></li><li><a href="#14cpu%E4%BA%B2%E5%92%8C%E6%8A%80%E6%9C%AF">1.4CPU亲和技术</a></li><li><a href="#15dpdk%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0">1.5DPDK性能影响因素</a></li><li><a href="#16%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">1.6内存管理</a><ul><li><a href="#161%E5%86%85%E5%AD%98%E5%A4%9A%E9%80%9A%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8">1.6.1内存多通道的使用</a></li><li><a href="#162%E5%86%85%E5%AD%98%E5%A4%8D%E5%88%B6">1.6.2内存复制</a></li><li><a href="#163%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">1.6.3内存分配</a></li><li><a href="#164numa%E6%9E%B6%E6%9E%84">1.6.4NUMA架构</a></li><li><a href="#165cpu%E6%A0%B8%E9%97%B4%E6%97%A0%E9%94%81%E9%80%9A%E4%BF%A1">1.6.5CPU核间无锁通信</a></li></ul></li></ul></li><li><a href="#-2dpdk%E5%BA%93%E5%87%BD%E6%95%B0">## 2.DPDK库函数</a></li><li><a href="#-%E4%BB%8E%E4%BB%A3%E7%A0%81%E8%A7%92%E5%BA%A6rte%E6%98%AF%E6%8C%87runtime-environmenteal%E6%98%AF%E6%8C%87environment-abstraction-layerdpdk%E7%9A%84%E4%B8%BB%E8%A6%81%E5%AF%B9%E5%A4%96%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%E9%83%BD%E6%98%AF%E4%BB%A5rte_%E4%BD%9C%E4%B8%BA%E5%89%8D%E7%BC%80%E6%8A%BD%E8%B1%A1%E5%8C%96%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%85%B8%E5%9E%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF">&gt; 从代码角度，rte是指<code>runtime environment</code>,eal是指<code>environment abstraction layer</code>。dpdk的主要对外函数接口都是以rte_作为前缀，抽象化函数接口是典型的软件设计思路。</a><ul><li><a href="#21eal%E5%BA%93">2.1EAL库</a><ul><li><a href="#211%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8">2.1.1内核初始化与启动</a></li><li><a href="#212%E5%86%85%E5%AD%98">2.1.2内存</a></li><li><a href="#213%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BA%B2%E5%92%8C%E6%80%A7">2.1.3多线程与亲和性</a></li></ul></li><li><a href="#2ring%E5%BA%93">2.Ring库</a><ul><li><a href="#221%E5%8D%95%E6%B6%88%E8%B4%B9%E8%80%85%E5%85%A5%E9%98%9F">2.2.1单消费者入队</a></li><li><a href="#222%E5%8D%95%E6%B6%88%E8%B4%B9%E8%80%85%E5%87%BA%E9%98%9F">2.2.2单消费者出队</a></li></ul></li><li><a href="#23mempool%E5%BA%93">2.3Mempool库</a></li><li><a href="#24mbuf%E5%BA%93">2.4mbuf库</a><ul><li><a href="#241%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8">2.4.1数据存储</a></li><li><a href="#242%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE">2.4.2缓冲区分配与释放</a></li><li><a href="#243%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C">2.4.3相关操作</a></li></ul></li><li><a href="#25pmd%E9%A9%B1%E5%8A%A8">2.5PMD驱动</a></li><li><a href="#26ivshmem%E5%BA%93">2.6IVSHMEM库</a></li><li><a href="#27timer%E5%BA%93">2.7Timer库</a></li><li><a href="#28-lpm%E5%BA%93">2.8 LPM库</a></li><li><a href="#29hash%E5%BA%93">2.9Hash库</a></li><li><a href="#210%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%94%AF%E6%8C%81">2.10多进程支持</a></li></ul></li><li><a href="#3dpdk%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2">3DPDK安装与部署</a><ul><li><a href="#31%E8%BF%90%E8%A1%8Cdpdk%E5%BA%94%E7%94%A8%E8%A6%81%E6%B1%82">3.1运行DPDK应用要求</a></li><li><a href="#32%E4%BD%BF%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91dpdk">3.2使用源代码编译DPDK</a><ul><li><a href="#321%E5%AE%89%E8%A3%85dpdk%E5%AE%89%E8%A3%85%E5%8C%85">3.2.1安装DPDK安装包</a></li><li><a href="#322%E5%AE%89%E8%A3%85dpdk%E7%9B%AE%E6%A0%87%E7%8E%AF%E5%A2%83">3.2.2安装DPDK目标环境</a></li><li><a href="#323%E6%9F%A5%E7%9C%8B%E5%B7%B2%E7%BB%8F%E5%AE%89%E8%A3%85%E7%9A%84dpdk%E7%8E%AF%E5%A2%83">3.2.3查看已经安装的DPDK环境</a></li><li><a href="#324%E5%90%AF%E7%94%A8dpdk%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4io%E6%A8%A1%E5%9D%97">3.2.4启用DPDK用户空间I&#x2F;O模块</a></li><li><a href="#325%E5%8A%A0%E8%BD%BDvfio%E6%A8%A1%E5%9D%97">3.2.5加载VFIO模块</a></li><li><a href="#326%E5%9C%A8%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BB%91%E5%AE%9A%E8%A7%A3%E9%99%A4%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3">3.2.6在内核模块绑定&#x2F;解除网络端口</a></li></ul></li><li><a href="#33%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B%E7%A8%8B%E5%BA%8F">3.3编译和运行实例程序</a><ul><li><a href="#331%E7%BC%96%E8%AF%91%E7%A4%BA%E4%BE%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">3.3.1编译示例应用程序</a></li><li><a href="#332%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">3.3.2运行实例应用程序</a></li><li><a href="#333%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%80%BB%E8%BE%91%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8">3.3.3应用程序的逻辑核的使用</a></li></ul></li></ul></li><li><a href="#-34%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E9%85%8D%E7%BD%AE">### 3.4使用脚本配置</a></li><li><a href="#-4dpdk%E8%87%AA%E5%B8%A6%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95">## 4DPDK自带应用软件调试</a><ul><li><a href="#41%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8%E4%BE%8B">4.1命令行应用例</a></li><li><a href="#42helloworld%E5%BA%94%E7%94%A8%E4%BE%8B">4.2HelloWorld应用例</a><ul><li><a href="#421%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E">4.2.1代码说明</a></li></ul></li><li><a href="#43l2%E8%BD%AC%E5%8F%91%E5%BA%94%E7%94%A8%E4%BE%8B">4.3L2转发应用例</a><ul><li><a href="#431%E6%A6%82%E8%BF%B0">4.3.1概述</a></li></ul></li></ul></li><li><a href="#-44l3%E8%BD%AC%E5%8F%91%E5%BA%94%E7%94%A8%E4%BE%8B">### 4.4L3转发应用例</a><ul><li><a href="#441%E6%A6%82%E8%BF%B0">4.4.1概述</a></li><li><a href="#442%E8%BF%90%E8%A1%8C%E8%BD%AC%E5%8F%91%E5%BA%94%E7%94%A8%E4%BE%8B">4.4.2运行转发应用例</a></li><li><a href="#443%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E">4.4.3代码说明</a></li><li><a href="#45qos%E8%B0%83%E5%BA%A6%E5%BA%94%E7%94%A8%E4%BE%8B">4.5QoS调度应用例</a><ul><li><a href="#451%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E">4.5.1代码说明</a></li></ul></li><li><a href="#46%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BA%94%E7%94%A8%E4%BE%8B">4.6定时器应用例</a><ul><li><a href="#461%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E">4.6.1代码说明</a></li></ul></li><li><a href="#47%E5%9F%BA%E6%9C%AC%E8%BD%AC%E5%8F%91%E5%BA%94%E7%94%A8%E4%BE%8Bskeleton">4.7基本转发应用例(skeleton)</a><ul><li><a href="#471%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E">4.7.1代码说明</a></li></ul></li></ul></li><li><a href="#5dpdk%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91">5DPDK应用开发</a><ul><li><a href="#51%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87">5.1网卡设备</a><ul><li><a href="#511%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8">5.1.1设备驱动</a></li><li><a href="#512%E5%BA%94%E7%94%A8%E6%8E%A5%E5%8F%A3">5.1.2应用接口</a></li><li><a href="#513%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3">5.1.3设备接口</a></li></ul></li><li><a href="#52%E8%BF%9B%E7%A8%8B">5.2进程</a><ul><li><a href="#521-%E7%BA%BF%E7%A8%8B">5.2.1 线程</a></li><li><a href="#522%E5%8D%95%E8%BF%9B%E7%A8%8B">5.2.2单进程</a></li><li><a href="#523%E5%A4%9A%E8%BF%9B%E7%A8%8B">5.2.3多进程</a></li></ul></li></ul></li></ul><!-- /code_chunk_output --><h1 id="DPDK学习"><a href="#DPDK学习" class="headerlink" title="DPDK学习"></a>DPDK学习</h1><hr><h2 id="1-DPDK简介"><a href="#1-DPDK简介" class="headerlink" title="1.DPDK简介"></a>1.DPDK简介</h2><hr><h3 id="1-1DPDK软件架构"><a href="#1-1DPDK软件架构" class="headerlink" title="1.1DPDK软件架构"></a>1.1DPDK软件架构</h3><hr><h4 id="1-1-1底部内核态"><a href="#1-1-1底部内核态" class="headerlink" title="1.1.1底部内核态"></a>1.1.1底部内核态</h4><p>最底部的内核态有两个模块组成：<code>KNI</code>和<code>IGB_UIO</code>模块，KNI提供给用户一个使用linux内核态的协议栈以及传统的linux网络工具，IGB_UIO借助UIO技术，在初始化过程中件将硬件寄存器映射到用户态。</p><p><em>UIO技术</em></p><hr><h4 id="2上层用户态"><a href="#2上层用户态" class="headerlink" title="2上层用户态"></a>2上层用户态</h4><p>上层用户态主要包括核心部件库，平台相关模块，轮询驱动模式驱动模块。</p><hr><h3 id="1-2巨页技术"><a href="#1-2巨页技术" class="headerlink" title="1.2巨页技术"></a>1.2巨页技术</h3><p>处理器的内存怒管理包含两个概念：物理内存和虚拟内存，linux操作系统中，物理内存按照帧管理，虚拟内存按照页管理。Intel处理使用一块缓存保存地址转换查找的结果，缓存称为<code>TLB(Translation Lookaside Buffer)</code>，如果查找不到相应的映射，就会发生<code>TLB miss</code>，而linux的一般页的大小为4KB，为了减少TLB miss的发生则采用2M或者1GB的大页表。DPDK则利用巨页技术，所有的内存都从巨页里分配，实现对内存池的管理，并预先分配好同样大小的<code>mbuf</code>,給数据分组使用</p><hr><h3 id="1-3轮询技术"><a href="#1-3轮询技术" class="headerlink" title="1.3轮询技术"></a>1.3轮询技术</h3><p>传统网卡的报文接收&#x2F;发送过程中，网卡硬件接收到网络报文，需要发送中断到CPU,通知应用软件有网络报文需要处理。对于高性能的网络处理应用，频繁的中断处理开销极大程度的降低了网络应用程序的性能。</p><p>DPDK使用轮询技术处理网络报文。网卡接收到报文之后，直接将报文保存在处理器缓存中，应用软件周期性的轮询是否有新报文处理。整个过程没有中断。</p><hr><h3 id="1-4CPU亲和技术"><a href="#1-4CPU亲和技术" class="headerlink" title="1.4CPU亲和技术"></a>1.4CPU亲和技术</h3><p>CPU亲和技术就是将某个进程或者线程绑定到特定的一个或者多个核上执行，而不被迁移到其他核上，保证了专用程序的性能。</p><hr><h3 id="1-5DPDK性能影响因素"><a href="#1-5DPDK性能影响因素" class="headerlink" title="1.5DPDK性能影响因素"></a>1.5DPDK性能影响因素</h3><p>&#x3D;&#x3D;CPU频率越高，DPDK性能越高&#x3D;&#x3D;<br>&#x3D;&#x3D;缓存越大，DPDK性能越高&#x3D;&#x3D;<br>&#x3D;&#x3D;PCIe数据通路的数目&#x3D;&#x3D;<br>&#x3D;&#x3D;NUMA&#x3D;&#x3D; </p><p><em>NUMA</em></p><hr><h3 id="1-6内存管理"><a href="#1-6内存管理" class="headerlink" title="1.6内存管理"></a>1.6内存管理</h3><p>降低访存开销。无论是CPU指令还是DMA，对于内存子系统都会访问频繁。利用已知的方法来减少访存的开销能够有效地提升性能。</p><hr><h4 id="1-6-1内存多通道的使用"><a href="#1-6-1内存多通道的使用" class="headerlink" title="1.6.1内存多通道的使用"></a>1.6.1内存多通道的使用</h4><p>现代的内存控制器都支持内存多通道，每个通道都有一个带宽上限，如果内存访问都在一个通道上，就会造成性能瓶颈。<br>DPDK的<code>Mempool</code>库把所有的对象分配在不同的内存通道上，保证尽可能的将内存访问均匀平滑的进行。</p><hr><h4 id="1-6-2内存复制"><a href="#1-6-2内存复制" class="headerlink" title="1.6.2内存复制"></a>1.6.2内存复制</h4><p>不要使用<code>memcpy()</code>或<code>strcpy()</code>,DPDK提供了<code>rte_memcpy()</code>.</p><hr><h4 id="1-6-3内存分配"><a href="#1-6-3内存分配" class="headerlink" title="1.6.3内存分配"></a>1.6.3内存分配</h4><p>不建议使用<code>malloc()</code>，DPDK提供了<code>rte_malloc()</code>。</p><hr><h4 id="1-6-4NUMA架构"><a href="#1-6-4NUMA架构" class="headerlink" title="1.6.4NUMA架构"></a>1.6.4NUMA架构</h4><p><code>NUMA（非统一访问内存）</code>架构<code>SMP(对称多处理)</code>架构是两种典型的内存访问架构</p><hr><h4 id="1-6-5CPU核间无锁通信"><a href="#1-6-5CPU核间无锁通信" class="headerlink" title="1.6.5CPU核间无锁通信"></a>1.6.5CPU核间无锁通信</h4><p>如果想建立一个基于消息传递的核间通信机制，可以使用DPDK ring API，该API是一个无锁的实现。支持批量和突发访问。</p><hr><h2 id="2-DPDK库函数"><a href="#2-DPDK库函数" class="headerlink" title="2.DPDK库函数"></a>2.DPDK库函数</h2><hr><p><code>rte_eal(DPDK环境抽象)</code>以及<code>libc(Linux下的c函数库)</code>是核心组件</p><blockquote><p>从代码角度，rte是指<code>runtime environment</code>,eal是指<code>environment abstraction layer</code>。dpdk的主要对外函数接口都是以rte_作为前缀，抽象化函数接口是典型的软件设计思路。</p></blockquote><hr><h3 id="2-1EAL库"><a href="#2-1EAL库" class="headerlink" title="2.1EAL库"></a>2.1EAL库</h3><p>EAL(环境抽象层)用于获取底层资源。主要提供DPDK装载与启动，内核亲和性与分配，系统内存预留等服务。<br>在内存层面，EAL通过<code>mmap()</code>函数在巨页表内进行物理内存分配。以此来提高性能。</p><hr><h4 id="2-1-1内核初始化与启动"><a href="#2-1-1内核初始化与启动" class="headerlink" title="2.1.1内核初始化与启动"></a>2.1.1内核初始化与启动</h4><p>内核初始化由<a href="http://www.dpdk.org/doc/api/"><code>rte_eal_init()</code></a>完成。主要包括内存，日志，PCI等方面的初始化工作。同时启动逻辑核线程。<br>EAL主要由<code>pthread</code>的库的调用组成，主要函数有<code>pthread_self()</code>,<code>pthread_creat()</code>,<code>pthread_setaffinity_np()</code>。</p><hr><h4 id="2-1-2内存"><a href="#2-1-2内存" class="headerlink" title="2.1.2内存"></a>2.1.2内存</h4><p>物理内存映射EAL的特点，物理内存可以是不连续的，EAL通过描述符来描述内存，每一个描述符表示一个连续的内存分配。</p><hr><h4 id="2-1-3多线程与亲和性"><a href="#2-1-3多线程与亲和性" class="headerlink" title="2.1.3多线程与亲和性"></a>2.1.3多线程与亲和性</h4><p>DPDK通常采用一个核匹配一个线程避免过度切换，但是缺乏灵活性。<br>为了提升灵活性，目前方法是设置线程与CPU以及CPU集合的亲和性。有两个公共线程API供使用。<code>rte_thread_set_affinity</code>,<code>rte_pthread_get_affinity</code>。</p><hr><h3 id="2-Ring库"><a href="#2-Ring库" class="headerlink" title="2.Ring库"></a>2.<span class="exturl" data-url="aHR0cDovL3d3dy5kcGRrLm9yZy9kb2MvZ3VpZGVzL3Byb2dfZ3VpZGUvcmluZ19saWIuaHRtbA==">Ring库</span></h3><p>DPDK中的Ring库用于管理队列，主要属性如下：</p><ul><li>FIFO;</li><li>可以设置空间最大值，指针存储在表中；</li><li>多消费者或者单消费者出队，&#x3D;&#x3D;消费者是指数据对象出队机制&#x3D;&#x3D;；</li><li>无锁；</li><li>多生产者或单生产者入队，&#x3D;&#x3D;其中生产者是指数据对象入队机制&#x3D;&#x3D;。</li></ul><p>&#x3D;&#x3D;优点&#x3D;&#x3D;</p><ol><li>数据交换速度相对较快。</li><li>比全无锁队列简单；</li><li>适用于巨型数据的入队和出队操作；</li></ol><p>&#x3D;&#x3D;缺点&#x3D;&#x3D;</p><ol><li>空间大小固定</li><li>Ring很多时，内存消耗很大，一个空的Ring至少包含N个指针。</li></ol><p>&#x3D;&#x3D;特性&#x3D;&#x3D;</p><ol><li>一个Ring用全局唯一的名字标识。</li></ol><hr><h4 id="2-2-1单消费者入队"><a href="#2-2-1单消费者入队" class="headerlink" title="2.2.1单消费者入队"></a>2.2.1单消费者入队</h4><ol><li>对象入队前<br>Ring结构体变量指针<code>ring-&gt;prod_head</code>,<code>ring-&gt;cons_tail</code>被复制到本地变量中，<code>prod_next</code>指向下一个元素。</li><li>入队<br>修改<code>ring-&gt;prod_head</code>的指针位置，和<code>prod_next</code>相同。指向新增对象的指针被复制。</li><li>入队后指针位置调整。<br>当对象入队后，<code>ring-&gt;prod_tail</code>指针位置修改到<code>ring-&gt;prod_head</code>。</li></ol><hr><h4 id="2-2-2单消费者出队"><a href="#2-2-2单消费者出队" class="headerlink" title="2.2.2单消费者出队"></a>2.2.2单消费者出队</h4><p>单消费者从Ring出队，限制条件只有消费者的head和tai可以修改。</p><ol><li>对象出队前<br>将<code>ring-&gt;cons_head</code>,<code>ring-&gt;prod_tail</code>复制到本地变量中，<code>cons_next</code>指向下一个元素。</li><li>对象出队中<br>将<code>ring-&gt;cons_head</code>指向<code>cons_next</code>的位置，指向出队对象的指针由用户给出。</li><li>对象出队后<br>将<code>ring-&gt;cons_tail</code>指向<code>cons_next</code>的位置。</li></ol><hr><h3 id="2-3Mempool库"><a href="#2-3Mempool库" class="headerlink" title="2.3Mempool库"></a>2.3<span class="exturl" data-url="aHR0cDovL3d3dy5kcGRrLm9yZy9kb2MvZ3VpZGVzL3Byb2dfZ3VpZGUvTWVtcG9vbF9saWIuaHRtbA==">Mempool库</span></h3><p>DPDK的Mempool(内存池)库主要供mbuf(内存缓冲区)和EAL使用。<br>DPDK中，Mempool使用字符串名字进行标识，通过Ring方式存储对象。<br>在多核情况中，多个核访问同一个内存池的频率很高，为了避免过多的访问请求，内存池分配器通过几乎无锁的缓存技术保证每一个核的缓存以及大块数据的访问。</p><hr><h3 id="2-4mbuf库"><a href="#2-4mbuf库" class="headerlink" title="2.4mbuf库"></a>2.4mbuf库</h3><p>mbuf库用来分配和释放缓冲区，该缓冲区存储在内存池中，使用Mempool库，Mempool中的数据结构<code>rte_mbuf</code>是承载网络数据分组的缓冲区或一般的控制区。</p><hr><h4 id="2-4-1数据存储"><a href="#2-4-1数据存储" class="headerlink" title="2.4.1数据存储"></a>2.4.1数据存储</h4><p>存储数据分组数据有两种方法：</p><ol><li>使用一个大小固定的单一内存缓冲区存储数据分组；</li><li>使用分散的内存缓冲区来存储数据。</li></ol><p>&#x3D;&#x3D;第一种方法的优点&#x3D;&#x3D;<br>对整个内存的操作只有一对分配和释放操作。<br>&#x3D;&#x3D;第二种方法的优点&#x3D;&#x3D;<br>灵活性好，可以将元数据与数据分组数据完全分离</p><p>&#x3D;&#x3D;DPDP采用第一中方法存储数据&#x3D;&#x3D;</p><hr><h4 id="2-4-2缓冲区分配与释放"><a href="#2-4-2缓冲区分配与释放" class="headerlink" title="2.4.2缓冲区分配与释放"></a>2.4.2缓冲区分配与释放</h4><p>mbuf库使用Mempool库来分配缓冲区<br>内存释放<code>rte_ctrlmbuf_free(m)</code>,<code>rte_pktmbuf_free(m)</code>;</p><h4 id="2-4-3相关操作"><a href="#2-4-3相关操作" class="headerlink" title="2.4.3相关操作"></a>2.4.3相关操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rte_pktmbuf_data_len(m) <span class="comment">//获取数据长度定义宏操作</span></span><br><span class="line">rte_ctrlmbuf_data(m)    <span class="comment">//获取数据起始地址指针宏操作</span></span><br><span class="line">rte_pktmbuf_prepend(<span class="keyword">struct</span> rte_mbuf *m,<span class="type">uint16_t</span> len)           <span class="comment">//在数据前新增数据</span></span><br><span class="line">rte_pktmbuf_append(<span class="keyword">struct</span> rte_mbuf *m,<span class="type">uint16_t</span> len)                    <span class="comment">//在数据后添加数据</span></span><br><span class="line">rte_pktmbuf_adj(<span class="keyword">struct</span> rte_mbuf *m,<span class="type">uint16_t</span> len)                    <span class="comment">//在缓冲区起始位置移除数据</span></span><br><span class="line">rte_pktmbuf_trim(<span class="keyword">struct</span> rte_mbuf *m,<span class="type">uint16_t</span> len)                    <span class="comment">//在缓冲区尾部位置移除数据</span></span><br></pre></td></tr></table></figure><p>所有的网络应用都可以用<code>mbufs</code>传输网络数据分组</p><hr><h3 id="2-5PMD驱动"><a href="#2-5PMD驱动" class="headerlink" title="2.5PMD驱动"></a>2.5PMD驱动</h3><p>DPDK提供1Gbit&#x2F;s,10Gbit&#x2F;s,40Gbit&#x2F;s以及虚拟网卡的<code>PMD(Poll Mode Driver轮询模式驱动)</code>。<br>一个PMD可以无中断的直接访问RX和TX，进而快速的接收、处理和转发数据分组。<br>DPDK环境下的数据分组处理有两种模式：<code>run-to-completion</code>和<code>pipe-line</code></p><ol><li><strong>&#x3D;&#x3D;run-to-completion模式&#x3D;&#x3D;</strong><br>指定端口的RXring被选中接收数据分组，然后数据分组在相同的核上进行处理并放置在该端口的TX ring上通过API发送。<br>&#x3D;&#x3D;这种模式属于同步模式&#x3D;&#x3D;</li><li><strong>&#x3D;&#x3D;pipe-line模式&#x3D;&#x3D;</strong><br>一个核选中一个或者多个端口RX ring，数据分组接收后，通过一个ring传递给另一个核进行处理，处理完成后将数据分组放在该端口的TX ring上，通过API进行转发。<br>&#x3D;&#x3D;这种模式属于异步模式&#x3D;&#x3D;，一些核用来接收数据分组，一些核处理先前接收的分组。</li></ol><p><strong>&#x3D;&#x3D;配置&#x3D;&#x3D;</strong><br>PMD为发送和接收队列提供一些配置：</p><ol><li>发送ring包含的描述符数量</li><li>socket标识符（描述对于DMA内存区的标识），DMA内存区用于在NUMA结构中分配给发送ring</li><li>发送队列相关阈值</li></ol><blockquote><p>当配置DCB操作时，在端口初始化时，发送队列和接收队列的个数必须设置为128.</p></blockquote><h3 id="2-6IVSHMEM库"><a href="#2-6IVSHMEM库" class="headerlink" title="2.6IVSHMEM库"></a>2.6IVSHMEM库</h3><p>DPDK IVSHMEM库主要作用是在虚拟机内快速共享零复制数据。</p><p>此库可以将几个巨页映射为一个单一的IVSHMEM设备，同时，将一个元数据文件映射出一个IVSHMEM段用来区分DPDK和非DPDK的IVSHMEM设备。</p><p><em>元数据文件？</em></p><p>&#x3D;&#x3D;相关API&#x3D;&#x3D;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rte_ivhshmem_metadata_create()   <span class="comment">//创建元数据文件</span></span><br><span class="line">rte_ivhshmem_metadata_add_memzone() <span class="comment">//添加一个内存区（rte_memzone）到元数据文件</span></span><br><span class="line">rte_ivhshmem_metadata_add_ring() <span class="comment">//添加ring到元数据文件</span></span><br><span class="line">rte_ivhshmem_metadata_add_mempool(rte_Mempool) <span class="comment">//添加内存池到元数据文件</span></span><br><span class="line">rte_ivhshmem_matadata_cmdline_generate() <span class="comment">//为QEMU生成命令行</span></span><br></pre></td></tr></table></figure><p><em>数据结构必须完整属于DPDK巨页内存才能正确工作，一个VM可以支持多个元数据文件</em></p><hr><h3 id="2-7Timer库"><a href="#2-7Timer库" class="headerlink" title="2.7Timer库"></a>2.7Timer库</h3><p>Timer（定时器）库为DPDK提供了计时器服务，用于保证执行单元能够执行异步回调功能。特征如下：</p><ol><li>定时器的使用频率可以是周期性或者一次性的</li><li>定时器可以从一个核装载，在另一个核执行</li><li>定时器可以提供较高的精准度</li><li>如果没有应用程序需要，定时器为关闭状态</li></ol><p>定时器的结构主要包含一个状态机，状态机的状态如下：</p><ol><li>STOPPED:没有所属者，不在列表中。</li><li>CONFIG:属于一个核，不能被另外的核修改</li><li>PENDING:属于一个核，存在一个列表中</li><li>RUNNING:属于一个核，不能被另外的核修改，存在与一个列表中。</li></ol><p><em>每一个核的定时器列表维护着那些没有过期的且还在跳表中的定时器。在64bit平台上，定时器的值不需要加锁来检验</em></p><hr><h3 id="2-8-LPM库"><a href="#2-8-LPM库" class="headerlink" title="2.8 LPM库"></a>2.8 LPM库</h3><p>LPM(Longest Prefix Match 最长前缀匹配)，其典型应用场景在IP转发过程中。</p><hr><h3 id="2-9Hash库"><a href="#2-9Hash库" class="headerlink" title="2.9Hash库"></a>2.9Hash库</h3><p>Hash(散列)库，可以通过该库创建散列表，用于快速路由，散列表是一个用于查找数据的优化数据结构，每一个条目由唯一关键字进行标识.<br>DPDK Hash要求在散列创建时，所有关键字具有想通过字节数，。</p><p>主要操作如下：</p><ol><li>增加记录</li><li>删除记录</li><li>查找记录</li></ol><hr><h3 id="2-10多进程支持"><a href="#2-10多进程支持" class="headerlink" title="2.10多进程支持"></a>2.10<span class="exturl" data-url="aHR0cDovL3d3dy5kcGRrLm9yZy9kb2MvZ3VpZGVzL3NhbXBsZV9hcHBfdWcvbXVsdGlfcHJvY2Vzcy5odG1s">多进程支持</span></h3><p>DPDK多线程机制允许一组DPDK进程一起执行数据分组处理或者其他任务<br>EAL允许生成两个DPDK进程，每个进程具有不同的巨页内存权限。</p><ul><li>主进程：可以初始化共享内存，拥有所有共享内存的管理权限。</li><li>辅进程：不能初始化共享内存，但是可以连接预初始化的共享内存并且在该内存中创建对象。<br>命令行参数：</li></ul><ul><li>proc-type：进程类型，primary或secondary</li><li>file-prefix：进程不同步非共同内存区域</li></ul><p>多进程的局限性：</p><ol><li>多进程的特点是要求具有&#x3D;&#x3D;完全相同&#x3D;&#x3D;的巨页内存映射</li><li>所有DPDK进程在使用共享内存时必须遵守严格的核分配</li><li>不能使用辅进程发送中断信息</li><li>DPDK不支持基于不同编译环境的多进程指针</li></ol><hr><h2 id="3DPDK安装与部署"><a href="#3DPDK安装与部署" class="headerlink" title="3DPDK安装与部署"></a>3DPDK安装与部署</h2><hr><h3 id="3-1运行DPDK应用要求"><a href="#3-1运行DPDK应用要求" class="headerlink" title="3.1运行DPDK应用要求"></a>3.1运行DPDK应用要求</h3><ol><li><p>内核版本高于2.6.33</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r //查看内核版本</span><br></pre></td></tr></table></figure></li><li><p>glibc版本高于2.7</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd -version</span><br></pre></td></tr></table></figure></li><li><p>kernel配置<br>大多数linux操作系统中，DPDK提供的内核配置能正常运行。<br>如果是其他操作系统，需打开以下选项：</p></li></ol><ul><li>UIO支持</li><li>HUGETLBFS</li><li>PROC_PAGE_MONITOR</li></ul><ol start="4"><li>巨页的使用</li></ol><ul><li>&#x3D;&#x3D;预留巨页给DPDK使用&#x3D;&#x3D;</li></ul><p>巨页的分配应在开机时或者系统启动后立即进行，防止内存在物理内存中被碎片化。<br>要预留2MB的1024页使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugepages = 1024</span><br></pre></td></tr></table></figure><p>对于其他巨页，如1GB页面，页面尺寸必须特别指定或者将该尺寸设置为系统默认的巨页大小。<br>预留4个1GB页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_hugepagesz=1 Ghugepagesz=1G hugepages=4</span><br></pre></td></tr></table></figure><blockquote><p>一个CPU支持的巨页大小由英特尔架构的CPU标志来决定。</p></blockquote><p>对于2MB的页面，也可以在系统启动后设置。对于单节点系统，使用命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1024 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</span><br></pre></td></tr></table></figure><p>在NUMA架构的系统下，需要对每一个NUMA节点分配巨页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 1024 &gt; /sys/devices/system/node/node0/hugepages/hugepages-2048kB/nr_hugepages</span><br><span class="line">echo 1024 &gt; /sys/devices/system/node/node1/hugepages/hugepages-2048kB/nr_hugepages</span><br></pre></td></tr></table></figure><blockquote><p>对于1GB页面，不能在系统启动后在预留巨页大小</p></blockquote><ul><li>&#x3D;&#x3D;DPDK中使用巨页&#x3D;&#x3D;</li></ul><p>一旦巨页被预留成功就可以在DPDK中使用巨页内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/huge</span><br><span class="line">mount -t hugetlbfs nodev /mnt/huge</span><br></pre></td></tr></table></figure><p>如果需要永久使用一个挂载点，可以将这个挂载点的信息写入&#x2F;etc&#x2F;fstab文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodev /mnt/huge hugetlbfs default 0 0</span><br></pre></td></tr></table></figure><p>对于1GB页面，页面大小必须指定为一个安装选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodev /mnt/huge_1GB hugetlbfs pagesize=1GB 0 0</span><br></pre></td></tr></table></figure><hr><h3 id="3-2使用源代码编译DPDK"><a href="#3-2使用源代码编译DPDK" class="headerlink" title="3.2使用源代码编译DPDK"></a>3.2使用源代码编译DPDK</h3><h4 id="3-2-1安装DPDK安装包"><a href="#3-2-1安装DPDK安装包" class="headerlink" title="3.2.1安装DPDK安装包"></a>3.2.1安装DPDK安装包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unzip DPDK-&lt;version&gt;.zip</span><br><span class="line">cd DPDK-&lt;version&gt;</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>DPDK由以下目录组成：</p><ul><li>lib目录：DPDK库的源代码</li><li>drivers目录：DPDK PMD的源代码</li><li>app目录：DPDK应用程序的源代码</li><li>examples目录：DPDP应用程序示例的源代码</li><li>config，tools，scripts，mkmul：框架相关的生成文件，脚本核配置文件。</li></ul><hr><h4 id="3-2-2安装DPDK目标环境"><a href="#3-2-2安装DPDK目标环境" class="headerlink" title="3.2.2安装DPDK目标环境"></a>3.2.2安装DPDK目标环境</h4><p>使用英特尔C++编译器时（ICC）时，编译编译命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /opt/intel/bin/iccvars.sh intel64</span><br><span class="line">source /opt/intel/bin/iccvars.sh ia32</span><br></pre></td></tr></table></figure><p>要安装核编译目标文件，使用<code>make install T=&lt;target&gt;</code>, T&#x3D; &lt;DPDK根目录&gt;，如使用ICC编译64位DPDK目标文件时，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install T=x86_64-native-linuxapp-icc</span><br></pre></td></tr></table></figure><p>使用gcc编译64位版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install T=x86_64-native-linuxapp-gcc</span><br></pre></td></tr></table></figure><hr><h4 id="3-2-3查看已经安装的DPDK环境"><a href="#3-2-3查看已经安装的DPDK环境" class="headerlink" title="3.2.3查看已经安装的DPDK环境"></a>3.2.3查看已经安装的DPDK环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls x86_64-native-linuxapp-gcc</span><br></pre></td></tr></table></figure><hr><h4 id="3-2-4启用DPDK用户空间I-x2F-O模块"><a href="#3-2-4启用DPDK用户空间I-x2F-O模块" class="headerlink" title="3.2.4启用DPDK用户空间I&#x2F;O模块"></a>3.2.4启用DPDK用户空间I&#x2F;O模块</h4><p>大部分情况下，linux标准内核模块<code>uio_pci_generic</code>可以提供UIO能力，可用如下命令加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe uio_pci_generic</span><br></pre></td></tr></table></figure><p>作为该模块的替代模块komd子目录<code>igb_uio</code>模块，可用如下命令加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe uio</span><br><span class="line">sudo insmod /kmod/igb_uio.ko</span><br></pre></td></tr></table></figure><blockquote><p>对于一些缺少对传统中断支持的设备，如虚拟功能(VF)器件，可能需要用<code>igb_uio</code>模块替代<code>uio_pci_generic</code>模块</p></blockquote><h4 id="3-2-5加载VFIO模块"><a href="#3-2-5加载VFIO模块" class="headerlink" title="3.2.5加载VFIO模块"></a>3.2.5加载VFIO模块</h4><p>对于支持VFIO功能的平台，UIO是可选的，利用VFIO运行DPDK应用程序时，必须加载<code>vfio-PCI</code>模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe vfio-pci</span><br></pre></td></tr></table></figure><blockquote><p>内核必须支持VFIO使用，linux3.6.0内核及以上版本已经包含了VFIO模块，通常默认时加载的。<br>使用VFIO时，服务器系统内核核BIOS必须支持I&#x2F;O虚拟化。 </p></blockquote><h4 id="3-2-6在内核模块绑定-x2F-解除网络端口"><a href="#3-2-6在内核模块绑定-x2F-解除网络端口" class="headerlink" title="3.2.6在内核模块绑定&#x2F;解除网络端口"></a>3.2.6在内核模块绑定&#x2F;解除网络端口</h4><p>使用tools目录下的<code>dpdk_nic_bind.py</code>查看当前网口的驱动状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tools/dpdk_nic_bind.py --status</span><br></pre></td></tr></table></figure><blockquote><p>绑定核接触绑定的操作需要root权限，但是查看网卡信息任何用户都可以</p></blockquote><p>绑定设备的eth1，04:00.1到<code>uio_pci_generic</code>驱动，使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./tools/dpdk_nic_bind.py --bind=ui_pci_generic 04:00.1</span><br><span class="line">或者</span><br><span class="line">./tools/dpdk_nic_bind.py --bind=ui_pci_generic eth1</span><br></pre></td></tr></table></figure><p>恢复设备08:00.1到原来的绑定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./root/dpdk_nic_bind.py --bind=ixgbe 08:00.1</span><br></pre></td></tr></table></figure><hr><h3 id="3-3编译和运行实例程序"><a href="#3-3编译和运行实例程序" class="headerlink" title="3.3编译和运行实例程序"></a>3.3编译和运行实例程序</h3><p> 当应用程序在linux上DPDK环境编译时，必须输出下列变量：<br> &#x3D;&#x3D;RTE_SDK&#x3D;&#x3D;:指向DPDK的安装目录<br> &#x3D;&#x3D;RTE_TARGET&#x3D;&#x3D;:指向DPDK目标环境的目录<br>ex:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export RTE_SDK=$HOME/DPDK</span><br><span class="line">export RTE_TARGET=$HOME</span><br></pre></td></tr></table></figure><hr><h4 id="3-3-1编译示例应用程序"><a href="#3-3-1编译示例应用程序" class="headerlink" title="3.3.1编译示例应用程序"></a>3.3.1编译示例应用程序</h4><p>在应用程序的文件夹中执行<code>make</code>命令即可</p><hr><h4 id="3-3-2运行实例应用程序"><a href="#3-3-2运行实例应用程序" class="headerlink" title="3.3.2运行实例应用程序"></a>3.3.2运行实例应用程序</h4><p>&#x3D;&#x3D;UIO驱动和巨页必须在应用程序运行之前进行设置。应用程序使用的端口必须在应用程序运行之前绑定到相应的内核模块&#x3D;&#x3D;</p><p>每个DPDK应用程序都要设定对应的DPDK目标环境的抽象层（EAL）库，EAL库提供给一些选项给DPDK应用程序使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./rte_app -c COREMASK [-n NUM] [-d &lt;domain:bus:devid.func&gt;]\</span><br><span class="line">[--Socket-mem=MB,...] [-m MB] [-r NUM] [-v] [--file-prefix]\</span><br><span class="line">[--proc-type &lt;primary|secondary|auto&gt;] [-- xen-dom0]</span><br></pre></td></tr></table></figure><p>EAL选项说明：</p><ol><li>-c COREMASK：16位进制掩码，用于指定使用的CPU核的编号</li><li>-n NUM：每个处理器插槽内存通道数</li><li>–use-device：指定使用的以太网设备</li><li>–socket-mem：从巨页中给特定的socket分配的内存</li><li>-m MB:巨页分配的大小，建议用–socket-mem代替</li><li>-v 启动时显示的版本信息</li></ol><p>&#x3D;&#x3D;-c和-n选项必选&#x3D;&#x3D;</p><p>在DPDK应用程序的目录中，假设硬件平台的每个Socket上由4个内存通道，而且0-3号核被应用程序使用，则运行命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./helloworld -c f -n 4</span><br></pre></td></tr></table></figure><hr><h4 id="3-3-3应用程序的逻辑核的使用"><a href="#3-3-3应用程序的逻辑核的使用" class="headerlink" title="3.3.3应用程序的逻辑核的使用"></a>3.3.3应用程序的逻辑核的使用</h4><p>coremask参数一般是DPDK应用程序的必要参数，建议在每个平台上使用coremask时，考虑CPU核的布局分布</p><hr><h3 id="3-4使用脚本配置"><a href="#3-4使用脚本配置" class="headerlink" title="3.4使用脚本配置"></a>3.4使用脚本配置</h3><hr><ol><li>构建DPDK库</li><li>设置环境</li><li>运行应用程序（可选）</li><li>检查系统</li><li>系统清理</li></ol><blockquote><p>setup.sh脚本需要在root权限下运行</p></blockquote><hr><h2 id="4DPDK自带应用软件调试"><a href="#4DPDK自带应用软件调试" class="headerlink" title="4DPDK自带应用软件调试"></a>4DPDK自带应用软件调试</h2><hr><h3 id="4-1命令行应用例"><a href="#4-1命令行应用例" class="headerlink" title="4.1命令行应用例"></a>4.1命令行应用例</h3><p>命令行应用例可以用于在Linux环境中调试各种DPDK应用</p><ul><li>add obj_name IP:用于增加一个带有IP&#x2F;IPv6地址的新对象</li><li>del obj_name:删除特有对象</li><li>show obj_name:显示IP地址所关联的特定对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/cmdline -c f -n 4   //运行实例</span><br></pre></td></tr></table></figure><hr><h3 id="4-2HelloWorld应用例"><a href="#4-2HelloWorld应用例" class="headerlink" title="4.2HelloWorld应用例"></a>4.2HelloWorld应用例</h3><p>在每个CPU的逻辑核上运行“helloworld”语句打印</p><ol><li><p>进入该应用例目录，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export RTE_SDK=/path/to/rte_sdk</span><br><span class="line">cd $(RTE_SDK)/example/helloworld</span><br></pre></td></tr></table></figure></li><li><p>设定RTE目标，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export RTE_TARGET=x86_64-native-linuxapp-gcc</span><br></pre></td></tr></table></figure></li><li><p>编译该应用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/helloworld -c f -n 4</span><br></pre></td></tr></table></figure><h4 id="4-2-1代码说明"><a href="#4-2-1代码说明" class="headerlink" title="4.2.1代码说明"></a>4.2.1代码说明</h4></li></ol><ul><li>主线程运行入口是main函数,调用了<code>rte_eal_init</code>入口函数，启动基础运行环境。</li><li><code>RTE_LCORE_FOREACH_SLAVE(lcore_id)</code>，遍历所有的EAL指定可以使用的lcore，然后通过<code>rte_eal_remote_launch</code>在每个lcore上启动被指定的线程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_remote_launch</span><span class="params">(<span class="type">int</span> (*f)(<span class="type">void</span>*),<span class="type">void</span> *arg,unsingned slave_id)</span>;</span><br></pre></td></tr></table></figure><ul><li>第一个参数是从线程，被征兆额线程</li><li>第二个参数是传给从线程的参数</li><li>第三个参数是指定的逻辑核，从线程会执行在这个core上。</li></ul><hr><h3 id="4-3L2转发应用例"><a href="#4-3L2转发应用例" class="headerlink" title="4.3L2转发应用例"></a>4.3L2转发应用例</h3><p>L2转发应用例是一个利用DPDK及其SR-IOV进行报文转发处理的简单实例</p><hr><h4 id="4-3-1概述"><a href="#4-3-1概述" class="headerlink" title="4.3.1概述"></a>4.3.1概述</h4><p>L2转发应用实例可以在物理或者虚拟化环境中对每一个从RX_PORT端口收到的报文执行二层转发，目的端口时所允许的端口掩码中的邻接端口，也就是所允许的前四个端口端口1和2转发，端口3和4转发。</p><ul><li>源MAC地址被TX_PORT端口的MAC地址取代</li><li>目的MAC地址被TX_PORT_ID取代</li></ul><blockquote><p>该应用可用于基准性能测试</p></blockquote><p>该应用例无需穿越物理机上的网络设备，可以直接在具有虚拟机的虚拟化环境中使用VF功能。可使用如下命令开启VF功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe ixgbe max_vfs=2,2</span><br></pre></td></tr></table></figure><p>编译该应用同helloworld类似</p><ol><li>该应用实例首先是初始化EAL层使用<code>rte_eal_init</code>初始化，解析EAL参数，然后通过<code>l2fwd_parse_args()</code>函数解析该应用例的特殊参数。</li><li>参数解析完毕，便使用<code>rte_pktmbuf_pool_create()</code>函数创建mbuf pool，mbuf pool中包含了一系列的mbuf对象，用来驱动和应用程序来存放报文。在<code>rte_pktmbuf_pool_creat()</code>函数中，有两个回调函数指针，一个是位于<code>rte_pktmbuf_pool_init()</code>函数中的mp指针，用于初始化驱动程序的私有数据的内存。</li><li>接下来是驱动程序初始化，通过<code>ret_eth_dev_configure()</code>函数配置每个端口上的队列个数。</li><li>然后是RX接收队列初始化，通过<code>rte_eth_rx_queue_setup</code>设置接收队列。</li><li>初始化TX发送队列，发送队列中，每个逻辑核可以在任何端口中发送。通过<code>rte_eth_tx_queue_setup</code>初始化。</li><li>报文的收发与报文处理。通过<code>l2fwd_main_loop</code>函数读取从RX队列接收到的报文。报文被读取到<code>MAX_PKT_BURST</code>大小的内存块中，然后通过<code>rte_eth_rx_burst</code>函数将mbuf指针写入一个本地表，并返回该表中的mbuf个数。然后每个mbuf被<code>l2fwd_simple_forward</code>函数处理。处理过程：从RX端口处理完成后，转送到TX端口发送，替换源MAC和目的MAC。</li><li>报文使用<code>rte_eth_tx_buffer</code>函数发送。</li></ol><hr><h3 id="4-4L3转发应用例"><a href="#4-4L3转发应用例" class="headerlink" title="4.4L3转发应用例"></a>4.4L3转发应用例</h3><hr><h4 id="4-4-1概述"><a href="#4-4-1概述" class="headerlink" title="4.4.1概述"></a>4.4.1概述</h4><p>该应用例展示了DPDK如何利用散列和LPM库进行查表转发处理。L3的转发初始化和确定实时转发路径的过程和L2转发应用例类似。2者的主要区别是L3是基于从输入的报文信息进行转发决策的。</p><blockquote><p>散列查找的键值为报文中的无五元组–源IP,目的IP，源端口,目的端口,协议类型。</p></blockquote><p>每个输入报文的输出接口ID从流表中读取。</p><blockquote><p>注：散列查表可同时转发支持IPv4和IPv6，而LPM查表仅支持IPv4</p></blockquote><p>编译同之前</p><hr><h4 id="4-4-2运行转发应用例"><a href="#4-4-2运行转发应用例" class="headerlink" title="4.4.2运行转发应用例"></a>4.4.2运行转发应用例</h4><p>端口队列逻辑核之间的映射关系</p><table><thead><tr><th align="center">端口</th><th align="center">队列</th><th align="center">逻辑核</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">从端口0映射队列0到逻辑核0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">从端口0映射队列1到逻辑核2</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">从端口1映射队列0到逻辑核1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">3</td><td align="center">从端口1映射队列1到逻辑核3</td></tr></tbody></table><hr><h4 id="4-4-3代码说明"><a href="#4-4-3代码说明" class="headerlink" title="4.4.3代码说明"></a>4.4.3代码说明</h4><p>L3转发大致与L2相似，仅说明L3独有的特性，</p><ol><li>散列初始化<br>散列对象被创建并存放在预先定义的一个全局矩阵中，然后将用户期望的五元组生成为键值，以保持与实际流量一致。通过<code>setup_l3fwd_lookup_tables()</code>函数设置查找的方式，散列的初始化通过<code>setup_hash</code>函数实现，既可以添加ipv4也可以添加ipv6。</li><li>LPM初始化<br>LPM初始化通过<code>setup_lpm</code>函数实现，但是只能添加ipv4。<blockquote><p>LPM和散列表只能选择一种方式，默认情况下选择LPM。</p></blockquote></li><li>基于散列查表的报文转发<br>对于每个输入的报文，通过<code>l3fwd_em_simple_forward()</code>转发，<code>l3fwd_em_simple_forward()</code>支持任何突发方式接收报文，基于散列查表方式分报文转发决策由<code>em_get_ipv4_dst_port</code>和<code>em_get_ipv6_dst_port</code>完成。</li><li>基于LPM的报文转发<br>报文转发操作由<code>l3fwd_lpm_simple_forward()</code>完成，基于LPM查表的报文转发决策由<code>lpm_get_ipv4_dst_port()</code>完成。</li></ol><hr><h3 id="4-5QoS调度应用例"><a href="#4-5QoS调度应用例" class="headerlink" title="4.5QoS调度应用例"></a>4.5QoS调度应用例</h3><p>接收线程从接收端口读取报文，并基于内层和外层VLAN标记，或者IP目的地址的低2byte进行报文分类，最后将这些报文放入环形队列。工作线程将报文从环形队列中取出。如果一个用户使用一个独立的发送核，则报文后续会被送至发送环形队列，发送线程从发送环形队列中读取报文并写入网卡的发送端口。</p><h4 id="4-5-1代码说明"><a href="#4-5-1代码说明" class="headerlink" title="4.5.1代码说明"></a>4.5.1代码说明</h4><p>qos_sched在该应用例中</p><ol><li>一个子接口表示一组预先定义的用户</li><li>一个管道表示一个具体用户</li><li>一个流量类表示具有不同丢包率，时延等需求的流量类型，例如语音，视频和数据传输。</li><li>一个队列承载了属于某类相同用户的一个或多个连接。</li></ol><p>代码流程：</p><ol><li>首先通过<code>app_parse_args</code>函数解析参数。</li><li>然后通过<code>app_init</code>对应用例初始化，初始化每一条流量。通过<code>rte_pktmbuf_pool_create</code>函数创建mbuf pools。通过<code>app_init_sched_port</code>创建调度的端口。</li><li>在<code>app_main_loop</code>函数中循环执行，根据不同的模式执行不同的线程。分别由接收，发送，工作，混合线程。</li></ol><h3 id="4-6定时器应用例"><a href="#4-6定时器应用例" class="headerlink" title="4.6定时器应用例"></a>4.6定时器应用例</h3><p>定时器应用例可以通过定时器设置，有节律的在不同逻辑核上打印出特定信息</p><h4 id="4-6-1代码说明"><a href="#4-6-1代码说明" class="headerlink" title="4.6.1代码说明"></a>4.6.1代码说明</h4><ol><li>首先初始化EAL,通过<code>rte_timer_subsystem_init</code>函数初始化定时器子系统。</li><li>定时器创建后，main注循环体在每个主从逻辑核上使用<code>rte_eal_remote_launch</code>,执行<code>lcore_mainloop</code>循环函数，主循环体内容简单，DPDK推荐使用TCS寄存器，检查是否需要调用<code>rte_timer_manager</code>，此时的定时器的分辨率为10ms。</li><li>在做任何定时器的操作前，首先都需要对定时器初始化，使用<code>rte_timer_init()</code>函数初始化。</li><li>之后对定时器进行配置，使用<code>rte_timer_reset()</code>进行配置</li></ol><ul><li>第一个定时器被放置在主逻辑核，并设置超时门限为1s（hz）,由于提供了，PERIODICAL标志，定时可以由定时器子系统自动重新加载，回调函数为<code>timer0_cb</code></li><li>第二个定时器每隔333ms就在下一个可用的逻辑核中触发，SINGLE标志表示定时器仅当必须被重新手动加载时才会超时。</li></ul><ol start="5"><li>当全局计数器达到20s后，第一个定时器的回调函数显示一段信息，使用<code>rte_timer_stop</code>停止</li><li>第二个定时器的回调函数显示一段信息，并在下一个逻辑核上调用<code>rte_timer_reset</code>重新加载定时器</li></ol><h3 id="4-7基本转发应用例-skeleton"><a href="#4-7基本转发应用例-skeleton" class="headerlink" title="4.7基本转发应用例(skeleton)"></a>4.7基本转发应用例(skeleton)</h3><p>可以用于平台的单核报文出入性能测试。</p><h4 id="4-7-1代码说明"><a href="#4-7-1代码说明" class="headerlink" title="4.7.1代码说明"></a>4.7.1代码说明</h4><ol><li>收先是EAL层的初始化</li><li>然后通过<code>rte_eth_dev_count_avail</code>函数检查可用的端口是否是偶数</li><li>通过<code>rte_pktmbuf_pool_create</code>函数分配一个内存池，保存应用程序使用的<code>mbufs</code>.入口参数是指定<code>rte_socket_id()</code>.</li><li>使用用户自己的函数<code>port_init</code>初始化端口</li><li>通过<code>lcore_main</code>执行应用程序。</li><li>在<code>port_init</code>中，使用<code>rte_eth_dev_configure</code>函数对网络设备进行配置。主要对指定的端口设置接收，发送方向的队列数目，一句配置信息来指定端口功能。通过<code>rte_eth_tx_queue_setup</code>和<code>rte_eth_rx_queue_setup</code>分别创建一个发送和接收队列。通过<code>rte_eth_dev_start</code>启动以太网端口。<br>数据包都是通过<code>rte_eth_rx_burst</code>和<code>rte_eth_tx_burst</code>以突发方式进行收发。最后通过<code>rte_pktmbuf_free</code>释放掉没有发送的数据包。</li></ol><hr><h2 id="5DPDK应用开发"><a href="#5DPDK应用开发" class="headerlink" title="5DPDK应用开发"></a>5DPDK应用开发</h2><hr><h3 id="5-1网卡设备"><a href="#5-1网卡设备" class="headerlink" title="5.1网卡设备"></a>5.1网卡设备</h3><h4 id="5-1-1设备驱动"><a href="#5-1-1设备驱动" class="headerlink" title="5.1.1设备驱动"></a>5.1.1设备驱动</h4><p>DPDK采用层次化设计网络设备驱动，由下到上依次是物理层，驱动功能层，设备接口层，应用接口层。</p><blockquote><p>与linuxu不同的是，DPDK采用UIO机制使得网络设备驱动程序运行在用户态。</p></blockquote><hr><h4 id="5-1-2应用接口"><a href="#5-1-2应用接口" class="headerlink" title="5.1.2应用接口"></a>5.1.2应用接口</h4><p>主要为应用程序提供数据分组的收发函数<br><code>rte_eth_rx_burst</code>，<code>rte_eth_tx_burst</code>最终通过Ethernet设备的<code>rx_pkt_burst</code>,<code>tx_pkt_burst</code>,完成报文的收发。<br>报文以<code>rte_mbuf</code>的形式在应用程序中处理。结构如下图</p><table><thead><tr><th align="center">mbuf header</th><th align="center">headroom(保留)</th><th align="center">pkt data</th></tr></thead></table><p>headroom主要预留给报文封装技术，如VLAN，GRE，封装时，在报文数据前填充封装报文头即可，此外同样可用作报文私有区，保存业务的私有数据，从而保持mbuf header的独立。</p><p>rte_mbuf主要分为两类，direct mbuf和indirect mbuf，其中indirect mbuf一般没有pkt data段，主要用作多播处理。</p><hr><h4 id="5-1-3设备接口"><a href="#5-1-3设备接口" class="headerlink" title="5.1.3设备接口"></a>5.1.3设备接口</h4><p>设备接口层，所有的网口抽象封装成Ethernet设备，从而使应用程序能够以相同的方式使用接口。</p><ol><li>rx_pkt_burst,tx_pkt_burst<br>网口的收发处理函数。初始化时，被赋值为与之对应的网卡驱动收发函数。</li><li>data<br>设备相关信息，如网卡名称，队列，链路状态等。</li><li>dev_ops<br>设备的操作函数组，包括MAC地址，链路状态的查询与设定等操作。<br>Ethernet设备的设置，即网口属性的配置，由<code>rte_eth_dev_configure()</code>完成。</li></ol><blockquote><p>队列的注意事项如下：</p><ol><li>队列测个数有限，具体个数根据网卡的类型确定</li><li>同一个队列不支持多线程同时操作</li></ol></blockquote><p>RX队列，通过<code>rte_eth_rx_queue_setup</code>创建<br>TX队列，通过<code>rte_eth_tx_queue_setup</code>创建</p><hr><h3 id="5-2进程"><a href="#5-2进程" class="headerlink" title="5.2进程"></a>5.2进程</h3><h4 id="5-2-1-线程"><a href="#5-2-1-线程" class="headerlink" title="5.2.1 线程"></a>5.2.1 线程</h4><p>默认情况下，DPDK为每个绑定的逻辑核创建一个对应的affinity thread,以降低线程调度切换造成的开销。</p><p>线程创建的初始化流程如下：</p><ol><li>单线程初始化时，运行在master lcore（主核），在初始化函数<code>rte_eal_init()</code>中，通过<code>RTE_LCORE_FOREACH_SLAVE()</code>遍历所有的slave lcore（从核）。</li><li>通过<code>pthread_creat()</code>为从核创建一个线程。，线程的入口函数为<code>eal_thread_loop()</code></li><li>从核执行<code>eal_thread_loop()</code>,获取相应配置及设置相关参数。</li><li>主核通过<code>rte_eal_mp_remote_launch</code>将指定的入口函数通过管道的方式装载到相关的逻辑核中，完成线程初始化。</li></ol><hr><h4 id="5-2-2单进程"><a href="#5-2-2单进程" class="headerlink" title="5.2.2单进程"></a>5.2.2单进程</h4><p>DPDK提供两种单进程方案：</p><ol><li>run-to-completion 报文的收发，处理，接收都在一个逻辑核完成，如l3fwd</li><li>pipeline，报文的额接收，处理，发送在不同的线程完成，线程之间通过ring传递报文核消息。</li></ol><blockquote><p>&#x3D;&#x3D;ring的主要作用就是实现报文的无锁传递。&#x3D;&#x3D;</p></blockquote><p>ring的应用</p><ul><li>属性<br>通过<code>rte_ring_init()</code>创建ring，参数中指定了ring属性：单入，单出，多入，多出</li><li>出入队函数<br>按队列属性，可将出入队函数分为两类：</li></ul><table><thead><tr><th align="center">方式</th><th align="center">主要函数</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">单入单出</td><td align="center">rte_ring_sp_enqueue</td><td align="center">队列属性为单入单出</td></tr><tr><td align="center">多入多出</td><td align="center">rte_ring_sc_dequeue</td><td align="center">队列属性为多入多出</td></tr></tbody></table><p>按照操作方式，可将出队，入队函数分为两类：</p><table><thead><tr><th align="center">方式</th><th align="center">主要函数</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">随机出入</td><td align="center">rte_ring_enqueue_burst()  rte_ring_dequeue_burst()</td><td align="center">返回实际入队、出队报文的个数</td></tr><tr><td align="center">批量出入</td><td align="center">rte_ring_enqueue_bulk() rte_ring_enqueue_bulk()</td><td align="center">一次性完成N个报文的出入队，如失败，则没有报文出入队。</td></tr></tbody></table><h4 id="5-2-3多进程"><a href="#5-2-3多进程" class="headerlink" title="5.2.3多进程"></a>5.2.3多进程</h4><p>在多进程方案中，primary进程用于初始化系统资源，创建巨页共享内容等，secondary进程依赖于primary进程，可通过名称查找找到共享资源。</p><blockquote><p>内存共享的实现：primary进程初始化系统资源时创建了全局配置文件.rte_config,secondary进程查找与之对应的ring和memory的物理地址，从而实现内存共享。</p></blockquote><p>由primary进程共享的资源主要包括如下：</p><ol><li>网口<br>网口共享了Ethermet设备的部分信息<code>struct rte_eth_dev_data</code>,可以实现报文发送，MAC地址的查询，但是无法进行设置和链路状态的查询。</li><li>mbuf_pool<br>实现报恩在进程间零复制，secondary进程通过函数<code>rte_mempool_lookup</code>查找共享的mbuf_pool。</li><li>ring<br>实现进程间无锁传递报文流，secondary进程通过<code>rte_ring_lookup</code>查找共享的ring</li></ol>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-base/">DPDK基础</category>
      
      
      <category domain="http://singlewang.top/tags/DPDK/">DPDK</category>
      
      
      <comments>http://singlewang.top/2022/04/29/dpdk/dpdk-base/dpdk/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>少年啊，前路漫漫</title>
      <link>http://singlewang.top/2022/04/29/informal-essay/life/start/</link>
      <guid>http://singlewang.top/2022/04/29/informal-essay/life/start/</guid>
      <pubDate>Fri, 29 Apr 2022 03:06:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;终于在今天搭建好了自己的博客，看着这个网页从无到有能够成功展示的那一刻，还是挺开心的，至少从今天起，有一个可以自由发挥的地方来发泄自己情绪，总想写点什么来纪念一下。&lt;/p&gt;
&lt;p&gt;博主是一个比较内向的人，想法很多却又怯于表达，导致留下了许多遗憾，若不是高中时我的班主任给了我</description>
        
      
      
      
      <content:encoded><![CDATA[<p>终于在今天搭建好了自己的博客，看着这个网页从无到有能够成功展示的那一刻，还是挺开心的，至少从今天起，有一个可以自由发挥的地方来发泄自己情绪，总想写点什么来纪念一下。</p><p>博主是一个比较内向的人，想法很多却又怯于表达，导致留下了许多遗憾，若不是高中时我的班主任给了我一个机会当班长(可惜做的并不好)，我可能现在连站在一群人面前讲话的勇气都没有，我的父母也常常建议我要大胆的表达自己的想法，可现实往往是话到嘴边却说不出，我并不知道这算是优点还是缺点，我知道言多必失，可我也知道掌握话语权是多么的重要。但是改变一个人的性格却并不是一件易事，我想将来可能我还是多半会以自己的行事风格去学习工作。</p><blockquote><p>先写到这儿，到饭点了，恰饭，今天刚好要放五一假，开心，虽然下午还是要去校外做项目，但是一想到之后的五一小长假，还是很兴奋的。</p></blockquote><p>虽然我不是出生在什么大富大贵的家庭，但是父母依然把他们最好的给予了我，我的父母都是老师，从小到大一直在他们的呵护下长大，虽然有时候会迎来劈头盖脸的训斥，但是现在想想倒也是一种美好的回忆。我的父亲很注重我们的素质教育，从小就让我们学习绘画，书法等，可惜那时候不懂父母的良苦用心，只是贪玩，现在当事人觉得十分后悔，要是能多一门技艺该多好。</p><p>我的读书生涯真的很平静，没有什么大风大浪，真的可以用一帆风顺来形容了，在西北教育资源相对匮乏的地区，我还是依旧享受了相对来说比较好的教育，一路顺风顺水，从小学再到初中，一直到高中所谓的冲刺班，基本没有任何阻碍，但我并不觉的这是一件特别好的事，或许还是因为太年轻，总想着要经历轰轰烈烈的青春，可慢慢的才发现，自己的青春是那么平淡，有人说青春这种珍贵的东西，要么拼命珍惜，要么使劲挥霍，我的青春可能就介于这个天平中间，平淡无奇。</p><p>高中的时候，总觉得自己还行，没有狂妄自大，也没有自卑，和同学们的关系也很好，有许多朋友，也有一些知己。总幻想着自己能在大学里干一番大事业，或者至少谈一段轰轰烈烈的爱情吧，可当自己以贫困专项的身份进入到华中科技大学的时候，才发现自己是那么渺小，无论是学习能力还是社交能力，都被别人碾压。以前我还不信高中老师们口中的阶级，现在我慢慢明白了，这些教育大省走出来的孩子，比我优秀得多，我一两周的复习抵不过人家一两天的突击。我想起高中班主任口中的差距，有些东西，天赋是很重要的。看着周围的同学参加各种各样的竞赛，各种各样的社团，我渐渐感到迷茫，不知何去何从，未来到底该走怎样的路。有一段时间甚至有过轻生的念头，但还好有我朋友的开导，我没有就此离去，这样太对不起生我养我这么多年的父母，这世上我唯一牵挂的也就是他们了。在大学的四年里我可能就属于最平凡的那一类人，考试没挂科，成绩也一般，没科研，没竞赛，我想努力向那些获奖的大佬们看齐，到后来发现，真的是云壤之别。社交方面更是难为我这个社死分子了，除了同班同学之外几乎不认识什么人了，他们毕业走后我更是觉得孤单一人，不过却也是习惯了。没学到什么本领，只能考研作为就业的缓冲，其实我也挺幸运的，一战就上岸，被一个还不错的老师录取，然而研一的一半已经过去，一个项目都做不出，我又开始怀疑自己选择的路是否是对的，读研真的适合我吗，但是开弓没有回头箭，自己选择的路就是再难，也得咽在肚子里。毕竟生活还是要继续，而且至少现在我有两个明确的目标，第一个毕业，第二个找到一份好工作，后面都会朝着这两个方向进行努力。至于爸妈催得紧的恋爱，正如我的首页–智者不入爱河，不是不想谈，只是自己的那份对于爱的热情已经被消耗殆尽了吧。</p><p>总之到现在，不想放弃自己，不为自己也为父母争一口气。</p><p><em>少年啊，前路漫漫，拨开云雾，方见璀璨星河</em></p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/informal-essay/">随笔</category>
      
      <category domain="http://singlewang.top/categories/informal-essay/life/">生活感悟</category>
      
      
      <category domain="http://singlewang.top/tags/%E5%BF%83%E5%BE%97/">心得</category>
      
      <category domain="http://singlewang.top/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/">生活感悟</category>
      
      
      <comments>http://singlewang.top/2022/04/29/informal-essay/life/start/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Markdown教程</title>
      <link>http://singlewang.top/2022/04/29/markdown/markdown-base/markdownlearn/</link>
      <guid>http://singlewang.top/2022/04/29/markdown/markdown-base/markdownlearn/</guid>
      <pubDate>Fri, 29 Apr 2022 03:00:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8vscode%E5%86%99markdown&quot;&gt;为什么用Vscode写Markdown&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%8E%E4%B9%88</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8vscode%E5%86%99markdown">为什么用Vscode写Markdown</a><ul><li><a href="#%E6%80%8E%E4%B9%88%E7%94%A8vscode%E5%86%99markdown">怎么用vscode写markdown</a></li><li><a href="#%E9%9A%8F%E4%BE%BF%E5%86%99%E7%82%B9">随便写点</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%AC%E5%9C%B0%E5%86%99markdown">为什么要本地写markdown</a><ul><li><a href="#%E5%A5%BD%E7%94%A8%E5%90%97">好用吗</a><ul><li><a href="#%E6%83%B3%E4%B8%8D%E5%87%BA%E5%86%99%E5%95%A5%E4%BA%86">想不出写啥了</a><ul><li><a href="#%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95">只是一个测试</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><!-- /code_chunk_output --><!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=true} --><!-- code_chunk_output --><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8vscode%E5%86%99markdown">为什么用Vscode写Markdown</a><ul><li><a href="#%E6%80%8E%E4%B9%88%E7%94%A8vscode%E5%86%99markdown">怎么用vscode写markdown</a></li><li><a href="#%E9%9A%8F%E4%BE%BF%E5%86%99%E7%82%B9">随便写点</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%AC%E5%9C%B0%E5%86%99markdown">为什么要本地写markdown</a><ul><li><a href="#%E5%A5%BD%E7%94%A8%E5%90%97">好用吗</a><ul><li><a href="#%E6%83%B3%E4%B8%8D%E5%87%BA%E5%86%99%E5%95%A5%E4%BA%86">想不出写啥了</a><ul><li><a href="#%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95">只是一个测试</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><!-- /code_chunk_output --><h1 id="为什么用Vscode写Markdown"><a href="#为什么用Vscode写Markdown" class="headerlink" title="为什么用Vscode写Markdown"></a>为什么用Vscode写Markdown</h1><h2 id="怎么用vscode写markdown"><a href="#怎么用vscode写markdown" class="headerlink" title="怎么用vscode写markdown"></a>怎么用vscode写markdown</h2><h2 id="随便写点"><a href="#随便写点" class="headerlink" title="随便写点"></a>随便写点</h2><h3 id="为什么要本地写markdown"><a href="#为什么要本地写markdown" class="headerlink" title="为什么要本地写markdown"></a>为什么要本地写markdown</h3><h4 id="好用吗"><a href="#好用吗" class="headerlink" title="好用吗"></a>好用吗</h4><h5 id="想不出写啥了"><a href="#想不出写啥了" class="headerlink" title="想不出写啥了"></a>想不出写啥了</h5><h6 id="只是一个测试"><a href="#只是一个测试" class="headerlink" title="只是一个测试"></a>只是一个测试</h6><p><em><strong>正文直接输入</strong></em></p><p>换行注意。直接换行的话，渲染输出其实是没有换行的，需要空行，使用<code>ctrl+shift+v</code>预览输出,或者使用<code>ctrl+鼠标右键，MPE打开侧边预览</code>，一边写一边看输出结果</p><p>代码段使用两个<code>标记，并且可以在第一个</code>的后面加上自己的语言</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>正文中的代码用<code>helloworld</code>，即两个&#96;&#96;,使用三个—就可以绘制出分割线</p><hr><p>有序列表,加上数字.空格就可以作出有序列表，</p><ol><li>123</li><li>12321</li><li>123123</li><li>123123<ol><li>asdf<ol><li>asdf<ol><li>大声道</li></ol></li></ol></li></ol></li></ol><hr><p>无序列表<br>输入-，然后空格，当然也可以换成*</p><ul><li>123<ul><li>1231<ul><li>12312<ul><li>3214<ul><li>2342</li></ul></li></ul></li></ul></li></ul></li></ul><hr><p><strong>加粗</strong><br><em>倾斜</em><br><em><strong>加粗和倾斜</strong></em> </p><hr><blockquote><p>这段就是引用，引用是加&gt;和空格</p></blockquote><blockquote><p>也许</p></blockquote><hr><p>插入图片，插入图片时，需要md文件的同级目录下建立一个文件夹，然后将图片放在里面即可</p><p><img data-src="/./assets/000002.jpg" alt="随便找的图片"></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tLw==">如果是链接的话，就不需要前面的额感叹号</span></p><hr><p>表格</p><table><thead><tr><th align="left">左对齐</th><th align="center">居中</th><th align="right">右对齐</th></tr></thead><tbody><tr><td align="left">2</td><td align="center">3</td><td align="right">5</td></tr><tr><td align="left">10</td><td align="center">1000</td><td align="right">1111</td></tr></tbody></table><hr><p>加入目录，在 MPE 里最简单的插入目录的方法就是在单独的行里使用 [TOC] 标记。这会在当前位置立即插入一个目录。</p><p><code>&lt;!-- @import &quot;[TOC]&quot; &#123;cmd=&quot;toc&quot; depthFrom=1 depthTo=5 orderedList=false&#125; --&gt;</code></p><p>depthFrom的参数是最高从几级标题开始</p><p>&#x3D;&#x3D;depthTo&#x3D;&#x3D;的参数是到几级标题结束</p><p>orderedList的参数是是否需要序号</p><hr><p>高亮&#x3D;&#x3D;高亮&#x3D;&#x3D;,使用两个&#x3D;&#x3D;对相应语句进行高亮</p><hr>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/markdown/">Markdown</category>
      
      <category domain="http://singlewang.top/categories/markdown/markdown-base/">Markdown基础</category>
      
      
      <category domain="http://singlewang.top/tags/Markdown/">Markdown</category>
      
      <category domain="http://singlewang.top/tags/%E6%95%99%E7%A8%8B/">教程</category>
      
      
      <comments>http://singlewang.top/2022/04/29/markdown/markdown-base/markdownlearn/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
