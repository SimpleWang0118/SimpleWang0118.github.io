<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Single Wang&#39;s Blog</title>
    <link>http://singlewang.top/</link>
    
    <atom:link href="http://singlewang.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>智者不入爱河，愚者重蹈覆辙</description>
    <pubDate>Mon, 09 May 2022 13:46:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Linux驱动中的并发控制</title>
      <link>http://singlewang.top/2022/05/09/linux/linux-kernal/linux%E9%94%81/</link>
      <guid>http://singlewang.top/2022/05/09/linux/linux-kernal/linux%E9%94%81/</guid>
      <pubDate>Mon, 09 May 2022 12:20:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Linux驱动中的并发控制&quot;&gt;&lt;a href=&quot;#Linux驱动中的并发控制&quot; class=&quot;headerlink&quot; title=&quot;Linux驱动中的并发控制&quot;&gt;&lt;/a&gt;Linux驱动中的并发控制&lt;/h2&gt;&lt;h3 id=&quot;并发与竞态&quot;&gt;&lt;a href=&quot;#并发与竞</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Linux驱动中的并发控制"><a href="#Linux驱动中的并发控制" class="headerlink" title="Linux驱动中的并发控制"></a>Linux驱动中的并发控制</h2><h3 id="并发与竞态"><a href="#并发与竞态" class="headerlink" title="并发与竞态"></a>并发与竞态</h3><p><strong>并发</strong>指的是多个执行单元同时、并行被执行，而并发的执行单元对共享资源（硬件资源和软件上的全局变量、静态变量等）的访问很容易导致竞态。在linux内核中，主要的竞态发生于如下几种情况：</p><ol><li>对称多处理器(SMP)的多个CPU</li><li>单CPU内进程与抢占它的进程</li><li>中断(硬中断，软中断，Tasklet、底半部)与进程之间。</li></ol><p>解决竞态问题的途径是保证对共享资源的<strong>互斥访问</strong>，所谓<strong>互斥访问</strong>是指一个执行单元在访问共享资源的时候，其他的执行单元被禁止访问。</p><h3 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h3><p>在单CPU范围内避免竞态的一种简单方法是在进入临界区之前屏蔽系统的中断。中断屏蔽将使得中断与进程之间的并发不再发生。由于linux内核的进程调度等操作都依赖与中断实现，内核抢占进程之间的并发也就避免；<br>中断屏蔽的使用方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disable() <span class="comment">//屏蔽中断</span></span><br><span class="line"></span><br><span class="line">critical section <span class="comment">//临界区</span></span><br><span class="line"></span><br><span class="line">local_irq_enable()<span class="comment">//开中断</span></span><br></pre></td></tr></table></figure><p><code>local_irq_disable()</code>和<code>local_irq_enable()</code>都只能禁止和使能本CPU内的中断，并不能解决SMP多CPU引发的竞态。因此中断屏蔽一般与<strong>自旋锁</strong>联合使用。</p><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作指的是在执行过程中不会被别的代码路径所中断的操作。</p><p>Linux内核原子操作分为两类：</p><ol><li>针对位</li><li>针对整型</li></ol><h4 id="整型原子操作"><a href="#整型原子操作" class="headerlink" title="整型原子操作"></a>整型原子操作</h4><ol><li>设置原子变量的值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">atomic_set</span><span class="params">(<span class="type">atomic_t</span> *v <span class="type">int</span> i)</span>; <span class="comment">//设置原子变量的值为i；</span></span><br><span class="line"><span class="type">atomic_t</span> v = ATOMIC_INIT(<span class="number">0</span>); <span class="comment">//设置原子变量v并初始化为0；</span></span><br></pre></td></tr></table></figure></li><li>获取原子变量的值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_read</span>(<span class="type">atomic_t</span> *v); <span class="comment">//返回原子变量的值</span></span><br></pre></td></tr></table></figure></li><li>原子变量加&#x2F;减<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">atomic_add</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span> <span class="comment">//原子变量增加i</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">atomic_sub</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span> <span class="comment">//原子变量减少i</span></span><br></pre></td></tr></table></figure></li><li>原子变量自增&#x2F;自减<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">atomic_inc</span><span class="params">(<span class="type">atomic_t</span> *v)</span><span class="comment">//原子变量增加1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">atomic_dec</span><span class="params">(<span class="type">atomic_t</span> *v)</span><span class="comment">//原子变量减少1</span></span><br></pre></td></tr></table></figure></li><li>测试并操作<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atomic_inc_and_test</span><span class="params">(<span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_dec_and_test</span><span class="params">(<span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_sub_and_test</span><span class="params">(<span class="type">atomic_t</span> *v)</span>;</span><br></pre></td></tr></table></figure>上述操作对原子变量指向自增自减和减操作后测试其是否为0，为0则返回true。</li><li>操作并返回<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atomic_add_return</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_sub_return</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_inc_return</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_dec_return</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span>;</span><br></pre></td></tr></table></figure>上述对原子变量进行操作后返回新的值。</li></ol><h4 id="位原子操作"><a href="#位原子操作" class="headerlink" title="位原子操作"></a>位原子操作</h4><ol><li>设置位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span>;<span class="comment">//设置addr地址的第nr位，所谓设置位即将位写为1.</span></span><br></pre></td></tr></table></figure></li><li>清除位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clear_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span><span class="comment">//清除addr地址的第nr位即将位写为0</span></span><br></pre></td></tr></table></figure></li><li>改变位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span><span class="comment">//对addr地址的第nr位进行反置</span></span><br></pre></td></tr></table></figure></li><li>测试位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_bit(nr,<span class="type">void</span> *addr)<span class="comment">//返回addr地址的第nr位</span></span><br></pre></td></tr></table></figure></li><li>测试并操作位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test_and_set_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">test_and_clear_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">test_and_change_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span>;</span><br></pre></td></tr></table></figure>上述操作相当于先指向test_bit后再执行相关操作。</li></ol><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><h4 id="自旋锁的使用"><a href="#自旋锁的使用" class="headerlink" title="自旋锁的使用"></a>自旋锁的使用</h4><p><strong>自旋锁</strong>可以对临界资源进行互斥访问。为了获得一个自旋锁，在某CPU上运行的代码需先执行一个原子操作，该操作测试并设置某个内存变量。</p><ul><li>如果测试结果表明锁已经空闲，则程序获得这个自旋锁并继续执行；</li><li>如果测试结果表明锁被占用，程序将在一个小循环内重复 <strong>“测试并设置”</strong>，这就是所谓的<strong>自旋</strong>。</li></ul><p>linux系统中与自旋锁相关的操作有如下四种：</p><ol><li>定义自旋锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> spin;</span><br></pre></td></tr></table></figure></li><li>初始化自旋锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_init(lock);</span><br></pre></td></tr></table></figure></li><li>获得自旋锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spink_lock(lock);</span><br></pre></td></tr></table></figure>该宏用于获得自旋锁lock，如果能够立即获得，就马上返回，否则，将自旋在那儿，知道该自旋锁的保持者释放<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_try_lock(lock)</span><br></pre></td></tr></table></figure>该宏尝试获得自旋锁，如果能够获得，它获得锁并返回真，否则立即返回假，实际上不再“自旋”。</li><li>释放自旋锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_unlock(lock)</span><br></pre></td></tr></table></figure></li></ol><p>自旋锁一般如下使用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个自旋锁</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line">spin_lock_init(&amp;lock);</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock); <span class="comment">//获得自旋锁，保护临界区</span></span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock); <span class="comment">//解锁</span></span><br></pre></td></tr></table></figure><p>自旋锁主要针对SMP或单CPU但内核可抢占的情况，对于单CPU和内核不抢占的系统，自旋锁退化为空操作。</p><p>在使用自旋锁要注意如下几个问题：</p><ol><li>自旋锁实际上是忙等锁，只有在占用锁的时间极短的情况下，使用自旋锁才是合理的。否在将会降低系统的性能</li><li>自旋锁可能导致死锁，引发该问题最常见的情况是递归使用一个自旋锁。在自旋锁占用期间不嫩调用<code>copy_from_user()</code>,<code>copy_to_user()</code>,<code>kmalloc()</code>这些函数。</li></ol>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核</category>
      
      
      <category domain="http://singlewang.top/tags/Linux/">Linux</category>
      
      <category domain="http://singlewang.top/tags/Linux%E5%86%85%E6%A0%B8%E9%94%81/">Linux内核锁</category>
      
      <category domain="http://singlewang.top/tags/Linux%E5%B9%B6%E5%8F%91/">Linux并发</category>
      
      
      <comments>http://singlewang.top/2022/05/09/linux/linux-kernal/linux%E9%94%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>cpp之虚函数与多态</title>
      <link>http://singlewang.top/2022/05/05/cpp/cpp%E5%A4%9A%E6%80%81/</link>
      <guid>http://singlewang.top/2022/05/05/cpp/cpp%E5%A4%9A%E6%80%81/</guid>
      <pubDate>Thu, 05 May 2022 13:20:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h2&gt;&lt;p&gt;何为 &lt;em&gt;&lt;strong&gt;多态&lt;/strong&gt;&lt;/em&gt;,顾名思义是同一个事物在不同场景下的多种形态。&lt;br&gt;多态分类：&lt;/p&gt;
&lt;u</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>何为 <em><strong>多态</strong></em>,顾名思义是同一个事物在不同场景下的多种形态。<br>多态分类：</p><ul><li>静态多态(编译阶段)<ul><li>函数重载</li><li>泛型编程</li></ul></li><li>动态多态(运行阶段)<ul><li>虚函数</li></ul></li></ul><p><em><strong>为什么需要多态</strong></em><br>派生类对象的地址可以赋值给基类指针。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时并不确定要执行的是基类还是派生类的虚函数；而当程序运行到该语句时，如果基类指针指向的是一个基类对象，则基类的虚函数被调用，如果基类指针指向的是一个派生类对象，则派生类的虚函数被调用。这种机制就叫作 <strong>多态（polymorphism）</strong>。</p><h3 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h3><p>函数重载就是一个简单的静态多态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Add</span><span class="params">(<span class="type">double</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">//Add(10.0, 20.0);  //这是一个问题代码</span></span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">10.0</span>,<span class="number">20</span>);  <span class="comment">//正常代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>静态多态实在编译期间完成的，编译器会根据实参类型来调用合适的函数,如果有合适的函数就调用，如果没有就会发出警告或报错</em></p><h3 id="动态多态"><a href="#动态多态" class="headerlink" title="动态多态"></a>动态多态</h3><p>动态多态，看名字就知道和静态多态是相反的。<em>它是在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的&#x3D;&#x3D;虚函数&#x3D;&#x3D;</em></p><p><em><strong>动态多态的条件</strong></em></p><ul><li>基类中必须包含虚函数，并且派生类中一定要对基类中的虚函数进行重写</li><li>通过基类对象的指针或者引用调用虚函数。</li></ul><p>提到动态多态那么不得不提一嘴 <em><strong>虚函数</strong></em>。虚函数可以说对动态多态具有决定性的作用。有虚函数才能构成多态。使用虚函数的注意事项：</p><ol><li>只需要在虚函数的声明处加上 virtual 关键字，函数定义处可以加也可以不加。</li><li>可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽（覆盖）关系的同名函数都将自动成为虚函数。</li><li>当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。</li><li>只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）。</li><li>构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。</li><li>析构函数可以声明为虚函数，而且有时候必须要声明为虚函数。</li></ol><p><em><strong>那么虚函数的作用是什么呢？</strong></em></p><ol><li>定义子类对象，并调用对象中未被子类覆盖的基类函数A。同时在该函数A中，又调用了已被子类覆盖的基类函数B。那此时将会调用基类中的函数B，可我们本应该调用的是子类中的覆盖函数B。虚函数即能解决这个问题。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类 Father</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Father::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在函数中调用了，子类覆盖基类的函数display()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fatherShowDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Son</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重写基类中的display()函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Son::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son son;                    <span class="comment">// 子类对象</span></span><br><span class="line">    son.<span class="built_in">fatherShowDisplay</span>();    <span class="comment">// 通过基类中未被覆盖的函数，想调用子类中覆盖的display函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父类中的<code>display()</code>不是虚函数，则执行结果为<code>Father::display()</code>。反之，执行结果为<code>Son::display()</code>。</p><ol start="2"><li>在使用指向子类对象的基类指针，并调用子类中的覆盖函数时，如果该函数不是虚函数，那么将调用基类中的该函数；如果该函数是虚函数，则会调用子类中的该函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类 Father</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义了虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Father::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Son</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 覆盖基类中的display函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Son::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Father *fp;     <span class="comment">// 定义基类指针</span></span><br><span class="line">    Son son;        <span class="comment">// 子类对象</span></span><br><span class="line">    fp=&amp;son;        <span class="comment">// 使基类指针指向子类对象</span></span><br><span class="line">    fp-&gt;<span class="built_in">display</span>();  <span class="comment">// 通过基类指针想调用子类中覆盖的display函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父类中的<code>display()</code>不是虚函数，则执行结果为<code>Father::display()</code>。反之，执行结果为<code>Son::display()</code>。</p><blockquote><p>哪些函数不能定义为虚函数？（面试题）</p><ol><li>友元函数，它不是类的成员函数</li><li>全局函数</li><li>静态成员函数，它没有this指针</li><li>构造函数，拷贝构造函数，以及赋值运算符重载。</li></ol></blockquote><p><em><strong>纯虚函数和抽象类</strong></em><br><strong>纯虚函数</strong>:没有函数体的虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">( )</span> </span>= <span class="number">0</span> ; <span class="comment">//纯虚函数</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>包含纯虚函数的类叫做<strong>抽象类</strong></p><ul><li>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象</li><li>抽象类的指针和引用可以指向抽象类派生出来的类的对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;         <span class="comment">// 错，A 是抽象类，不能创建对象</span></span><br><span class="line">A * pa ;     <span class="comment">// ok,可以定义抽象类的指针和引用</span></span><br><span class="line">pa = <span class="keyword">new</span> A ; <span class="comment">// 错误, A 是抽象类，不能创建对象</span></span><br></pre></td></tr></table></figure><h3 id="多态的表现形式"><a href="#多态的表现形式" class="headerlink" title="多态的表现形式"></a>多态的表现形式</h3><p><em><strong>多态的表现形式一</strong></em></p><ul><li>&#x3D;&#x3D;派生类的指针&#x3D;&#x3D;可以赋给&#x3D;&#x3D;基类指针&#x3D;&#x3D;</li><li>通过基类指针调用基类和派生类中的同名&#x3D;&#x3D;虚函数时&#x3D;&#x3D;：</li></ul><ol><li>若该指针指向一个基类的对象，那么调用是基类的虚函数；</li><li>若该指针指向一个派生类的对象，那么调用的是派生类的虚函数。</li></ol><blockquote><p>调用哪个虚函数，取决于指针对象指向哪种类型的对象。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFather</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123; &#125; <span class="comment">// 虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSon</span> : <span class="keyword">public</span> CFather </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CSon son;</span><br><span class="line">    CFather *p = &amp;son;</span><br><span class="line">    p-&gt;<span class="built_in">Fun</span>(); <span class="comment">//调用哪个虚函数取决于 p 指向哪种类型的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针<code>p</code>指向的是<code>CSon</code>类对象，所以<code>p-&gt;Fun()</code>调用的是<code>CSon</code>类的<code>Fun</code>。</p><p><em><strong>多态的表现形式二</strong></em></p><ul><li>派生类的对象可以付给基类&#x3D;&#x3D;引用&#x3D;&#x3D;</li><li>通过基类引用调用基类和派生类中的同名&#x3D;&#x3D;虚函数&#x3D;&#x3D;时：</li></ul><ol><li>若该引用引用的是一个基类的对象，那么被调用的是基类的虚函数</li><li>若该引用引用的是派生类的对象，那么被调用的是派生类的虚函数。</li></ol><blockquote><p>调用哪个虚函数，取决于引用的对象是哪种类型的对象</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFather</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123; &#125; <span class="comment">// 虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSon</span> : <span class="keyword">public</span> CFather </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CSon son;</span><br><span class="line">    CFather &amp;r = son;</span><br><span class="line">    r.<span class="built_in">Fun</span>(); <span class="comment">//调用哪个虚函数取决于 r 引用哪种类型的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>r</code>引用的是<code>CSon</code>类对象，所以<code>r.Fun()</code>调用的是<code>CSon</code>类的<code>Fun</code>。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/CPP/">CPP</category>
      
      
      <category domain="http://singlewang.top/tags/cpp/">cpp</category>
      
      <category domain="http://singlewang.top/tags/%E5%A4%9A%E6%80%81/">多态</category>
      
      <category domain="http://singlewang.top/tags/%E8%99%9A%E5%87%BD%E6%95%B0/">虚函数</category>
      
      
      <comments>http://singlewang.top/2022/05/05/cpp/cpp%E5%A4%9A%E6%80%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux内核协议栈-cp3</title>
      <link>http://singlewang.top/2022/05/04/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp3/</link>
      <guid>http://singlewang.top/2022/05/04/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp3/</guid>
      <pubDate>Wed, 04 May 2022 12:17:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;3-配置系统&quot;&gt;&lt;a href=&quot;#3-配置系统&quot; class=&quot;headerlink&quot; title=&quot;3.配置系统&quot;&gt;&lt;/a&gt;3.配置系统&lt;/h2&gt;&lt;h3 id=&quot;3-1配置过程分析&quot;&gt;&lt;a href=&quot;#3-1配置过程分析&quot; class=&quot;headerlink</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="3-配置系统"><a href="#3-配置系统" class="headerlink" title="3.配置系统"></a>3.配置系统</h2><h3 id="3-1配置过程分析"><a href="#3-1配置过程分析" class="headerlink" title="3.1配置过程分析"></a>3.1配置过程分析</h3><h4 id="3-1-1配置如何下达到内核"><a href="#3-1-1配置如何下达到内核" class="headerlink" title="3.1.1配置如何下达到内核"></a>3.1.1配置如何下达到内核</h4><p>我们假设在安装我们的 Linux 系统时，没有配置 IP 地址，也没有挂上网线，完完全全是一台“裸机”， 这样方便我们跟踪系统到底做了什么。<br>使用<code>ifconfig -a</code>查看网络配置<br>使用<code>strace ifconfig eth0 192.168.18.2 netmask 255.255.255.0</code>配置号ip和网络掩码<br>在大部分系统上是没有 ifconfig 的源代码的，那么为了查看 ifconfig 内部完成了什么操作时，可以用strace命令查看。<br>把 ifconfig 内部调用的系统接口整理如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="type">int</span> argc, <span class="type">char</span> **argv ) &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span> </span><br><span class="line">    <span class="type">char</span> host[<span class="number">128</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aftype</span> *<span class="title">ap</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hwtype</span> *<span class="title">hw</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span> </span><br><span class="line">    <span class="type">char</span> **spp; </span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">    fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);</span><br><span class="line">    ifr.ifr_name = “eth0”; </span><br><span class="line"> </span><br><span class="line">    ap = inet_aftype = &#123;</span><br><span class="line">    <span class="string">&quot;inet&quot;</span>, <span class="literal">NULL</span>, <span class="comment">/*&quot;DARPA Internet&quot;, */</span> AF_INET, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>), INET_print, INET_sprint, INET_input, INET_reserror, <span class="literal">NULL</span> <span class="comment">/*INET_rprint */</span> , <span class="literal">NULL</span> <span class="comment">/*INET_rinput */</span> , INET_getnetmask,</span><br><span class="line"><span class="number">-1</span>, <span class="comment">/* 这个值会被赋成 fd，即刚才打开的 socket */</span> <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line">    host = “<span class="number">192.168</span><span class="number">.18</span><span class="number">.2</span>”; </span><br><span class="line">    ap-&gt;input(<span class="number">0</span>, host, &amp;sa);<span class="comment">/* 在此 sa-&gt;sa_family=AF_INET，af-&gt;sa_data 已经被设置成 192.168.1.1 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">char</span> *) &amp;ifr.ifr_addr, (<span class="type">char</span> *) &amp;sa, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)); </span><br><span class="line">    ioctl (fd, SIOCSIFADDR, &amp;ifr);</span><br><span class="line">    ioctl (skfd, SIOCGIFFLAGS, &amp;ifr); </span><br><span class="line">    ioctl (skfd, SIOCSIFFLAGS, &amp;ifr);</span><br><span class="line">    host = “<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>”;</span><br><span class="line">    ioctl (skfd, SIOCSIFNETMASK, ifr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可以看出 ifconfig 实际调用了 2 个系统函数：socket 和 ioctl。</p><h4 id="3-1-2socket系统调用"><a href="#3-1-2socket系统调用" class="headerlink" title="3.1.2socket系统调用"></a>3.1.2socket系统调用</h4><p>内核中与socket对应的系统调用时sys_socket,所谓的船舰套接字，就是在sockfs这个文件系统中创建一个节点。该节点是一个文件，不过这个文件具有非普通文件的属性，于是起名socket。<br>从进程角度看，一个套接口就是一个特殊的已打开文件。<br>socket函数本身经过glibc库对其封装，通过int 0x80产生一个软件中断，由内核导向执行sys_socket。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核</category>
      
      
      <category domain="http://singlewang.top/tags/kernal/">kernal</category>
      
      <category domain="http://singlewang.top/tags/linux/">linux</category>
      
      <category domain="http://singlewang.top/tags/%E5%86%85%E6%A0%B8/">内核</category>
      
      
      <comments>http://singlewang.top/2022/05/04/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>c++遇到的bug-1</title>
      <link>http://singlewang.top/2022/05/03/cpp/cpp-bug/c++bug-1/</link>
      <guid>http://singlewang.top/2022/05/03/cpp/cpp-bug/c++bug-1/</guid>
      <pubDate>Tue, 03 May 2022 12:54:00 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;&lt;code&gt;reference to local variable ‘c’ returned [-Wreturn-local-addr]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;函数的返回值为函数内部定义变量的引用，但函数在调用完毕后，函数内部定义的变量空间被</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li><code>reference to local variable ‘c’ returned [-Wreturn-local-addr]</code></li></ol><p>函数的返回值为函数内部定义变量的引用，但函数在调用完毕后，函数内部定义的变量空间被释放，无法访问，从而造成的错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix&amp; Matrix::<span class="keyword">operator</span>+(<span class="type">const</span> Matrix&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix result;</span><br><span class="line"><span class="comment">//其他操作</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>改正方法一</strong></em>：给返回变量定义加上static限定符，保证在函数调用完后不释放空间<br>Matrix&amp; Matrix::operator+(const Matrix&amp; rhs)<br>{<br>    static Matrix result;<br>    &#x2F;&#x2F;其他操作<br>    return result;<br>}</p><p><em><strong>改正方法二</strong></em>：去掉返回值的引用，保证函数外部无法访问返回值的空间，只能得到其内容<br>Matrix Matrix::operator+(const Matrix&amp; rhs)<br>{<br>    static Matrix result;<br>    &#x2F;&#x2F;其他操作<br>    return result;<br>}</p><ol start="2"><li><p>LNK2019<br>即使包含了头文件依然会报无法解析的命令,原因可能是没添加相应的.lib文件</p></li><li><p>不允许指针指向不完整的类类型<br>一般是没有包含相应的头文件</p></li></ol>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/cpp/">C++</category>
      
      <category domain="http://singlewang.top/categories/cpp/cpp-bug/">C++BUG</category>
      
      
      <category domain="http://singlewang.top/tags/cpp/">cpp</category>
      
      <category domain="http://singlewang.top/tags/bug/">bug</category>
      
      
      <comments>http://singlewang.top/2022/05/03/cpp/cpp-bug/c++bug-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>git学习</title>
      <link>http://singlewang.top/2022/05/03/git%E5%AD%A6%E4%B9%A0/</link>
      <guid>http://singlewang.top/2022/05/03/git%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Tue, 03 May 2022 12:51:00 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;初始化一个git目录    &lt;code&gt;git init&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加文件到Git仓库，分两步：&lt;br&gt; 使用命令&lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt;，注意，可反复多次使用，添加多个文件；&lt;br&gt; 使用命令&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>初始化一个git目录    <code>git init</code></li><li>添加文件到Git仓库，分两步：<br> 使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；<br> 使用命令<code>git commit -m &lt;message&gt;</code>提交完成。-m后面输入的是本次提交的说明</li><li>要随时掌握工作区的状态，使用<code>git status</code>命令。<br> 如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li><li>添加远程库<code>git remote add origin git@github.com:SimpleWang0118/C-Game.git</code><br> 添加后，远程库的名字就是<code>origin</code><br> 把本地库的所有内容推送到远程库上（第一次）<code>git push -u origin master</code><br> 只要本地作了提交，就可以通过命令 <code>git push origin master</code>推送至远程库上</li><li>查看远程库信息<code>git remote -v</code></li><li>删除远程库<code>eg git remote rm origin</code></li><li><code>git commit</code>提示<code>Your branch is up-to-date with &#39;origin/master&#39;</code><br> 首先建立一个分支：<code>git branch new branch</code><br> 然后检查分支是否创建成功: <code>git branch</code> *代表的是当前你所在的工作分支<br> 然后切换到你的新分支: <code>git checkout newbranch</code><br> 然后将你的改动提交到新分支上: git add .     git commit -m “18.03.01”<br> 然后切换到主分支:<code>git checkout master</code><br> 然后将新分支提交的改动合并到主分支上:<code>git merge newbranch</code><br> 然后就可以push代码了:<code>git push -u origin master</code><br> 最后还可以删除这个分支:<code>git branch -D newbranch</code></li></ol>]]></content:encoded>
      
      
      
      <category domain="http://singlewang.top/tags/git/">git</category>
      
      <category domain="http://singlewang.top/tags/github/">github</category>
      
      
      <comments>http://singlewang.top/2022/05/03/git%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>刷机教程</title>
      <link>http://singlewang.top/2022/05/03/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</link>
      <guid>http://singlewang.top/2022/05/03/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</guid>
      <pubDate>Tue, 03 May 2022 08:34:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;1、首先解锁手机BL锁，进入开发者选项，然后需要到相应的手机官网下载解锁工具。&lt;br&gt;2、安装对应手机的rec软件，之后进入rec，先双清，即首先清除数据，再格式化&lt;br&gt;3、下载对应的系统压缩包&lt;br&gt;4、在rec软件中安装压缩包即可。&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>1、首先解锁手机BL锁，进入开发者选项，然后需要到相应的手机官网下载解锁工具。<br>2、安装对应手机的rec软件，之后进入rec，先双清，即首先清除数据，再格式化<br>3、下载对应的系统压缩包<br>4、在rec软件中安装压缩包即可。</p>]]></content:encoded>
      
      
      
      <category domain="http://singlewang.top/tags/%E5%88%B7%E6%9C%BA/">刷机</category>
      
      
      <comments>http://singlewang.top/2022/05/03/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux内核协议栈-cp2</title>
      <link>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp2/</link>
      <guid>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp2/</guid>
      <pubDate>Tue, 03 May 2022 08:34:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;2-系统初始化&quot;&gt;&lt;a href=&quot;#2-系统初始化&quot; class=&quot;headerlink&quot; title=&quot;2.系统初始化&quot;&gt;&lt;/a&gt;2.系统初始化&lt;/h2&gt;&lt;h3 id=&quot;2-1-系统初始化流程简介&quot;&gt;&lt;a href=&quot;#2-1-系统初始化流程简介&quot; class</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="2-系统初始化"><a href="#2-系统初始化" class="headerlink" title="2.系统初始化"></a>2.系统初始化</h2><h3 id="2-1-系统初始化流程简介"><a href="#2-1-系统初始化流程简介" class="headerlink" title="2.1 系统初始化流程简介"></a>2.1 系统初始化流程简介</h3><p>在系统启动过程中，我们要关注这几个方面： </p><ol><li>中断系统及调度系统 </li><li>文件系统的初始化 </li><li>设备管理系统的初始化</li><li>网络协议的初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kernel_thread</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> * arg, <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br></pre></td></tr></table></figure><p><code>kernel_thread</code>创建一个线程，定义在arch&#x2F;i386&#x2F;kernel&#x2F;process.c中，Linux 的内核线程是没有虚拟存储空间的进程，它们运行在内核中，直接使用物理地址空间。</p><h3 id="2-2内核文件解读"><a href="#2-2内核文件解读" class="headerlink" title="2.2内核文件解读"></a>2.2内核文件解读</h3><h4 id="2-2-1ELF文件格式"><a href="#2-2-1ELF文件格式" class="headerlink" title="2.2.1ELF文件格式"></a>2.2.1ELF文件格式</h4><p>ELF 是*nix 系统上可执行文件的标准格式，它取代了out格式的可执行文件，原因在于它的可扩展性。<br>ELF文件有三种不同的形式：</p><ol><li>Relocatable：由编译器和汇编器生成，由 linker 处理它。 </li><li>Executable：所有的重定位和符号解析都完成了，也许共享库的符号要在运行时刻解析。</li><li>Shared Object：包含 linker 需要的符号信息和运行时刻所需的代码。</li></ol><p>ELF 文件有双重性质：一方面，编译器、汇编器、连接器都把它看作是逻辑段（sections）的集合， 另一方面 loader 把它看作段（segments）的集合。Section 是给 linker 做进一步处理的，而 segments 是被映射到内存中去的。</p><p>一个 segment 可以由几个 sections 组成。为了定位不同 segment&#x2F;section，可执行文件用一个 table 来记录各个 segment&#x2F;section 的位置和描述。</p><h4 id="2-2-2Link-Scripts知识"><a href="#2-2-2Link-Scripts知识" class="headerlink" title="2.2.2Link Scripts知识"></a>2.2.2Link Scripts知识</h4><p>为什么我们编出来的代码肯定是在用户地址空间运行，而内核编出来的代码 却一定是运行在内核空间？<br>主要是因为链接器的作用。不能简单地认为链接器仅仅完成将各 obj 文件拼在一起的任务，而且它还指定每个段被装入内存的真正地址。</p><p>可以用<code>ld -verbose</code>查看<code>ld script</code></p><h3 id="2-3中断及任务调度管理"><a href="#2-3中断及任务调度管理" class="headerlink" title="2.3中断及任务调度管理"></a>2.3中断及任务调度管理</h3><h4 id="2-3-1中断及软中断模型"><a href="#2-3-1中断及软中断模型" class="headerlink" title="2.3.1中断及软中断模型"></a>2.3.1中断及软中断模型</h4><p>Linux 支持 CPU 的外部硬件中断和内部中断。&#x3D;&#x3D;内部中断包含系统调用陷入和异常&#x3D;&#x3D;，在一般的嵌入式操作系统（比如 VxWorks）中是没有系统调用这个概念的。</p><ul><li>&#x3D;&#x3D;系统调用&#x3D;&#x3D;就是软件有计划地调用 CPU 提供的特殊指令，触发 CPU 内部产生一个中断，于是完成一次核内核外运行空间的切换，具体可以参考许多书籍。</li><li>&#x3D;&#x3D;异常&#x3D;&#x3D;就是软件无意的执行了一个非法指令（比如除 0）从而造成 CPU 内部引发一次中断。</li></ul><p>&#x3D;&#x3D;外部中断&#x3D;&#x3D;特指外部设备发出的中断信号。但这几种中断的 CPU 处理过程基本相同，即：在执行完当 前指令后，或在执行当前指令期间，根据中断源所提供的“中断向量”，在内存中找到相应的 ISR（中断<br>服务例程）然后调用之。</p><h5 id="2-3-1-1中断系统和软中断"><a href="#2-3-1-1中断系统和软中断" class="headerlink" title="2.3.1.1中断系统和软中断"></a>2.3.1.1中断系统和软中断</h5><p>IRQ 是设备相关的号码，一般生产厂商都会使自己的设备分配到一个合适的号码。<br>&#x3D;&#x3D;中断向量&#x3D;&#x3D;就是操作系统中关于如何处理中断的内存组织结构，它们之间存在某种映射关系，这种关系是由CPU体系结构以及操作系统决定的。</p><blockquote><p>中断向量号0x80是系统调用号</p></blockquote><p>软中断是在处理完所有的中断之后才会处理的。目前linux内核中定义了6种软中断。在<code>start_kernel</code>函数中调用的<code>softirp_init</code>只初始化了两个。</p><p>Tasklet机制是一种比较特殊的软中断。指一小段可以执行的代码。通常以函数的形式出现。从某种程度上讲tasklet机制是linux内核对BH机制的一种扩展。它呈现出以下两个特点:</p><ol><li>与一般的软中断不同，某一段 tasklet 代码在某个时刻只能在一个 CPU 上运行，而不像一般的软 中断服务函数（即 softirq_action 结构中的 action 函数指针）那样在同一时刻可以被多个 CPU 并发地执行。</li><li>与BH机制不同，不同的 tasklet 代码在同一时刻可以在多个 CPU上并发地执行，而不像BH机制 那样必须严格地串行化执行（也即在同一时刻系统中只能有一个 CPU 执行BH函数）。</li></ol><h3 id="2-4虚拟文件系统"><a href="#2-4虚拟文件系统" class="headerlink" title="2.4虚拟文件系统"></a>2.4虚拟文件系统</h3><p>VFS（虚拟文件系统）在 Linux 及Unix 家族中是非常重要的概念，可以说它是操作系统的骨架。VFS 只存在与内存中，它在系统启动时被创建，系统关闭时注销。<br>&#x3D;&#x3D;VFS 的作用就是屏蔽各类文件系统的差异， 给用户、应用程序、甚至 Linux 其他管理模块提供统一的接口集合。&#x3D;&#x3D;</p><p>VFS 描述文件系统使用超级块和 inode 的方式，所谓超级块就是对所有文件系统的管理机构，每种 文件系统都要把自己的信息挂到 <code>super_blocks</code> 这么一个全局链表上。内核中是分成 2 个步骤完成：首先 每个文件系统必须通过 <code>register_filesystem</code> 函数将自己的 <code>file_system_type</code> 挂接到 <code>file_systems</code> 这个全局变量上，然后调用 <code>kern_mount</code> 函数把自己的文件相关操作函数集合表挂到 <code>super_blocks</code> 上。</p><h3 id="2-5网络协议栈各部分初始化"><a href="#2-5网络协议栈各部分初始化" class="headerlink" title="2.5网络协议栈各部分初始化"></a>2.5网络协议栈各部分初始化</h3><p>初始化大致的顺序：</p><ol><li>core_initcall:sock_init()</li><li>fs_initcall:inet_init()</li><li>subsys_initcall:net_dev_init()</li><li>device_initcall:设备驱动初始化</li></ol><h4 id="2-5-1网络基础系统初始化"><a href="#2-5-1网络基础系统初始化" class="headerlink" title="2.5.1网络基础系统初始化"></a>2.5.1网络基础系统初始化</h4><p>第一个步骤使用<code>core_initcall</code>初始化宏修饰<code>sock_init</code>函数，此函数知识分配一些内存空间，以及创建一个sock_fs_type的二年间系统。</p><blockquote><p>基本的socket初始化必须在每一个TCP&#x2F;IP成员协议能注册到socket层之前完成。</p></blockquote><p>当执行<code>do_initcalls</code>时才是真正初始化那些特定协议。</p><h4 id="2-5-2网络内存管理"><a href="#2-5-2网络内存管理" class="headerlink" title="2.5.2网络内存管理"></a>2.5.2网络内存管理</h4><h5 id="2-5-2-1-sk-buff结构"><a href="#2-5-2-1-sk-buff结构" class="headerlink" title="2.5.2.1 sk_buff结构"></a>2.5.2.1 sk_buff结构</h5><p>数据包在应用层称为data，在TCP层成为segment，在IP层称为packet，在数据链路层称为frame。Linux内核中<code>sk_buff&#123;&#125;</code>存放网络接收到或需要发送的数据，因此其必须要有足够的扩展性。<br>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 <code>skb-&gt;data</code> 的值，来逐步剥离协议首部；<br>而要发送报文时，各协议创建<code>sk_buff&#123;&#125;</code>，在经过各下层协议时，通过减少 <code>skb-&gt;data</code><br>的值来增加协议首部。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span>&#123;</span></span><br><span class="line">    <span class="comment">/*这两个成员必须放在前面*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    _u32    qlen;<span class="comment">/*该sk_buff_head引导的一个链表的节点的个数*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当接收一个报文时，创建一个<code>sk_buff&#123;&#125;</code>(sk_buff的内容过多，暂不列出),然后更具地址类型指定该skb实际属于哪一种的报文类型，然后上层协议栈采取相应的处理方式处理该skb。</p><p>其中<code>len</code>是指数据包全部数据的长度，包括<code>data</code>指向的数据和end后面的分片的数据的总长，而<code>data_len</code>只包括分片的数据的长度。<code>truesize</code>的最终值时<code>len+sizof(struct sk_buff)</code>。</p><p>两个后备高速缓存的区别：</p><ul><li><code>skbuff_head_cache</code> 在创建时指定的单位内存区域的大小是<code>sizeof(struct sk_buff)</code>，可以容纳任意数目的<code>struct sk_buff</code>。</li><li><code>skbuff_fclone_cache</code>在创建时指定的单位内存区域大小时<code>2*sizeof(struct sk_buff)+sizeof(atomic_t)</code>。</li></ul><p>创建一个套接字缓冲区，最常用的操作是<code>alloc_skb</code>。它是在<code>skbuff_head_cache</code>中创建。</p><blockquote><p>GSO(Generic Segmentation Offload):<br>协议栈的效率提高的一个策略：尽可能晚的推迟分段，最理想的是在网卡驱动里分段，在网卡驱动里把大包拆开，组成SG list，或在一块预先分配好的内存中重组分段，然后交给网卡。</p></blockquote><h5 id="2-5-2-2-内存管理函数"><a href="#2-5-2-2-内存管理函数" class="headerlink" title="2.5.2.2 内存管理函数"></a>2.5.2.2 内存管理函数</h5><p>在<code>sk_buff&#123;&#125;</code>中的 4 个指针 data、head、tail、end 初始化的时候，data、head、tail 都是指向申请到的 数据区的头部，end 指向数据区的尾部。一般都是通过 data 和 tail 来获得在 sk_buff中 可用的数据区的开始和结尾。而 head 和 end 就表示 sk_buff中存在的数据包最大可扩展的空间范围。</p><p> skb_clone 和 skb_copy 的区别：</p><ul><li>前者基本在 <code>skbuff_fclone_cache</code> 中分配内存，除非 一定要对一个不是可以被克隆的对象进行克隆，那么才会在 <code>skbuff_head_cache</code> 中分配内存，而且只是 <code>sk_buff&#123;&#125;</code>结构的复制，没有涉及到真正数据区（data）的复制；</li><li>后者必定在 <code>skbuff_head_cache</code> 中进行，<br>不仅复制 <code>sk_buff&#123;&#125;</code>，而且复制了数据区。</li></ul><h4 id="2-5-3-网络文件系统初始化"><a href="#2-5-3-网络文件系统初始化" class="headerlink" title="2.5.3 网络文件系统初始化"></a>2.5.3 网络文件系统初始化</h4><p>在 <code>linux</code> 系统中，<code>socket</code> 属于文件系统的一部分，网络通信可以被看作对文件的读取。这种特殊的文件系统叫 <code>sockfs</code>。</p><p>初始化文件系统，首先是调用 <code>register_filesystem(&amp;sock_fs_type)</code>;把文件系统类型注册到 <code>file_systems</code> 链表上，然后调用 <code>kern_mount(&amp;sock_fs_type)</code>;把该文件系统注册到 <code>super_blocks</code> 上。</p><p>在系统初始化的时候要通过 <code>kern_mount</code> 安装此文件系统。所谓创建一个套接字就是在 <code>sockfs</code>文件系统中创建一个特殊文件。</p><h4 id="2-5-4-网络协议初始化"><a href="#2-5-4-网络协议初始化" class="headerlink" title="2.5.4 网络协议初始化"></a>2.5.4 网络协议初始化</h4><p>初始化第二个大步骤就是使用 <code>fs_initcall</code> 初始化宏修饰 <code>inet_init</code> 函数，它初始化和协议本身相关的东西。这一步才真正设计到“栈”的概念。在这之前，必须要知道两个概念–地址族和套接字类型。Linux 将不同的地址族抽象统一为 BSD 套接字接口，应用程序关心的只是BSD套接字接口，通过参数来指定所使用的套接字地址族。</p><p>Linux 内核中为了支持多个地址族，定义了这么一个变量：<code>static struct net_proto_family *net_families[NPROTO]</code>，NPROTO 等于 32，也就是说 Linux 内核支持最多 32 种地址族。</p><p>我们常用的就是 PF_UNIX（1）、PF_INET（2）、PF_NETLINK（16），Linux 还有一个自有的 PF_PACKET（17）。</p><blockquote><p>网络协议的初始化是在网络设备的初始化之前完成的，在 Linux 系统中并不是说网络设备不存在就不需要网络协议了，而是在没有网络设备存在的时候，照样可以完成网络的工作，只不过网络系统物理上只存在于本机一台机器中而已。</p></blockquote><p>一进入初始化就调用 <code>proto_register</code>3次，先后为 tcp、udp、raw的 <code>proto&#123;&#125;</code>结构申请空间并将其挂到一 个全局链表 <code>proto_list</code> 上。这三个 proto 全局变量非常重要，是连接传输层和 IP 层的纽带。</p><p><code>sock_register</code>函数，它把 <code>inet_family_ops</code> 塞入 <code>net_families</code> 数组中，这个 <code>inet_family_ops</code>是如下定义的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> =</span> &#123; </span><br><span class="line">    .family = PF_INET, </span><br><span class="line">    .create = inet_create, </span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户创建 socket 时，先指定 INET 地址族，在指定套接字 类型。换句话说这是数据流发送的流向。</p><p>socket层必须区分哪一个用户应该接收这个包，这叫做<em><strong>socket解复用</strong></em>。</p><p>之后就是初始化第二个方面的必要步骤:注册接收函数<br>Linux 区分永久和非永久协议。永久协议包括像UDP和TCP，这是TCP&#x2F;IP 协议实现的基本部分，去掉一个永久协议是不允许的。所以，UDP和TCP是不能unregistered。此机制由2个函数和一个维护注册协议的数据结构组成。一个负责注册协议，另一个负责注销。每一个注册的协议都放在一个表里，叫<br><em><strong>协议切换表</strong></em>。</p><p>对于发送过程，直接调用IP层函数，而对于内核接收过程则分为2层：上层需要一个接收函数解复用传输协议报文，下层需要一个接收函数解复用网络层报文。报文从设备层送到上层之前，必须区分是IP报文还是ARP报文。</p><p>标识一个套接字的三元组:&lt;地址族，类型，具体协议&gt;。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核</category>
      
      
      <category domain="http://singlewang.top/tags/kernal/">kernal</category>
      
      <category domain="http://singlewang.top/tags/linux/">linux</category>
      
      <category domain="http://singlewang.top/tags/%E5%86%85%E6%A0%B8/">内核</category>
      
      
      <comments>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux内核协议栈-cp1</title>
      <link>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp1/</link>
      <guid>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp1/</guid>
      <pubDate>Tue, 03 May 2022 07:55:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;linux内核协议栈&quot;&gt;&lt;a href=&quot;#linux内核协议栈&quot; class=&quot;headerlink&quot; title=&quot;linux内核协议栈&quot;&gt;&lt;/a&gt;linux内核协议栈&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;1-协议栈概述&quot;&gt;&lt;a href=&quot;#1-协议栈概述&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="linux内核协议栈"><a href="#linux内核协议栈" class="headerlink" title="linux内核协议栈"></a>linux内核协议栈</h1><hr><h2 id="1-协议栈概述"><a href="#1-协议栈概述" class="headerlink" title="1.协议栈概述"></a>1.协议栈概述</h2><hr><h3 id="1-1操作系统及网络协议介绍"><a href="#1-1操作系统及网络协议介绍" class="headerlink" title="1.1操作系统及网络协议介绍"></a>1.1操作系统及网络协议介绍</h3><hr><h4 id="1-1-1linux操作系统架构简介"><a href="#1-1-1linux操作系统架构简介" class="headerlink" title="1.1.1linux操作系统架构简介"></a>1.1.1linux操作系统架构简介</h4><p>linux是一款大内核操作系统。</p><p>操作系统内核可能是微内核，也可能是大内核（后者有时称之为宏内核Macrokernel）。按照类似封装 的形式，这些术语定义如下:</p><ul><li>微内核（Microkernel kernel）――在微内核中，大部分内核都作为独立的进程在特权状态下运行， 它们通过消息传递进行通讯。微内核设计的一个优点是在不影响系统其它部分的情况下，用更高效的实现代替现有文件系统 模块的工作将会更加容易。我们甚至可以在系统运行时将开发出的新系统模块或者需要替换现有模块的 模块直接而且迅速的加入系统。另外一个优点是不需要的模块将不会被加载到内存中，因此微内核就可<br>以更有效的利用内存。</li><li>大内核（Monolithic kernel）――大内核是一个很大的进程。它的内部又可以被分为若干模块（或者是层次或其它）。但是在运行的时候，它是一个独立的二进制大映象。其模块间的通讯是通过直接调用其它模块中的函数实现的，而不是消息传递。</li></ul><blockquote><p>除了嵌入式，没有一款商用的操作系统是以真正学术上的微内核形式存在。</p></blockquote><h4 id="1-1-2网络协议发展介绍"><a href="#1-1-2网络协议发展介绍" class="headerlink" title="1.1.2网络协议发展介绍"></a>1.1.2网络协议发展介绍</h4><p>IP网络的优点，简单，IP协议栈的中心在于，使用IP协议将数据包发送到任何网络，数据包到达的时间可以不同。</p><p>事实上的网络协议栈实现基本采用TCP&#x2F;IP的4层架构，从底往上分别是：链路层，网络层，传输层，应用层。<br>但是在实际开发人员的眼中，却是五层，即在链路层之下还有一个物理层。</p><p>将链路层简称为2层或L2，网络层简称为3层或L3，而传输层即为4层或L4。</p><p>应用程序是可以绕过TCP层而直接与IP层协作，比如我们常用的 ping 命令。</p><h4 id="1-1-3基本的数据结构和计算机术语"><a href="#1-1-3基本的数据结构和计算机术语" class="headerlink" title="1.1.3基本的数据结构和计算机术语"></a>1.1.3基本的数据结构和计算机术语</h4><ul><li><p>链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ist_head 结构包含两个指向list_head结构的指针prev和next，通常它都组织成双循环链表。在 Linux内核链表中，不是在链表结构中包含数据，而是在数据结构中包含链表节点。</p></li><li><p>由链表节点到数据项变量<br>如何通过这个 list_head 成员访问到它的所有者呢？Linux 为此提供了一个 list_entry(ptr, type, member)宏，<br>ptr 是指向该数据中 list_head 成员的指针<br>type 是数据项的类型<br>member 则是数据项</p></li><li><p>hlist<br>hlist 是 hash list的简称，即用拉链法实现的 hash 数据结构。它由 2 部分组成：hash 数组和冲突链。当节点第一次要插入 hash 表的时候，它必定是先插入 hash 数组中，而以后要插入的节点如果发生了冲突，则可以挂在数组后面，形成一条链表。当然也可以插入数组，原先在数组中的节点被挤出来形成一条链表。</p></li></ul><p>也许Linux链表设计者认为双头（next、prev）的双链表对于HASH表来说”过于浪费”，因而另行设计了一套用于HASH表应用的 hlist 数据结构——单指针表头双循环链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span>, **<span class="title">pprev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核</category>
      
      
      <category domain="http://singlewang.top/tags/kernal/">kernal</category>
      
      <category domain="http://singlewang.top/tags/linux/">linux</category>
      
      <category domain="http://singlewang.top/tags/%E5%86%85%E6%A0%B8/">内核</category>
      
      
      <comments>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch2</title>
      <link>http://singlewang.top/2022/05/03/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch2/</link>
      <guid>http://singlewang.top/2022/05/03/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch2/</guid>
      <pubDate>Tue, 03 May 2022 07:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;传统网络设备驱动包处理的流程可以概括如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据包到达网卡设备&lt;/li&gt;
&lt;li&gt;网卡设备依据配置进行DMA操作&lt;/li&gt;
&lt;li&gt;网卡发送中断，唤醒处理器&lt;/li&gt;
&lt;li&gt;驱动软件填充读写缓冲区数据结构&lt;/li&gt;
&lt;li&gt;数据报文到达内核协议栈</description>
        
      
      
      
      <content:encoded><![CDATA[<p>传统网络设备驱动包处理的流程可以概括如下:</p><ul><li>数据包到达网卡设备</li><li>网卡设备依据配置进行DMA操作</li><li>网卡发送中断，唤醒处理器</li><li>驱动软件填充读写缓冲区数据结构</li><li>数据报文到达内核协议栈，进行高层处理</li><li>如果最终应用在用户态，数据从内核搬移到用户态</li><li>如果最终应用在内核态，在内核继续进行</li></ul><h2 id="2-cache和内存"><a href="#2-cache和内存" class="headerlink" title="2.cache和内存"></a>2.cache和内存</h2><h3 id="2-1存储系统简介"><a href="#2-1存储系统简介" class="headerlink" title="2.1存储系统简介"></a>2.1存储系统简介</h3><h4 id="2-1-1系统架构的演进"><a href="#2-1-1系统架构的演进" class="headerlink" title="2.1.1系统架构的演进"></a>2.1.1系统架构的演进</h4><p>在经典计算机系统中一般有两个标准化的部分:<em><strong>北桥</strong></em>和<em><strong>南桥</strong></em></p><ul><li>北桥也称为主桥，主要用来处理高速信号，通常负责与处理器的联系，并控制内存AGP、PCI数据在北桥内部传输。</li><li>南桥也称为I&#x2F;O桥，负责I&#x2F;O总线之间的通信，比如:PCI总线，SATA,USB等。</li></ul><p>在这种系统中，所有的数据交换都需要通过北桥:</p><ol><li>处理器访问内存需要通过北桥</li><li>处理器方位所有的外设</li><li>处理器之间的数据交换</li><li>挂在南桥的设备访问内存</li></ol><p>因此可以看出，这种系统的瓶颈就在北桥中。为了解决这个瓶颈，于是产生了NUMA(Non-Uniform Memory Architecture 非一致性内存架构)。在这种架构下，在一个拥有四核的机器中，不需要一个复杂的北桥就能将内存宽带增加到以前的四倍</p><h3 id="2-2-cache系统简介"><a href="#2-2-cache系统简介" class="headerlink" title="2.2 cache系统简介"></a>2.2 cache系统简介</h3><blockquote><p>为什么要提出cache的概念？<br>虽然随着DDR4，DDR5技术的不断推出，内存的吞吐率得到了很大提升，但是相对于处理器来说任然很慢，一般来讲，处理器要从内存中直接读取数据要花大概几百个时钟周期，在这期间，处理器除了等待什么也不能做。为了匹配处理器和内存之间存在巨大的速度差距，才提出了cache的概念。</p></blockquote><h4 id="2-2-1cache的种类"><a href="#2-2-1cache的种类" class="headerlink" title="2.2.1cache的种类"></a>2.2.1cache的种类</h4><p>一般来说，cache由三级组成，一级最快，但是容量最小，三级最慢，但是容量最大。cache是一种SRAM</p><ul><li>一级cache，一般分为数据cache和指令cache，数据cache用来存放数据，指令cache用来存放指令。一般只有几十KB。</li><li>二级cache，数据cache和指令cache无差别存放在一起。一般有几百KB到几MB。</li><li>三级cache，一般有几MB到几十个MB。</li></ul><p>对于各级cache的访问时间，在英特尔处理器上一般是一级cache访问是4个指令周期。二级cache是<br>12个指令周期，三级cache是26~31个指令周期。</p><h3 id="2-3Cache地址映射和变换"><a href="#2-3Cache地址映射和变换" class="headerlink" title="2.3Cache地址映射和变换"></a>2.3Cache地址映射和变换</h3><p>由于内存大，cache容量小，如何把内存中的内容存放到cache中?需要一个映射算法和一个分块机制。</p><p>分块机制就是cache和内存以块为单位进行数据交换，块的大小通常以在内粗的一个存储周期中能够访问到的数据长度为限。主流块的大小都是64字节，因此一个cache line就是64个字节大小的数据块。</p><p>映射算法是指把内存地址空间映射到cache地址空间。<br>根据cache和内存之间的映射关系的不同，cache可以分为三类;全关联型cache，直接关联型cache，组关联型cache</p><h4 id="2-3-1全关联型cache"><a href="#2-3-1全关联型cache" class="headerlink" title="2.3.1全关联型cache"></a>2.3.1全关联型cache</h4><p>全关联型cache是指主存中的任何一块内存都可以映射到cache中的任意一块位置上。在cache中，需要建立一个目录表，目录表的每个表项都有三部分组成：内存地址、cache块号和一个有效位。<br>使用全关联型cache，块冲突最小，cache的利用率也高，但是需要一个访问速度很快的相联存储器。一般只有容量很小的cache才会设计成全关联型的。</p><h4 id="2-3-2直接关联型cache"><a href="#2-3-2直接关联型cache" class="headerlink" title="2.3.2直接关联型cache"></a>2.3.2直接关联型cache</h4><p>直接关联型cache是指主存中的一块内存只能映射到cache的一个特定的块中。假设一个cache中总共存在N个cache line，那么内存被分成N等分，其中每一等分对应一个cache line。直接关联型cache的目录表只有两部分组成，区号和有效位。<br>直接关联型cache命中率最低，但是实现方式最简单，匹配速度也最快。</p><h4 id="2-3-3组关联型cache"><a href="#2-3-3组关联型cache" class="headerlink" title="2.3.3组关联型cache"></a>2.3.3组关联型cache</h4><p>组关联型Cache是目前Cache中用的比较广泛的一种方式，是前两种Cache的折中形式。在这种方式下，内存被分为很多组，一个组的大小为多个Cache line的大小，一个组映射到对应的多个连续的Cache line，也就是一个Cache组，并且该组内的任意一块可以映射到对应 Cache组的任意一个。可以看出，在组外，其采用直接关联型Cache的映射方式，而在组内，则采用全关联型Cache的映射方式。</p><h3 id="2-4cache的写策略"><a href="#2-4cache的写策略" class="headerlink" title="2.4cache的写策略"></a>2.4cache的写策略</h3><p>内存的数据被加载到cache后，在某个时刻要被写回内存，有如下策略：</p><ul><li><em><strong>直写</strong></em>，就是在处理器对cache写入的同时，将数据写入到内存中，这种策略保证了在任何时刻，内存的数据和cache中的数据都是同步的。但是由于处理器每次对cache更新时都要对内存进行写操作，因此总线繁忙，占用了大量内存带宽。运行速度会受影响。</li><li><em><strong>回写</strong></em>，回写系统通过将cache line的标志位添加上一个Dirty标志位，当处理器在改写了某个cache line后，并不是马上把其协会内存，而是将cache line的Dirty标志位置为1.当处理器查表发现该标志位为1时，先将cache line内容写回到内存中，再将新数据写到cache中。</li></ul><blockquote><p>回写系统在多核系统中会引起cache一致性的问题。</p></blockquote><h3 id="2-5cache预取"><a href="#2-5cache预取" class="headerlink" title="2.5cache预取"></a>2.5cache预取</h3><h4 id="2-5-1cache预取原理"><a href="#2-5-1cache预取原理" class="headerlink" title="2.5.1cache预取原理"></a>2.5.1cache预取原理</h4><p>cache之所以能够提高系统性能，主要是程序执行存在局部性现象，即时间局部性和空间局部性。</p><ol><li>时间局部性：是指程序即将用到的指令&#x2F;数据可能就是目前正在使用的指令&#x2F;数据。比如一个循环语句的指令，在循环终止的条件满足之前，处理器需要反复执行循环语句中的指令</li><li>空间局部性：是指程序即将用到的指令&#x2F;数据可能与目前正在使用的指令&#x2F;数据在空间上相邻或相近。比如一个需要顺序处理的数组。</li></ol><p>所谓的cache预取就是预测数据并取入到cache中，是根据空间局部性和时间局部性等在数据&#x2F;指令被使用前取入cache。</p><h4 id="2-5-2DPDK中的预取"><a href="#2-5-2DPDK中的预取" class="headerlink" title="2.5.2DPDK中的预取"></a>2.5.2DPDK中的预取</h4><p>报文处理的基本过程：</p><ol><li>写接收描述符到内存，填充数据缓冲区指针，网卡收到报文后 就会根据这个地址把报文内容填充进去。</li><li>从内存中读取接收描述符（当收到报文时，网卡会更新该结构）（内存读），从而确认是否收到报文。</li><li>从接收描述符确认收到报文时，从内存中读取控制结构体的指针（内存读），再从内存中读取控制结构体（内存读），把从接收描述符读取的信息填充到该控制结构体。</li><li>更新接收队列寄存器，表示软件接收到了新的报文。 </li><li>内存中读取报文头部（内存读），决定转发端口。</li><li>从控制结构体把报文信息填入到发送队列发送描述符，更新发送队列寄存器。 </li><li>从内存中读取发送描述符（内存读），检查是否有包被硬件传送出去。 </li><li>如果有的话，从内存中读取相应控制结构体（内存读），释放数据缓冲区。</li></ol><p>DPDK必须保证所有需要读取的数据都在cache中，否则一旦出现cache不命中，性能将会严重下降。<br>以下是报文接收部分代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (nb_rx &lt; nb_pkts) &#123; </span><br><span class="line">    rxdp = &amp;rx_ring[rx_id]; </span><br><span class="line">    <span class="comment">//读取接收描述符 </span></span><br><span class="line">    staterr = rxdp-&gt;wb.upper.status_error; </span><br><span class="line">    <span class="comment">//检查是否有报文收到</span></span><br><span class="line">    <span class="keyword">if</span> (!(staterr &amp; rte_cpu_to_le_32(IXGBE_RXDADV_STAT_DD))) <span class="keyword">break</span>;</span><br><span class="line">    rxd = *rxdp; </span><br><span class="line">    <span class="comment">//分配数据缓冲区</span></span><br><span class="line">    nmb = rte_rxmbuf_alloc(rxq-&gt;mb_pool); </span><br><span class="line">    nb_hold++; </span><br><span class="line">    <span class="comment">//读取控制结构体</span></span><br><span class="line">    rxe = &amp;sw_ring[rx_id]; ……</span><br><span class="line">    rx_id++;</span><br><span class="line">    <span class="keyword">if</span> (rx_id == rxq-&gt;nb_rx_desc) rx_id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//预取下一个控制结构体mbuf</span></span><br><span class="line">    rte_ixgbe_prefetch(sw_ring[rx_id].mbuf); </span><br><span class="line">    <span class="comment">//预取接收描述符和控制结构体指针 </span></span><br><span class="line">    <span class="keyword">if</span> ((rx_id &amp; <span class="number">0x3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        rte_ixgbe_prefetch(&amp;rx_ring[rx_id]); </span><br><span class="line">        rte_ixgbe_prefetch(&amp;sw_ring[rx_id]);</span><br><span class="line">&#125;</span><br><span class="line">…… </span><br><span class="line">    <span class="comment">//预取报文</span></span><br><span class="line">    rte_packet_prefetch((<span class="type">char</span> *)rxm-&gt;buf_addr + rxm-&gt;data_off); </span><br><span class="line">    <span class="comment">//把接收描述符读取的信息存储在控制结构体mbuf中 </span></span><br><span class="line">    rxm-&gt;nb_segs = <span class="number">1</span>; </span><br><span class="line">    rxm-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">    rxm-&gt;pkt_len = pkt_len; </span><br><span class="line">    rxm-&gt;data_len = pkt_len; </span><br><span class="line">    rxm-&gt;port = rxq-&gt;port_id; ……</span><br><span class="line">    rx_pkts[nb_rx++] = rxm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6cache一致性"><a href="#2-6cache一致性" class="headerlink" title="2.6cache一致性"></a>2.6cache一致性</h3><h4 id="2-6-1cache一致性问题的由来及解决办法"><a href="#2-6-1cache一致性问题的由来及解决办法" class="headerlink" title="2.6.1cache一致性问题的由来及解决办法"></a>2.6.1cache一致性问题的由来及解决办法</h4><p>当多个处理器对某个内存块同时读写时，同时对内存进行写回操作时，便会引起冲突，这便是cache一致性问题。<br>cache一致性问题出现的原因时在一个多处理器系统中，每个处理器核心都有独占的cache系统，因此当他们独立执行计算机指令时，有可能同时对某个内存块进行读写操作。<br>cache一致性问题的根源是因为存在多个处理器独占的cache而不是多个处理器。<br>解决办法：两种机制</p><ol><li>基于目录的协议<br>需要缓存在cache的内存块被统一存储在一个目录表中，目录表统一管理所有的数据。<br>特点：延迟性较大，有更好的扩展性</li><li>总线窥探协议<br>提出了一个窥探的动作，即对于被处理器独占的cache中的缓存的内容，该处理器负责监听总线，如果该内容被本处理器修改，则需要总线广播，繁殖如果本处理器的cache从总线收到了通知，则需要改变本地备份的状态。<br>适用于具有广播能力的总线结构。<h4 id="2-6-3DPDK如何保证cache一致性"><a href="#2-6-3DPDK如何保证cache一致性" class="headerlink" title="2.6.3DPDK如何保证cache一致性"></a>2.6.3DPDK如何保证cache一致性</h4>dpdk的解决方案很简单，首先就是避免多个核访问同一个内存地址或者数据结构。这样每个核都避免与其他核共享数据，从而减少因为错误的数据共享导致的cache一致性的开销。</li></ol>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/cache/">cache</category>
      
      <category domain="http://singlewang.top/tags/%E5%86%85%E5%AD%98/">内存</category>
      
      
      <comments>http://singlewang.top/2022/05/03/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux命令</title>
      <link>http://singlewang.top/2022/05/03/linux/linux-command/linux%E5%91%BD%E4%BB%A4/</link>
      <guid>http://singlewang.top/2022/05/03/linux/linux-command/linux%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Tue, 03 May 2022 03:24:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;.    #当前文件夹&lt;br&gt;..   #上一级文件夹&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;tar&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;tar -zxvf             解压缩&lt;br&gt;tar -zcv</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>.    #当前文件夹<br>..   #上一级文件夹</p></blockquote><hr><p><em><strong>tar</strong></em><br>tar -zxvf             解压缩<br>tar -zcvf             压缩</p><blockquote><p>解压tar.xz文件时<br>xz -d xxx.tar.xz 之后会得到xxx.tar文件<br>再执行tar -xvf xxx.tar即可</p></blockquote><p><em>~&#x2F;.bash_history 记录了所有的历史命令</em><br>执行history中的某一句，只需用！加行号<br><code>!1322</code></p><hr><p><em><strong>find</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find ./home/wang -name test.txt  在/home/wang路径下寻找test.txt文件</span><br><span class="line"></span><br><span class="line">find ./home/wang -name <span class="string">&quot;*.c&quot;</span> 在/home/wang路径下寻找所有后缀为.c的文件</span><br></pre></td></tr></table></figure><hr><p><em><strong>grep</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep -i -n &quot;hello&quot; ./*.cpp 在当前文件夹下所有的.cpp文件中查找hello字符串，-n 并且打印行号，-i 不区分大小写</span><br><span class="line">grep -r &quot;include&quot; ./*.cpp 在当前文件夹下所有的.cpp文件中查找include字符串，-r 并且打印文件路径</span><br><span class="line">ls | grep -n &#x27;.c$&#x27;  列出所有的.c文件</span><br><span class="line">grep shell ed.md 在文件ed.md中查找所有的单词shell</span><br></pre></td></tr></table></figure><hr><p><em><strong>环境变量</strong></em><br>查看全局变量 <code>env</code> 或者 <code>printenv</code><br><code>export PATH=$PATH:/home/wang</code>        将某个路径添加到环境变量中，只能生效一次，待重启之后依然需要重新添加<br><code>echo</code> 显示变量的值<br><code>echo $PATH</code> 取出变量PATH的内容</p><hr><p><em><strong>vim</strong></em><br>vim常用命令：<br><code>yy</code> 复制光标所指的当前行<br><code>nyy</code> 复制光标所指的一行往下n行<br><code>p</code> 粘贴在光标以下<br><code>P</code> 粘贴在光标以上<br><code>dd</code> 删除光标所指的一行<br><code>ndd</code> 删除光标所指的往下n行<br><code>set nu</code> 显示行号</p><hr><blockquote><p>反单引号&#96;&#96;&#96;这个符号代表的意义为何？<br>在一串指令中，在”&#96;”之内的指令会被先执行，而其执行出来的结果将作为外部的输入信息</p></blockquote><hr><p><code>uname -a</code> 查看当前内核版本</p><p><code>?</code>代表一个字符<br><code>*</code> 代表零个或多个字符</p><hr><p><em><strong>进程</strong></em><br><code>ps</code>                查看进程<br><code>top</code>               显示实时进程<br><code>kill 3445</code>(端口号)  结束进程 </p><p><code>ctrl+c</code>             中断进程<br><code>ctrl+z</code>              暂停进程 </p><hr><p><code>rmdir</code> 删除目录<br><code>rm -rf</code> 强制删除目录，即使目录下面有文件<br>要想同时创建多个目录和子目录，需要加入-p参数<br><code>mkdir -p new_dir/sub_dir/under_dir</code><br><code>tree</code> 目录以树的形式列出目录中的所有文件<br><code>file</code>  查看文件类型<br><code>cat file1</code> 显示文件内容<br><code>cat -n file1</code> 给显示的文件内容加上行号<br><code>cat -b file</code>   只给文件中有内容的加上行号</p><p><code>du</code>显示当前目录下所有的文件、目录、子目录的磁盘使用情况:</p><ul><li>-c  显示所有已列出文件的大小</li><li>-h 以易读形式显示</li><li>-s 显示每个输出参数的总计</li></ul><hr><p><em><strong>挂载</strong></em><br>要手动在虚拟目录中挂载设备，需要以root用户身份登录，或是以root用户身份运行sudo命<br>令。下面是手动挂载媒体设备的基本命令：<br><code>mount -t type device directory</code></p><blockquote><p>&#x3D;&#x3D;文件类型&#x3D;&#x3D;：<br><em>vfat</em>：Windows长文件系统。<br><em>ntfs</em>：Windows NT、XP、Vista以及Windows 7中广泛使用的高级文件系统。<br><em>iso9660</em>：标准CD-ROM文件系统。</p></blockquote><p>手动将U盘&#x2F;dev&#x2F;sdb1挂载到&#x2F;media&#x2F;disk，可用下面的命令：<br><code>mount -t vfat /dev/sdb1 /media/disk</code></p><ul><li>从Linux系统上移除一个可移动设备时，不能直接从系统上移除，而应该先卸载。</li><li>Linux上不能直接弹出已挂载的CD。如果你在从光驱中移除CD时遇到麻烦，通常是因为该CD还挂载在虚拟目录里。先卸载它，然后再去尝试弹出。</li></ul><p><code>df -h</code> 查看所有已挂载磁盘的使用情况，-h把磁盘空间以易读的形式显示</p><hr><p><em><strong>sort</strong></em><br><code>sort</code> 按指定的默认语言的排序规则对文件中的数据进行排序</p><ul><li>-d 仅考虑空白和字母</li><li>-n 按字符串数值排序</li><li>-u 消除输出中重复的行</li><li>-r 逆序排列</li><li>-o 指定输出文件</li></ul><hr>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-command/">Linux命令</category>
      
      
      <category domain="http://singlewang.top/tags/Linux/">Linux</category>
      
      <category domain="http://singlewang.top/tags/Linux%E5%91%BD%E4%BB%A4/">Linux命令</category>
      
      
      <comments>http://singlewang.top/2022/05/03/linux/linux-command/linux%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
