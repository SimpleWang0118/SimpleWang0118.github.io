<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Single Wang&#39;s Blog</title>
    <link>http://singlewang.top/</link>
    
    <atom:link href="http://singlewang.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>智者不入爱河，愚者重蹈覆辙</description>
    <pubDate>Sat, 25 Jun 2022 11:41:49 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>c++primer之语句</title>
      <link>http://singlewang.top/2022/06/25/cpp/cpp_primer_ch5/</link>
      <guid>http://singlewang.top/2022/06/25/cpp/cpp_primer_ch5/</guid>
      <pubDate>Sat, 25 Jun 2022 11:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h2&gt;&lt;h3 id=&quot;简单语句&quot;&gt;&lt;a href=&quot;#简单语句&quot; class=&quot;headerlink&quot; title=&quot;简单语句&quot;&gt;&lt;/a&gt;简单语句&lt;/h</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h3><p>正常人都知道一些简单语句，不再赘述。<br><em>空语句</em><br>空语句只有一个单独的分号<br>eg：<code>;</code><br>常见情况是，当循环的全部工作在条件部分可以完成时，通常使用空语句。</p><p><em>别漏写分号，也别多写分号</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(iter!=a.<span class="built_in">end</span>());<span class="comment">//循环体是空语句</span></span><br><span class="line">    ++iter; <span class="comment">//递增运算不属于循环</span></span><br></pre></td></tr></table></figure><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition1)</span><br><span class="line">    statement; <span class="comment">//没有else分支</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(condition2)</span><br><span class="line">    statement1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statement2；</span><br></pre></td></tr></table></figure><p>除此之外，还有嵌套if-else，但是很简单不再赘述。</p><p><strong>悬垂else</strong>：指当if分支多余else分支时，if和else分匹配问题。</p><p>c++规定else与离其最近的尚未匹配的if匹配。<br>通常用花括号控制执行的路径。</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> acnt=<span class="number">0</span>,ecnt=<span class="number">0</span>,icnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">switch</span> (ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        acnt++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        ecnt++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        icnt++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>case的标签必须是整型常量表达式。<br>有时候，我们需要多个值共享一组操作时可以省略掉break语句，只在最后一个符合条件的语句中加break。</p></blockquote><p>一般不要省略break语句。</p><h3 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h3><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure><p>只要condition的求值结果为真就会一直执行statement。<br>当不确定要迭代多少次时，使用while比较合适。</p><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p><em>传统for语句</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(init-statement;condition;express)</span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure><p>for语句头中定义的对象只在for循环体内可见。</p><p><em>范围for语句</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaratioin:expression)</span><br><span class="line">    statement</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;r:v)</span><br><span class="line">    r*=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>expression表示的必须是一个序列，比如数组、vector、string等类型的对象。<br>declaration定义一个变量，序列中的每个元素都能转换成该变量的类型。</p><h4 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h4><p>do while语句与while语句很相似区别是do while语句先执行循环体后检查条件，至少会执行一次循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">    statement</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(condition)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>do while语句最后用一个分号结束</p></blockquote><h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><h4 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h4><p>break语句负责中止离它最近的循环语句，并从这些语句之后的第一天语句开始继续执行。</p><h4 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h4><p>continue语句终止最近的循环中的当前迭代并立即开始下一次迭代。只能出现在for、while、do while循环的内部。<br>continue终止当前迭代，但是仍然执行循环。</p><h4 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> lable;</span><br><span class="line"></span><br><span class="line">lable: <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><blockquote><p>一般不要在程序中使用goto语句，会使得程序即难理解又难修改。</p></blockquote><h3 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h3><p>异常处理机制由异常检测和异常处理两部分协作完成。<br>异常处理包括：</p><ul><li>throw表达式：异常检测部分使用throw表达式来表示它遇到了无法处理的问题。</li><li>try语句块：以关键字try开始，以一个或者多个catch子语句结束。</li></ul><h4 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a!=b)</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;error&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果a不等于b，则抛出一个类型为runtime_error的异常。抛出异常将终止当前的函数，并把控制权交给能处理该异常的代码。</p><p>runtime_error是标准库异常类型的一种。</p><h4 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h4><p>通用形式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    program-statement</span><br><span class="line">&#125;   <span class="built_in">catch</span>(expression)&#123;</span><br><span class="line">    handler</span><br><span class="line">&#125;   <span class="built_in">catch</span>(expression2)&#123;</span><br><span class="line">    handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h4><table><thead><tr><th align="center">异常类型</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">exception</td><td align="center">最常见的问题</td></tr><tr><td align="center">runtime_error</td><td align="center">只有在允许时才能检测出的问题</td></tr><tr><td align="center">range_error</td><td align="center">生成结果超出范围</td></tr><tr><td align="center">logic_error</td><td align="center">程序逻辑错误</td></tr><tr><td align="center">invalid_argument</td><td align="center">无效参数</td></tr><tr><td align="center">length_error</td><td align="center">试图创建一个超出该类型最大长度的对象</td></tr><tr><td align="center">out_of_range</td><td align="center">使用一个超出范围的值</td></tr><tr><td align="center">domain_error</td><td align="center">参数对应的结果不存在</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/CPP/">CPP</category>
      
      
      <category domain="http://singlewang.top/tags/cpp/">cpp</category>
      
      
      <comments>http://singlewang.top/2022/06/25/cpp/cpp_primer_ch5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>c++primer之字符串、向量、数组</title>
      <link>http://singlewang.top/2022/06/24/cpp/cpp_primer_ch3/</link>
      <guid>http://singlewang.top/2022/06/24/cpp/cpp_primer_ch3/</guid>
      <pubDate>Fri, 24 Jun 2022 13:20:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;命名空间的using声明&quot;&gt;&lt;a href=&quot;#命名空间的using声明&quot; class=&quot;headerlink&quot; title=&quot;命名空间的using声明&quot;&gt;&lt;/a&gt;命名空间的using声明&lt;/h2&gt;&lt;p&gt;通过&lt;strong&gt;using声明&lt;/strong&gt;使用命名</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>通过<strong>using声明</strong>使用命名空间，无须专门的前缀也能使用所需的名字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::std;  <span class="comment">//使用std命名空间</span></span><br></pre></td></tr></table></figure><p><em>每个名字都需要独立的using声明</em><br><em>头文件不应包含using声明</em></p><h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>标准库类型string表示可变长的字符序列，使用时必须首先包含string头文件。</p><h3 id="定义和初始化string"><a href="#定义和初始化string" class="headerlink" title="定义和初始化string"></a>定义和初始化string</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">string s2=s1;</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;</span><br><span class="line">string s3=<span class="string">&quot;value&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(n,<span class="string">&#x27;c&#x27;</span>)</span></span>;<span class="comment">//把s4初始化为由n个字符c组成的串</span></span><br></pre></td></tr></table></figure><p><strong>拷贝初始化</strong>：使用&#x3D;初始化一个变量<br><strong>直接初始化</strong>：不使用等号初始化</p><h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p><em>读写string对象</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><em>读取位置数量的string对象</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s)</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>使用getline读取一整行</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin,line))</span><br><span class="line">        cout&lt;&lt;line&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>string::size_type类型</em><br>size_type类型是一个无符号类型的值，足够放下任何string对象的大小。</p><h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><p><em>使用基于范围的for语句</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;helloworld&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> <span class="params">(<span class="keyword">auto</span> c:str)</span></span></span><br><span class="line"><span class="function">    cout&lt;&lt;c&lt;&lt;endl</span>;</span><br></pre></td></tr></table></figure><p><em>使用for语句改变字符串中的字符</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;helloworld&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:str)</span><br><span class="line">    c=<span class="built_in">toupper</span>(c);</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><em>只处理一部分字符</em><br>有两种方式</p><ol><li>使用下标<blockquote><p>string对象的下标必须大于等于0小于s.size()</p></blockquote></li><li>使用迭代器</li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *parr[<span class="number">10</span>];<span class="comment">//含有10个整型指针的数组</span></span><br></pre></td></tr></table></figure><p>定义数组时必须指定数组的类型，不允许使用auto关键字由初始值的列表推断类型。</p><p><em>显示初始化数组</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="comment">//等价于a3[]=&#123;0,1,2,0,0&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em><strong>不允许拷贝和赋值</strong></em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[]=a;<span class="comment">//错误</span></span><br><span class="line">b=a;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h3 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h3><p>通常情况下，使用取地址符获取指向某个对象的指针，取地址符可以用于任何对象，包括数组的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p=&amp;a[<span class="number">0</span>];<span class="comment">//p指向a的第一个元素</span></span><br></pre></td></tr></table></figure><p><em>指针也是迭代器</em><br>可以通过++移动指针。</p><p><em>指针运算</em><br>给一个指针加或减去某个整数值，结果仍然是指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p=arr;</span><br><span class="line"><span class="type">int</span> *p2=p+<span class="number">4</span>;<span class="comment">//指向arr[4]</span></span><br></pre></td></tr></table></figure><p>如果两个指针指向同一个数组的元素，或者指向该数组的尾元素的下一个位置，就能利用关系运算符对其进行比较。如果分别指向不同的对象，则不能比较。</p><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>&#x3D;&#x3D;<em>严格来说，c++语言中没有多维数组，通常所说的多维数组其实是数组的数组</em>&#x3D;&#x3D;</p><p>通常使用两个维度来定义多维数组，一个维度表示数组本身大小，另外一个维度表示其元素大小。</p><p><em>多维数组的初始化</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;<span class="comment">//效果一样</span></span><br></pre></td></tr></table></figure><p><em>多维数组的下标引用</em><br>如果表达式含有的下标运算符和数组的维度一样多，该表达式的结果将是给定类型的元素。如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将式给定索引处的一个内层数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>][<span class="number">3</span>]=arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">int</span> (&amp;row)[<span class="number">4</span>]=a[<span class="number">1</span>];把row绑定到row的第二个<span class="number">4</span>元素数组上。</span><br></pre></td></tr></table></figure><p><em>指针和多维数组</em><br>多维数组实际上式数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">4</span>]=a;<span class="comment">//p指向含有四个整数的数组</span></span><br><span class="line">p=&amp;a[<span class="number">2</span>];<span class="comment">//p指向a的尾元素</span></span><br></pre></td></tr></table></figure><blockquote><p>上述声明中，圆括号必不可少：<br>int *p[4];&#x2F;&#x2F;整型指针的数组<br>int (*p)[4];&#x2F;&#x2F;指向含有4个整数的数组</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/CPP/">CPP</category>
      
      
      <category domain="http://singlewang.top/tags/cpp/">cpp</category>
      
      
      <comments>http://singlewang.top/2022/06/24/cpp/cpp_primer_ch3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>c++primer之变量和基本类型</title>
      <link>http://singlewang.top/2022/06/10/cpp/cpp_primer_ch2/</link>
      <guid>http://singlewang.top/2022/06/10/cpp/cpp_primer_ch2/</guid>
      <pubDate>Fri, 10 Jun 2022 13:20:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;变量和基本类型&quot;&gt;&lt;a href=&quot;#变量和基本类型&quot; class=&quot;headerlink&quot; title=&quot;变量和基本类型&quot;&gt;&lt;/a&gt;变量和基本类型&lt;/h2&gt;&lt;h3 id=&quot;基本内置类型&quot;&gt;&lt;a href=&quot;#基本内置类型&quot; class=&quot;headerlink&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h2><h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><p>基本内置类型包括：</p><ul><li>算术类型(arithmetic type)<ul><li>字符</li><li>整数型</li><li>布尔值</li><li>浮点</li></ul></li><li>空类型(void)<h4 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h4><table><thead><tr><th align="center">类型</th><th align="center">size</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">8位</td></tr><tr><td align="center">wchar_t</td><td align="center">16</td></tr><tr><td align="center">char16_t</td><td align="center">16</td></tr><tr><td align="center">char32_t</td><td align="center">32</td></tr><tr><td align="center">short</td><td align="center">16</td></tr><tr><td align="center">int</td><td align="center">16</td></tr><tr><td align="center">long</td><td align="center">32</td></tr><tr><td align="center">long long</td><td align="center">64</td></tr></tbody></table></li></ul><blockquote><p>c++规定一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大。long long是在c++11中新定义的</p></blockquote><p>浮点型可表示单精度、双精度和扩展精度值。通常float以1个字来表示，double以2个字来表示，long double以3或4个字表示。一般来说类型float和double分别有7个和16个有效位。</p><p><strong>带符号类型和无符号类型</strong><br>整型可以划分为带符号和无符号，在带符号类型前加<code>unsigned</code>即可得到无符号类型。<br>字符型被分成三种：char、signed char、unsigned char。<br>c++标准约定在表示范围内正值和负值量应该平衡。因此8bit的signed char理论上可以表示-127到127区间内的值，大多数现代计算机将实际的表示范围定为-128~127。</p><blockquote><p>选择类型经验准则：</p><ul><li>当明知数值不可能为负，选用无符号类型</li><li>使用int进行整数运算</li><li>在算数表达式中不要使用char或bool</li><li>执行浮点运算选用double</li></ul></blockquote><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。</p><blockquote><p><strong>避免无法预知和依赖于实现环境的行为</strong>：<br>无法预知的行为源于编译器无须检测的错误。即使代码编译通过了，运行时仍然可能产生错误。</p></blockquote><blockquote><p><strong>切勿混用带符号类型和无符号类型</strong></p></blockquote><h4 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h4><p>一个形如42的值被称为<strong>字面值常量</strong>，每个字面值常量对应一种数据类型。它的形式和值决定了它的数据类型</p><blockquote><p>eg: 20<br>20 (十进制)  024(八进制)  0x14(十六进制)</p></blockquote><p><strong>指定字面值的类型</strong><br>字符和字符串字面值</p><table><thead><tr><th align="center">前缀</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">u</td><td align="center">char16_t</td></tr><tr><td align="center">U</td><td align="center">char32_t</td></tr><tr><td align="center">L</td><td align="center">wchar_t</td></tr><tr><td align="center">u8</td><td align="center">char</td></tr><tr><td align="center">整型字面值</td><td align="center"></td></tr><tr><td align="center">后缀</td><td align="center">最小匹配类型</td></tr><tr><td align="center">:–:</td><td align="center">:–:</td></tr><tr><td align="center">u or U</td><td align="center">unsigned</td></tr><tr><td align="center">l or L</td><td align="center">long</td></tr><tr><td align="center">ll or LL</td><td align="center">long long</td></tr></tbody></table><p>浮点型字面值</p><table><thead><tr><th align="center">后缀</th><th align="center">最小匹配类型</th></tr></thead><tbody><tr><td align="center">f or F</td><td align="center">float</td></tr><tr><td align="center">l or L</td><td align="center">long double</td></tr></tbody></table><p><strong>c++语言规定的转义序列</strong>：<br>换行符   \n      横向制表符   \t<br>纵向制表符  \v   退格符      \b<br>反斜线    \     问号     ?<br>回车符   \r      单引号    &#39;</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>基本形式：<strong>类型说明符</strong>+一个或多个变量名组成的列表+分号</p><blockquote><p><strong>什么是对象</strong><br>通常情况下，对象是指一块能存储数据并具有某种类型的内存空间</p></blockquote><p>当对象被创建时获得了一个特定的值，我们就说这个值被<strong>初始化</strong>了。</p><blockquote><p>初始化不是赋值，初始化的含义使创建变量时赋予一个初始值，而赋值的含义是把对象的当前值擦除，以一个新值来替代。</p></blockquote><h4 id="变量声明和定义"><a href="#变量声明和定义" class="headerlink" title="变量声明和定义"></a>变量声明和定义</h4><p><strong>声明</strong>使得名字被程序知道，如果要使用别处定义的名字必须包含该名字的声明。<br><strong>定义</strong>创建与名字关联的实体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i ;<span class="comment">//声明i</span></span><br><span class="line"><span class="type">int</span> j; <span class="comment">//声明并定义j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.1416</span>; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure><blockquote><p>变量能且只能被定义一次，但是可以被多次声明<br>一般来说，在对象第一次使用的地方定义更好。</p></blockquote><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><strong>引用</strong>就是为对象起了另一个名字，并且引用必须被初始化，通过在变量前加&amp;定义引用类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">11</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref = a;</span><br><span class="line">ref = <span class="number">13</span>; <span class="comment">//把13赋值给a</span></span><br></pre></td></tr></table></figure><blockquote><p>为什么引用要被初始化<br>因为引用时，程序把引用和初始值绑定在一起，而不是将初始值拷贝给引用。</p></blockquote><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p><strong>指针</strong>：在变量名前加*来定义指针,指针存放某个对象的地址,要想获得该地址，需要用取地址符&amp;。如果指针指向了一个对象，需要使用解引用符 *来访问对象</p><ol><li>指针本身就是一个对象，允许对指针赋值和拷贝</li><li>指针无需在定义时赋初值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;a; <span class="comment">//指向地址</span></span><br><span class="line"><span class="type">int</span> *ptr2 = ptr; <span class="comment">//指向int对象的指针</span></span><br><span class="line">cout&lt;&lt;*ptr;</span><br></pre></td></tr></table></figure></li></ol><p><strong>指针值</strong>应属于下列4种状态之一：</p><ol><li>指向一个对象</li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针</li><li>无效指针，上述情况以外的值</li></ol><p><strong>空指针</strong>不指向任何对象，生成空指针如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p =<span class="literal">nullptr</span>; <span class="comment">//C++11引入</span></span><br><span class="line"><span class="type">int</span> *p =<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p =<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><blockquote><p>建议初始化所有指针，并且尽量等定义了对象之后再定义指向它的指针。</p></blockquote><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p>加了const限定符的变量不能被改变，相当于一个常量。任何试图修改该值的行为都会引发错误，并且const对象必须初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i=<span class="built_in">get</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j=<span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>默认情况下，const对象仅在文件内有效，但是如果我们要使用的const常量，初始值不是一个常量表达式，但是有需要在文件间共享，只需在const变量前添加extern即可。</p><h4 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h4><p><strong>常量表达式</strong>是指不会改变并且在编译过程就能得到计算结果的表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max =<span class="number">20</span>;<span class="comment">//是</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = max+<span class="number">1</span>;<span class="comment">//是</span></span><br><span class="line"><span class="type">int</span> b=<span class="number">2</span>;<span class="comment">//不是</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="built_in">get_size</span>();<span class="comment">//不是常量表达式</span></span><br></pre></td></tr></table></figure><p>但是在复杂的系统中，很难分辨一个初始值是不是常量表达式，因此c++11标准规定，允许将变量声明为constexpr类型由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，并且必须用常量表达式初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> b=a+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>一般来说，如果认定变量是一个常量表达式，就把其设为constexpr类型。</p><p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。</p><h3 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h3><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名就是给某种类型重新定义一个名字。传统方法是使用关键字typedef:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages; <span class="comment">//wages与double同义</span></span><br><span class="line"><span class="keyword">typedef</span> wages base,*p;<span class="comment">//base是double的同义词，p是double*的同义词。</span></span><br></pre></td></tr></table></figure><p>新标准使用别名声明来定义类型的别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI  Sale_item;<span class="comment">//SI是Sale_item的同义词。</span></span><br></pre></td></tr></table></figure><h4 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h4><p>auto类型说明符是在c++新标准引入的，用它就能让编译器替我们去分析表达式所属的类型。因此auto定义的变量必须有初始值。<br>使用auto可以在一个语句中声明多个变量，但是该语句中所有变量的初始基本数据类型必须一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i=<span class="number">0</span>;*p=&amp;i;</span><br></pre></td></tr></table></figure><h4 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h4><p>decltype类型说明符是选择并返回操作数的数据类型，编译器可以得到它的类型，但是不计算表达式的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum=x;<span class="comment">//sum的类型就是f返回的类型。</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/CPP/">CPP</category>
      
      
      <category domain="http://singlewang.top/tags/cpp/">cpp</category>
      
      
      <comments>http://singlewang.top/2022/06/10/cpp/cpp_primer_ch2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch9硬件加速与功能卸载</title>
      <link>http://singlewang.top/2022/06/09/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch9/</link>
      <guid>http://singlewang.top/2022/06/09/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch9/</guid>
      <pubDate>Thu, 09 Jun 2022 11:22:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;硬件加速与功能卸载&quot;&gt;&lt;a href=&quot;#硬件加速与功能卸载&quot; class=&quot;headerlink&quot; title=&quot;硬件加速与功能卸载&quot;&gt;&lt;/a&gt;硬件加速与功能卸载&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;硬件的缺点：资源局限，功能固化，设计与发布的时间长，更新周</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="硬件加速与功能卸载"><a href="#硬件加速与功能卸载" class="headerlink" title="硬件加速与功能卸载"></a>硬件加速与功能卸载</h3><blockquote><p>硬件的缺点：资源局限，功能固化，设计与发布的时间长，更新周期长。</p></blockquote><h4 id="硬件卸载"><a href="#硬件卸载" class="headerlink" title="硬件卸载"></a>硬件卸载</h4><p>硬件卸载就是将某些功能下移到硬件实现。这些功能原先一般是由软件承担的。<br>对于专有网络设备，为了提高处理数据包的速度，常常将数据面与控制面分离。控制面主要对复杂的数据包进行复杂的控制处理，数据面就是进行简单类似的包处理。<br>基于专门设计的硬件，快速执行数据包的转发和一些简单的报文修改处理可以有效地提高数据的吞吐量和降低发送时延。</p><h4 id="DPDK软件接口"><a href="#DPDK软件接口" class="headerlink" title="DPDK软件接口"></a>DPDK软件接口</h4><p>网卡的硬件卸载功能可能是基于端口设置，也有可能是基于每个包使能设置，需要仔细区分。在包粒度而言，每个包都对应一个或者多个Mbuf，DPDK软件利用<code>rte_mbuf</code>数据结构里的64位的标识(<code>ol_flags</code>)来表征卸载和状态</p><h4 id="硬件与软件功能实现"><a href="#硬件与软件功能实现" class="headerlink" title="硬件与软件功能实现"></a>硬件与软件功能实现</h4><p>如果需要使用硬件卸载功能，网卡驱动需要提供相应的API给上层应用，通过调用API驱动硬件完成相应的工作。<br>硬件提供的接口一般包括寄存器(<code>Register</code>)和描述符(<code>Descriptor</code>)。寄存器是全局的设置，一般用于开启某项功能或者为某项功能设置全局性的参数配置。<br>描述符可以看作是每个数据包的属性，和数据包一起发送给硬件，一般用于携带单个数据包的参数或设置。<br>按照功能的相似性，硬件卸载功能大致可分为三类，分别是&#x3D;&#x3D;计算及更新功能&#x3D;&#x3D;、&#x3D;&#x3D;分片功能&#x3D;&#x3D;、&#x3D;&#x3D;组包功能&#x3D;&#x3D;。</p><h4 id="计算及更新功能卸载"><a href="#计算及更新功能卸载" class="headerlink" title="计算及更新功能卸载"></a>计算及更新功能卸载</h4><h5 id="VLAN硬件卸载"><a href="#VLAN硬件卸载" class="headerlink" title="VLAN硬件卸载"></a>VLAN硬件卸载</h5><p>VLAN只有四个字节，可以实现以太网中逻辑网络隔离功能。<br>如果由软件完成VLAN Tag的插入将给CPU带来额外的负荷，设计一次额外的内存拷贝。VLAN Tag的插入和剥离由网卡硬件完成，可以减轻服务器CPU的负荷。<br><strong>收包时VLAN Tag的过滤</strong><br>VLAN定义了虚拟网络，只有属于相同VLAN的报文，才需要被进一步处理，不属于VLAN的报文会被直接丢弃，网卡最典型的卸载功能之一就是在接收侧针对VLAN进行包过滤。比较典型的实现实在网卡硬件端口设计VLAN过滤表，无法在过滤表中匹配的VLAN包会被丢弃。<br><strong>收包时VLAN Tag的剥离</strong><br>网卡硬件能够对接收到的包的VLAN Tag进行剥离。首先硬件能够对VLAN包进行识别，之后需要在网卡端口的队列上设置使能标志，将剥离特性打开，对应到软件，是驱动写配置入相应的寄存器。网卡硬件会从此寄存器中提取配置信息，用于判断是否对收到的以太网数据进行VLAN剥离。<br>网卡硬件将4字节的VLAN Tag从数据包中剥离，但是 VLAN Tag不能丢弃。DPDK中，驱动对每个接收的数据包进行检测，会依据硬件描述符信息，如果剥离动作发生需要将<code>rte_mbuf</code>中的<code>PKT_RX_VLAN_PKT</code>置位，并且将被剥离的VLAN Tag写入下列字段，供上层使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span>&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> vlan_tci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>发包时VLAN Tag的插入</strong><br>VLAN Tag由两部分组成：<code>TPID(Tag Protocol Identifier)</code>，也就是VLAN的<code>Ether type</code>,和<code>TCI(Tag Control Information)</code>。TPID是一个固定的值，作为一个全局范围内起作用的值，可以通过寄存器进行设置。TCI是每个包相关的，需要逐包设置，在DPDK中，在调用发送函数前，必须提前设置mbuf数据结构。</p><h4 id="分片功能卸载"><a href="#分片功能卸载" class="headerlink" title="分片功能卸载"></a>分片功能卸载</h4><p><strong>TSO</strong><br><code>TSO(TCP Segment Offload)</code>是TCP分片功能的硬件卸载，是发送方向的功能。对于从应用层获取的较大的数据，TCP需要根据下层网络的报文大小限制，将其切分成较小的分片发送。<br>硬件提供的TCP分片硬件卸载功能可以大幅减轻软件对TCP分片的负担。<br>在dpdk&#x2F;testpmd中提供了两条TSO相关的命令行：</p><ol><li>tso set 14000:用于设置tso分片大小</li><li>tso show 0：用于查看tso分片大小</li></ol><h4 id="组包功能卸载"><a href="#组包功能卸载" class="headerlink" title="组包功能卸载"></a>组包功能卸载</h4><p><strong>RSC</strong><br><code>RSC(Receive Side Coalescing，接收方聚合)</code>是TCP组包功能的硬件卸载。硬件组包功能实际上是硬件拆包功能的逆向功能。属于接收方向的功能，可以将拆分的TCP分片聚合成一个大的分片，从而减轻软件的处理。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/">硬件加速</category>
      
      
      <comments>http://singlewang.top/2022/06/09/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>VLAN基本知识</title>
      <link>http://singlewang.top/2022/05/31/mobile-communication/VLAN/</link>
      <guid>http://singlewang.top/2022/05/31/mobile-communication/VLAN/</guid>
      <pubDate>Tue, 31 May 2022 13:21:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;什么是VLAN&quot;&gt;&lt;a href=&quot;#什么是VLAN&quot; class=&quot;headerlink&quot; title=&quot;什么是VLAN&quot;&gt;&lt;/a&gt;什么是VLAN&lt;/h2&gt;&lt;p&gt;&lt;code&gt;VLAN(Virtual Local Area Network)&lt;/code&gt;即虚拟局域</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="什么是VLAN"><a href="#什么是VLAN" class="headerlink" title="什么是VLAN"></a>什么是VLAN</h2><p><code>VLAN(Virtual Local Area Network)</code>即虚拟局域网，是将一个物理的LAN再逻辑上划分成多个广播域的通信技术。<br>每个VLAN是一个广播域，VLAN内的主机间可以直接通信，而VLAN间不能直接互通。这样广播报文就被限制在一个VLAN内。</p><h2 id="为什么需要VLAN"><a href="#为什么需要VLAN" class="headerlink" title="为什么需要VLAN"></a>为什么需要VLAN</h2><p>早期以太网是一种基于CSMA&#x2F;CD（Carrier Sense Multiple Access&#x2F;Collision Detection）的共享通讯介质的数据网络通讯技术。当主机数目较多时会导致冲突严重、广播泛滥、性能显著下降甚至造成网络不可用等问题。通过二层设备实现LAN互连虽然可以解决冲突严重的问题，但仍然不能隔离广播报文和提升网络质量。</p><p>在这种情况下出现了VLAN技术。这种技术可以把一个LAN划分成多个逻辑的VLAN，每个VLAN是一个广播域，VLAN内的主机间通信就和在一个LAN内一样，而VLAN间则不能直接互通，广播报文就被限制在一个VLAN内。</p><p>VLAN的优点：</p><ul><li><strong>限制广播域</strong>：广播域被限制在一个VLAN内，节省了带宽，提高了网络处理能力。</li><li><strong>增强局域网的安全性</strong>：不同VLAN内的报文在传输时相互隔离，即一个VLAN内的用户不能和其它VLAN内的用户直接通信。</li><li><strong>提高了网络的健壮性</strong>：故障被限制在一个VLAN内，本VLAN内的故障不会影响其他VLAN的正常工作。</li><li><strong>灵活构建虚拟工作组</strong>：用VLAN可以划分不同的用户到不同的工作组，同一工作组的用户也不必局限于某一固定的物理范围，网络构建和维护更方便灵活。</li></ul><h2 id="VLAN与子网"><a href="#VLAN与子网" class="headerlink" title="VLAN与子网"></a>VLAN与子网</h2><p><strong>区别</strong></p><ol><li>VLAN用于划分二层网络，子网用于划分三层网络</li><li>VLAN在配置VLANIF接口的基础上实现路由互通后，属于不同VLAN用户才能互访；子网只要通过路由实现网络互通，属于不同子网的用户就能互访</li><li>VLAN内的设备数量不受限制；子网划分的网段会影响各个子网内的设备最大数</li></ol><p><strong>联系</strong></p><ul><li>同一个VLAN内可以划分一个或多个网段，同一子网内，可以划分一个或多个VLAN。</li></ul><h2 id="VLAN的基本概念"><a href="#VLAN的基本概念" class="headerlink" title="VLAN的基本概念"></a>VLAN的基本概念</h2><h3 id="VLAN-Tag"><a href="#VLAN-Tag" class="headerlink" title="VLAN Tag"></a>VLAN Tag</h3><p>为了使设备能够分辨不同VLAN的报文，需要在报文中添加VLAN信息的字段。802.11Q协议规定，在以太网数据帧的目的MAC地址和源MAC地址字段之后、协议类型字段之前加入四个字节的VLAN tag，用来标识VLAN信息。</p><h3 id="VLAN帧格式"><a href="#VLAN帧格式" class="headerlink" title="VLAN帧格式"></a>VLAN帧格式</h3><table><thead><tr><th align="center">Destination address</th><th align="center">Source address</th><th align="center">VLAN tag</th><th align="center">length&#x2F;type</th><th align="center">Data</th><th align="center">FCS</th></tr></thead><tbody><tr><td align="center">6Byte</td><td align="center">6Byte</td><td align="center">4Byte</td><td align="center">2Byte</td><td align="center">46-1500Byte</td><td align="center">4Byte</td></tr></tbody></table><p>VLAN tag包括TPID（数据帧类型）、PRI（数据帧的优先级，0~7，值越大优先级越高）、CFI（标准格式指示位）、VID（VLAN ID）</p><blockquote><p>设备利用VLAN标签中的VID来识别数据帧所属的VLAN,广播帧只在同一VLAN内转发，这就将广播域限制在一个VLAN内。VLAN ID取值范围使0<del>4095，有效范围使1</del>4094。</p></blockquote><h3 id="链路类型和接口类型"><a href="#链路类型和接口类型" class="headerlink" title="链路类型和接口类型"></a>链路类型和接口类型</h3><p>在一个VLAN交换网络中，以太网帧主要有以下两种格式：</p><ul><li><strong>有标记帧（Tagged帧）</strong>：加入了4字节VLAN标签的帧</li><li><strong>无标记帧（untagged帧）</strong>：原始的、未加入4字节VLAN标签的帧</li></ul><p>设备内部处理的数据帧一律都是Tagged帧。</p><p>为了适应不同的连接和组网，设备定义了<strong>Access</strong>接口、<strong>Trunk</strong>接口、<strong>Hybrid</strong>接口，以及<strong>接入链路（Access Link）</strong>和<strong>干道链路（Trunk Link）</strong>。</p><h4 id="链路类型"><a href="#链路类型" class="headerlink" title="链路类型"></a>链路类型</h4><p>根据链路中需要承载的VLAN数目的不同，以太网链路分为：</p><ul><li>接入链路<br>接入链路只可以承载1个VLAN的数据帧，用于连接设备和用户终端，用户终端并不需要知道自己属于哪个VLAN，也不能识别带有Tag的帧，所以在接入链路上传输的帧都是untagged帧</li><li>干道链路<br>干道链路可以承载多个不同VLAN的数据帧，用于设备间互联。因此需要给数据帧加VLAN Tag。</li></ul><h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h4><p>根据接口连接对象以及对收发数据帧处理的不同，以太网接口分别为：</p><ul><li>Access接口<br>Access接口一般用于和不能识别Tag的用户终端相连，或者不需要区分不同VLAN成员时使用，只能收发Untagged帧。</li><li>Trunk接口<br>Trunk接口一般用于连接交换机、路由器、AP以及可同时收发Tagged帧和Untagged帧的语音终端。它可以允许多个VLAN的帧带Tag通过，但只允许一个VLAN的帧从该类接口上发出时不带Tag。</li><li>Hybrid接口<br>Hybrid接口同时综合了以上两种接口的方式，且允许从该类接口发出的某些帧带Tag，某些帧不带Tag。</li></ul>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/mobile-communication/">移动通信</category>
      
      
      <category domain="http://singlewang.top/tags/VLAN/">VLAN</category>
      
      
      <comments>http://singlewang.top/2022/05/31/mobile-communication/VLAN/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch7多队列与流分类</title>
      <link>http://singlewang.top/2022/05/31/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch8/</link>
      <guid>http://singlewang.top/2022/05/31/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch8/</guid>
      <pubDate>Tue, 31 May 2022 11:28:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;流分类与多队列&quot;&gt;&lt;a href=&quot;#流分类与多队列&quot; class=&quot;headerlink&quot; title=&quot;流分类与多队列&quot;&gt;&lt;/a&gt;流分类与多队列&lt;/h3&gt;&lt;h4 id=&quot;多队列&quot;&gt;&lt;a href=&quot;#多队列&quot; class=&quot;headerlink&quot; title=</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="流分类与多队列"><a href="#流分类与多队列" class="headerlink" title="流分类与多队列"></a>流分类与多队列</h3><h4 id="多队列"><a href="#多队列" class="headerlink" title="多队列"></a>多队列</h4><h5 id="网卡多队列的由来"><a href="#网卡多队列的由来" class="headerlink" title="网卡多队列的由来"></a>网卡多队列的由来</h5><p>网卡多队列技术是一个硬件手段，利用该技术，可以做到分而治之。比如视频数据强调实时性，对数据的准确性要求不高，这样我们可以为其队列设置更高的发送优先级，或者说使用更高优先级的队列，为了达到较好的实时性，我们可以减小队列对应的带宽。</p><h5 id="Linux内核对多队列的支持"><a href="#Linux内核对多队列的支持" class="headerlink" title="Linux内核对多队列的支持"></a>Linux内核对多队列的支持</h5><ol><li>多队列对应的结构<br>Linux的网卡由结构体<code>net_device</code>表示，一个该结构体 可对应多个可以调度的数据包发送队列，数据包的实体在内核中以结构体<code>sk_buff（skb）</code>表示。</li><li>接收端<br>网卡驱动程序为每个接收队列设定相应的中断号，通过中断的均衡处理，或者设置中断的亲和性（<code>SMP IRQ Affinity</code>）,从而实现队列绑定到不同的核。</li><li>发送端<br><code>dev_pick_tx</code>用于选取发送队列，可以是driver定制的策略，也可以根据队列优先级选取，按照hash来做均衡。也就是利用<code>XPS(Transmit Packet Steering)</code>机制，智能地选择多队列设备的队列来发送数据包。</li><li>收发队列一般会被绑在同一个中断上。如果从收队列1收上来的包从发队列1发出去，cache命中率高，效率也会高。</li></ol><h5 id="DPDK与多队列"><a href="#DPDK与多队列" class="headerlink" title="DPDK与多队列"></a>DPDK与多队列</h5><p>再某个核上运行的程序从指定的队列上接收，往指定的队列上发送，可以达到很高的cache命中率，效率就会更高。<br>以<code>run to completion</code>为例，可以从核、内存与网卡队列之间的关系来理解DPDK是如何利用网卡多队列技术带来性能的提升。</p><ul><li>将网卡的某个接收队列分配给某个核，从该队列中收到的所有报文都应当在该指定的核上处理结束。</li><li>从核对应的本地存储中分配内存池，接收报文和对应的报文描述符都位于该核和发送队列对应的本地内存池中。</li><li>为每个核分配一个单独的发送队列，发送报文核对应的报文描述符都位于该核和发送队列对应的本地内存池中。</li></ul><p>不同的核，操作的是不同的队列，从而避免了多个线程同时访问一个队列带来的锁的开销。但是如果逻辑核的数目大于每个接口上所含的发送队列的数目，那么就需要有机制将队列分配给这些核。</p><h5 id="队列分配"><a href="#队列分配" class="headerlink" title="队列分配"></a>队列分配</h5><p>包的接收从网卡侧来看分为以下几步：</p><ol><li>监听到线上的报文。</li><li>按照地址过滤报文。</li><li>DMA队列分配。</li><li>将报文暂存在接收数据的先进先出缓存中。</li><li>将报文转移到主存中的指定队列中。</li><li>更新接收描述符的状态。</li></ol><h4 id="流分类"><a href="#流分类" class="headerlink" title="流分类"></a>流分类</h4><h5 id="包的类型"><a href="#包的类型" class="headerlink" title="包的类型"></a>包的类型</h5><p>对于DPDK而言，Mbuf结构中含有相应的字段来表示网卡分析出的包的类型，<code>Packet_type</code>由二层，三层，四层以及tunnel的信息组成。<br>网卡设备同时可以根据报的类型确定其关键字，从而根据关键字确定其收包队列。</p><blockquote><p>不是所有网卡都支持这项功能，支持功能的复杂度也有差异</p></blockquote><h5 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h5><p>负载均衡就是将负载分摊到多个执行单元上执行，对于<code>Packet IO</code>而言，就是将数据包收发处理分摊到多个核上。<br><code>RSS（Receive-Side Scaling）</code>接收方扩展技术可以将流量分散到不同的队列中的技术。它和硬件相关联，必须要有网卡的硬件进行支持。RSS把数据包分配到不同的队列中。<br>简单的说RSS就是根据关键字通过哈希函数计算出哈希值，再由哈希值确定队列。网卡会根据不同的数据包类型选取出不同的关键字。<br>RSS是否能将数据包均匀散开再多个队列中，取决于真实环境中的数据包构成和哈希函数的选取。哈希函数一般选取微软的托普利兹算法。</p><h5 id="服务质量"><a href="#服务质量" class="headerlink" title="服务质量"></a>服务质量</h5><p>多队列应用于服务质量（Qos）流量类别：</p><ul><li>把发送队列分配给不同的流量类别，可以让网卡再发送侧做调度</li><li>把收包队列分配给不同的流量类别，可以做到基于流的限速</li></ul><h5 id="流过滤"><a href="#流过滤" class="headerlink" title="流过滤"></a>流过滤</h5><p>流的合法性验证的主要任务是决定哪些数据包是合法的、可被接收的。&#x3D;&#x3D;合法性检查主要包括对外部来的流和内部流的验证&#x3D;&#x3D;<br>可以被接收的数据包会被网卡送到主机或者网卡内置的管理控制器，其过滤主要集中再以太网的二层功能，包括VLAN及MAC过滤。<br>流的过滤可以分为以下几步：</p><ol><li>MAC地址的过滤（L2Filter）</li><li>VLAN标签的过滤</li><li>管理数据包的过滤</li></ol>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E6%B5%81%E5%88%86%E7%B1%BB/">流分类</category>
      
      
      <comments>http://singlewang.top/2022/05/31/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WIFI基本知识</title>
      <link>http://singlewang.top/2022/05/30/mobile-communication/WIFI%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</link>
      <guid>http://singlewang.top/2022/05/30/mobile-communication/WIFI%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</guid>
      <pubDate>Mon, 30 May 2022 11:47:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;WIFI的连接过程&quot;&gt;&lt;a href=&quot;#WIFI的连接过程&quot; class=&quot;headerlink&quot; title=&quot;WIFI的连接过程&quot;&gt;&lt;/a&gt;WIFI的连接过程&lt;/h2&gt;&lt;p&gt;一般如果STA要和AP建立连接，要经过三个阶段才能够接入：&lt;/p&gt;
&lt;ol&gt;
&lt;li</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="WIFI的连接过程"><a href="#WIFI的连接过程" class="headerlink" title="WIFI的连接过程"></a>WIFI的连接过程</h2><p>一般如果STA要和AP建立连接，要经过三个阶段才能够接入：</p><ol><li>扫描阶段(SCAN)</li><li>认证关联(Authentication)</li><li>关联(Association)</li></ol><h3 id="WIFI扫描"><a href="#WIFI扫描" class="headerlink" title="WIFI扫描"></a>WIFI扫描</h3><p>STA在加入任何网络之前必须识别现有网络，这个过程称为扫描，扫描又分为 <strong>主动扫描</strong> 和 <strong>被动扫描</strong>。</p><ol><li>主动扫描：STA会在每个信道上发出<code>Probe request</code>,携带相关的SSID信息，寻找相同SSID的AP，若找不到，一直扫描下去，找到后等待接收<code>Probe response</code>。</li><li>被动扫描：STA会在各个信道之间不断切换，通过监听AP定期发送的<code>Beacon</code>帧来发现网络，<code>Beacon</code>帧标示了相关的BSS信息（可以理解为对应的路由器的信息就是BSS信息）</li></ol><p>选网原则：</p><ul><li>选择相同SSID的网络做认证</li><li>优先选择信号强度最强或最近使用的网络</li></ul><h3 id="WIFI认证"><a href="#WIFI认证" class="headerlink" title="WIFI认证"></a>WIFI认证</h3><blockquote><p>只有通过STA和AP之间的认证，才能进一步接入无线网络<br>认证可以通过MAC地址认证，或者用户名和密码口令认证</p></blockquote><p>认证的方式有两种：</p><ol><li>开放式认证：STA发送认证请求，AP直接通过认证请求，安全风险较高</li><li>共享密钥认证：STA向AP 发送认证请求，AP随机产生字符串，STA接收到字符串后进行密钥加密后发给AP，AP收到信息后用密钥解密得到随机字符串，如果AP判断字符串与原始发的字符串相同，则认证通过。</li></ol><h3 id="WIFI关联"><a href="#WIFI关联" class="headerlink" title="WIFI关联"></a>WIFI关联</h3><p>STA一旦完成身份认证，便可以发送<code>Association Request</code>,请求获得网络的完全访问权。关联能让AP记录每个STA的位置，以便将帧正确送达。</p><ul><li>STA与AP认证成功后，就可以向AP发送关联请求</li><li>AP将STA的信息添加到数据库，并向STA发出关联响应，则注册成功，完成关联</li><li>关联建立后，即可接入无线网络，实现数据通信</li><li>当STA需要接入新的网络时，需要去关联后，重新认证，和新AP再关联。</li><li>每个STA只能关联到一个AP，但是关联总是由STA发起。</li></ul><p><strong>去关联</strong>是一个单向的，无需确认的过程，可由STA发起也可以由AP发起。只需发送一个通知性质的<code>deauth</code>帧或者<code>disassoc</code>帧，因此容易造成状态不同步</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/mobile-communication/">移动通信</category>
      
      
      <category domain="http://singlewang.top/tags/WIFI/">WIFI</category>
      
      
      <comments>http://singlewang.top/2022/05/30/mobile-communication/WIFI%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux中断和定时器</title>
      <link>http://singlewang.top/2022/05/24/linux/linux-kernal/linux-kernal-driver/Linux%E4%B8%AD%E6%96%AD%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <guid>http://singlewang.top/2022/05/24/linux/linux-kernal/linux-kernal-driver/Linux%E4%B8%AD%E6%96%AD%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <pubDate>Tue, 24 May 2022 13:27:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;中断与定时器&quot;&gt;&lt;a href=&quot;#中断与定时器&quot; class=&quot;headerlink&quot; title=&quot;中断与定时器&quot;&gt;&lt;/a&gt;中断与定时器&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;中断&lt;/strong&gt;：指CPU在指向程序的过程中，出现某些突发事件时，CPU必须暂停执行当</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="中断与定时器"><a href="#中断与定时器" class="headerlink" title="中断与定时器"></a>中断与定时器</h3><p><strong>中断</strong>：指CPU在指向程序的过程中，出现某些突发事件时，CPU必须暂停执行当前的程序，转去处理突发事件，处理完毕后又返回原程序被中断的位置并继续执行。</p><ul><li>根据中断的来源可分为：</li></ul><ol><li>内部中断：中断源来自CPU内部，如软件中断指令、溢出等。</li><li>外部中断：中断源来自CPU外部，由外设请求</li></ol><ul><li>根据是否可以屏蔽分为：</li></ul><ol><li>可屏蔽中断：通过屏蔽字相应，屏蔽后，该中断不再得到相应</li><li>不屏蔽中断：不能被屏蔽</li></ol><ul><li>根据中断入口跳转方法不同，可分为：</li></ul><ol><li>向量中断：CPU通常为不同的中断分配不同的中断号。（硬件）</li><li>非向量中断：多个中断共享一个入口地址，进入该入口地址后再通过软件判断中断标志来识别具体哪个中断。（软件）</li></ol><h3 id="Linux中断编程"><a href="#Linux中断编程" class="headerlink" title="Linux中断编程"></a>Linux中断编程</h3><h4 id="申请和释放中断"><a href="#申请和释放中断" class="headerlink" title="申请和释放中断"></a>申请和释放中断</h4><ol><li>申请irq<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">                <span class="type">void</span> (*handler)(<span class="type">int</span> irq.<span class="type">void</span> *dev_id,<span class="keyword">struct</span> pt_regs *regs),</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">char</span> * devname,</span></span><br><span class="line"><span class="params">                <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure>irq是要申请的硬件中断号。<br>handler是向系统等级的中断处理函数，是一个回调函数。<br>irqflags是中断处理的属性<blockquote><p>SA_INTERRUPT 表示中断处理程序是快速处理程序<br>SA_SHIRQ 表示多个设备共享中断<br>request_irq()返回0表示成功，返回-INVAL表示中断号无效或函数指针为NULL，返回-EBUSY表示中断已经被占用。</p></blockquote></li></ol><p>2.释放IRQ</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,<span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure><h4 id="使能和屏蔽中断"><a href="#使能和屏蔽中断" class="headerlink" title="使能和屏蔽中断"></a>使能和屏蔽中断</h4><p>以下三个函数用于屏蔽一个中断源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">disable_irq</span><span class="params">(<span class="type">int</span> irq)</span>; <span class="comment">//立即返回</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_irq_nosync</span><span class="params">(<span class="type">int</span> irq)</span>; <span class="comment">//等待目前的中断处理完成</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_irq</span><span class="params">(<span class="type">int</span> irq)</span>; <span class="comment">//作用与可编程中断控制器，对系统内的所有CPU都生效。</span></span><br></pre></td></tr></table></figure><p>以下两个函数将屏蔽本CPU内的所有中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">local_irq_save</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> falgs)</span>;<span class="comment">//将目前的中断状态保留在flags中。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">local_irq_diasble</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//直接禁止中断</span></span><br></pre></td></tr></table></figure><p>恢复中断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">local_irq_restore</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">local_irq_enable</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>硬中断、软中断、信号的区别：</p><ol><li>硬中断是外部设备对&#x3D;&#x3D;CPU&#x3D;&#x3D;的中断</li><li>软中断通常是硬中断服务程序对&#x3D;&#x3D;内核&#x3D;&#x3D;的中断</li><li>信号则是由内核对某个&#x3D;&#x3D;进程&#x3D;&#x3D;的中断</li></ol><h3 id="内核定时器"><a href="#内核定时器" class="headerlink" title="内核定时器"></a>内核定时器</h3><h4 id="内核定时器编程"><a href="#内核定时器编程" class="headerlink" title="内核定时器编程"></a>内核定时器编程</h4><p>软件意义上的定时器最终依赖硬件定时器来实现，内核在时钟中断发生后检测各定时器是否到期，到期后的定时器处理函数将作为软中断在底半部执行。</p><p>linux内核所提供的用于操作定时器的数据结构和函数如下：</p><ol><li>timer_list</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span> <span class="comment">//定时器列表</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires; <span class="comment">//定时器到期时间</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">//定时器处理函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;  <span class="comment">//作为参数被传入</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_base_s</span> *<span class="title">base</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">my_timer</span>;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>初始化定时器<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span>;</span><br></pre></td></tr></table></figure></li></ol><p><code>TIMER_INITIALIZER(_function,_expires,_data)</code>宏用于赋值定时结构体的function、expires、data、base成员。</p><ol start="3"><li><p>增加定时器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span>; <span class="comment">//注册内核定时器，将定时器加入到内核动态定时器链表中。</span></span><br></pre></td></tr></table></figure></li><li><p>删除定时器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">del_timer</span><span class="params">(sturct timer_list * timer)</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="内核延时"><a href="#内核延时" class="headerlink" title="内核延时"></a>内核延时</h3><h4 id="短延时"><a href="#短延时" class="headerlink" title="短延时"></a>短延时</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ndelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nsecs)</span>; <span class="comment">//纳秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">udelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> usecs)</span>; <span class="comment">//微秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mdelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span>; <span class="comment">//毫秒</span></span><br></pre></td></tr></table></figure><p>在内核中，最好不要直接使用毫秒级别的延时，这将无所谓地耗费CPU资源。对于毫秒级以上地时延，内核提供了下述函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">msleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>; <span class="comment">//不能被打断</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">msleep_interruptible</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>; <span class="comment">//可以被打断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ssleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>; <span class="comment">//不能被打断</span></span><br></pre></td></tr></table></figure><h4 id="长延时"><a href="#长延时" class="headerlink" title="长延时"></a>长延时</h4><p>内核中进行延时地很直观地方法时比较当前地jiffies和目标jiffies，知道未来地jiffies达到目标jiffies。</p><h4 id="睡着延时"><a href="#睡着延时" class="headerlink" title="睡着延时"></a>睡着延时</h4><p>睡着延时比忙等待更好，随着延迟在等待地时间到来之间进程处于睡眠状态，CPU资源被其他进程使用。<code>schedule_timeout()</code>可以使当前任务睡眠指定地jiffies之后重新被调度执行。<br>实际上<code>schedule_timeout()</code>地实现原理时向系统添加一个定时器，在定时器处理函数中唤醒参数对应地进程。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/linux-kernal-driver/">Linux内核驱动</category>
      
      
      <category domain="http://singlewang.top/tags/Linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/">Linux网络设备</category>
      
      <category domain="http://singlewang.top/tags/Linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/">Linux内核驱动</category>
      
      
      <comments>http://singlewang.top/2022/05/24/linux/linux-kernal/linux-kernal-driver/Linux%E4%B8%AD%E6%96%AD%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我真的有机会被爱吗</title>
      <link>http://singlewang.top/2022/05/20/informal-essay/life/520%E9%9A%8F%E6%83%B3/</link>
      <guid>http://singlewang.top/2022/05/20/informal-essay/life/520%E9%9A%8F%E6%83%B3/</guid>
      <pubDate>Fri, 20 May 2022 03:06:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;红豆生南国，&lt;br&gt;春来发几枝。&lt;br&gt;愿君多采撷，&lt;br&gt;此物最相思。&lt;br&gt;         –《相思》唐·王维&lt;br&gt;讲真，这个标题属实有点矫情了，但是仔细一想，其实也没那么肉麻，更多的是基于我目前现状的一种感叹吧。&lt;br&gt;今天恰好是5月20日，也就是不知道从什么时候</description>
        
      
      
      
      <content:encoded><![CDATA[<p>红豆生南国，<br>春来发几枝。<br>愿君多采撷，<br>此物最相思。<br>         –《相思》唐·王维<br>讲真，这个标题属实有点矫情了，但是仔细一想，其实也没那么肉麻，更多的是基于我目前现状的一种感叹吧。<br>今天恰好是5月20日，也就是不知道从什么时候演变成一个节日的日期，在这一天，朋友圈，微博无处不在秀着各自的恩爱，在从前我还会有些许的羡慕，羡慕情侣之间的浪漫，也曾幻想着自己也能和自己心爱的姑娘在这一天过着属于自己二人世界，可如今我的羡慕之情却已暗淡，因为不知道什么时候起，爱情对我来说就像是不存在一般，仿佛神话故事中那些未曾见过的神兽般虚无缥缈。我不知道自己是否还需要它，因为就目前我的现状来看自己好像也并不是没它不行，一个人的生活也很潇洒，但是看着路边的情侣卿卿我我，也不免会从心底有一丝孤单。<br>我是一个沉默寡言的人，性格随和却又内向，想起昨天玩游戏的时候，碰见一对情侣很有意思，一边聊天一边玩，说找对象要靠口才，乍一听好像有些片面了，但是仔细想想，许多时候人们的邂逅不就是第一次打招呼开始吗，现实中那些滔滔不绝，口若悬河的人也往往更能获得女生的关注，而我则可能呆在角落里看他们嬉戏打闹，我并不是不想参与，只是性格的原因导致我放不开，看见一个心动的女生也不敢上前打招呼，唯一一个令自己心动了那么多年的女生还在前不久和我断联，只能说是我咎由自取吧。但是老实话少就该被嫌弃吗，又或者说得不到关注，说到这儿又想起实验室即将毕业的学长，和他女朋友谈了几年了，工作也找好了，华为的一年40多w，能力强，却在前不久分手了，女方给出的原因是他太没有情趣了，随后就和另一个男生无缝衔接（我也只是听实验室的同学所说），女生的脑回路真的想不明白，当然每个人都有自己的选择，孰是孰非作为一个旁观者不好做评论，只是为这个学长感到不值罢了。<br>我曾经给我爸妈说过，我反正是不会走相亲这条路的。如果找不到互相喜欢的，那就这样一个人挺好的，努力赚钱，做自己想做的事，虽然知道对不起爸妈，但是我实在不想在感情这件事上妥协，我实在做不到和一个自己不喜欢的人去共度余生，那真的会是一场灾难。我不是不想谈，只是不想抱着试一试的态度去谈了。<br>昨晚莫名其妙又梦见她了，也不知道她现在过的怎样，我努力克制自己不去想她，让自己变得忙碌起来，大概两个月的时间没有想她，可是昨晚又做了一个很清晰的梦，让我不愿醒来。渐渐的我也想开了，有些人并不一定非要在一起，遇见已经是最好的结果了。</p><p>今天就随便写写，感情这事遇见了说明是缘分，遇不见也可能是缘分未到，只能不断的提升自己，静待花开。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/informal-essay/">随笔</category>
      
      <category domain="http://singlewang.top/categories/informal-essay/life/">生活感悟</category>
      
      
      <category domain="http://singlewang.top/tags/%E5%BF%83%E5%BE%97/">心得</category>
      
      <category domain="http://singlewang.top/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/">生活感悟</category>
      
      
      <comments>http://singlewang.top/2022/05/20/informal-essay/life/520%E9%9A%8F%E6%83%B3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch7网卡性能优化</title>
      <link>http://singlewang.top/2022/05/17/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch7/</link>
      <guid>http://singlewang.top/2022/05/17/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch7/</guid>
      <pubDate>Tue, 17 May 2022 12:49:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;网卡性能优化&quot;&gt;&lt;a href=&quot;#网卡性能优化&quot; class=&quot;headerlink&quot; title=&quot;网卡性能优化&quot;&gt;&lt;/a&gt;网卡性能优化&lt;/h3&gt;&lt;h4 id=&quot;DPDK的轮询模式&quot;&gt;&lt;a href=&quot;#DPDK的轮询模式&quot; class=&quot;headerlink</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="网卡性能优化"><a href="#网卡性能优化" class="headerlink" title="网卡性能优化"></a>网卡性能优化</h3><h4 id="DPDK的轮询模式"><a href="#DPDK的轮询模式" class="headerlink" title="DPDK的轮询模式"></a>DPDK的轮询模式</h4><p>DPDK采用了轮询或者轮询混杂中断的模式来进行收包和发包，此 前主流运行在操作系统内核态的网卡驱动程序基本都是基于异步中断处理模式。</p><h5 id="异步中断模式"><a href="#异步中断模式" class="headerlink" title="异步中断模式"></a>异步中断模式</h5><p>当有包进入网卡收包队列后，网卡会产生硬件中断，进而触发CPU中断，进入中断服务程序，在中断服务程序中完成收包的处理。<br>基于异步中断信号处理模式的收包，不断地在做中断处理，在CPU比I&#x2F;O速率高很多时，处理地负荷可以被忽略，但是如果是高速网卡且I&#x2F;O频繁，开销就会很大。中断是异步方式，因此CPU无需等待，有效利用率高。<br>当有包需要发送出去地时候，基于异步中断信号地驱动程序会准备奥需要发送地包，配置号发送队列地各个描述符。包被真正发送完成时，网卡同样会产生硬件中断信号，进而触发CPU中断，进入中断服务。</p><h5 id="轮询模式"><a href="#轮询模式" class="headerlink" title="轮询模式"></a>轮询模式</h5><p>DPDK最初地纯轮询模式指收发包完全不使用任何中断，集中所有运算资源用于报文处理，但这不是意味着DPDK部可以支持任何中断。</p><p>DPDK所有地收发包有关的中断在物理端口初始化的时候都会关闭，也就是说，CPU在任何时候都不会收到中断。</p><p>每一个收包队列，DPDK都会有一个对应的软件线程负责轮询里面的收包描述符的收包成功的标志。一旦发现某一个收包描述符的收包成功标志被硬件置位了，驱动程序会解析相应的收包描述符，提取各种有用的信息，然后填充对应的缓冲内存块头部。然后把收包缓冲内存块存放到收包函数提供的数组里面，同时分配好一个新的缓冲内存块给这个描述符，以便下一次收包。</p><p>每一个发包队列，DPDK都会有一个对应的软件线程负责设置需要发送出去的包，DPDK的驱动程序负责提取发包缓冲内存块的有效信息。DPDK的轮询驱动程序根据内存缓存块中的包的内容来负责初始化好每一个发包描述符，驱动程序会把每个包翻译成为一个或者多个发包描述符里能够理解的内容，然后写入发包描述符。最关键的有两个，一个是标识完整的包结束的标志<code>EOP(End Of Packet)</code>,另一个就是请求报告发送状态<code>RS(Report Status)</code>。EOP就是驱动程序用来通知网卡硬件一个完整的包结束的标志。RS是驱动程序告诉网卡什么时候需要报告发送结果的标志。</p><p>发包的轮询就是轮询发包结束的硬件标志位。</p><h5 id="混合中断轮询模式"><a href="#混合中断轮询模式" class="headerlink" title="混合中断轮询模式"></a>混合中断轮询模式</h5><p>由于实际网络应用中可能存在的潮汐效应，在某些时间段网络数据流量可能很低，甚至完全没有需要处理的包，这样就会出现在高速端口下低负荷运行的场景，而完全轮询的方式会让处理器一直全速运行，明显浪费处理能力和不节能。<br>因此DPDK引入了收包中断与轮询的混合模式的支持，用户可以根据实际应用场景来选择完全轮询模式，或者混合中断轮询模式。<br>PDK的混合中断轮询机制是基于UIO或VFIO来实现其收包中断通知与处理流程的。如果是基于VFIO的实现，该中断机制是可以支持队列级别的，即一个接收队列对应一个中断号，这是因为VFIO支持多MSI-X 中断号。但如果是基于UIO的实现，该中断机制就只支持一个中断号，所有的队列共享一个中断号。</p><h4 id="网卡I-x2F-O性能优化"><a href="#网卡I-x2F-O性能优化" class="headerlink" title="网卡I&#x2F;O性能优化"></a>网卡I&#x2F;O性能优化</h4><h5 id="Burst收发包的优点"><a href="#Burst收发包的优点" class="headerlink" title="Burst收发包的优点"></a>Burst收发包的优点</h5><p>Burst收发包是DPDK的优化模式，它把收发包复杂的处理过程进行分解，使之成为相对较小的处理阶段，把相邻的数据访问、相似的数据运算集中处理。</p><p>Burst可以理解为突发模式，是一次完成多个数据包的收发，由DPDK函数调用者来决定。</p><p>网卡的收发包描述符一般为16或32字节，而网卡对收包描述符的回写都会一次处理4个或者8个。处理器缓存的预取机制会每次存取相邻的多个缓存单位，Burst充分利用这种机制，明显提高收发包效率。</p><p>Burst收发包是DPDK普遍使用的软件接口，用户可以设定每次收发包函数调用所处理的包的个数，具体函数接口如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">rte_eth_rx_burst</span><span class="params">(<span class="type">uint8_t</span> port_id,<span class="type">uint16_t</span> queue_id,<span class="keyword">struct</span> rte_mbuf  **rx_pkts,<span class="type">const</span> <span class="type">uint16_t</span> nb_pkts)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">rte_eth_tx_burst</span><span class="params">(<span class="type">uint8_t</span> port_id,<span class="type">uint16_t</span> queue_id,<span class="keyword">struct</span> rte_mbuf  **tx_pkts,<span class="type">const</span> <span class="type">uint16_t</span> nb_pkts)</span>;</span><br></pre></td></tr></table></figure><h5 id="批处理和时延隐藏"><a href="#批处理和时延隐藏" class="headerlink" title="批处理和时延隐藏"></a>批处理和时延隐藏</h5><p><strong>时延</strong>：处理器核心执行单元完成一条指令所需要的时钟周期数<br><strong>吞吐</strong>：处理器指令发射端口再次允许接受相同指令所需等待的时钟周期数。<br>时延描述了前后两个关联操作的等待时间，吞吐则描述了指令的并发能力。</p><p>利用CPU指令乱序多发的能力，掩藏指令延迟的一个有效方法是批量处理无数据前后依赖关系的独立事务。对于重复事务执行，通常采用循环逐次操作。对于较复杂的事务，编译器很难大量地区乱序不同迭代序列下地指令。常用到的做法是在一个序列中铺开执行多个事务，以一个合理地步进迭代。</p><h4 id="队列长度及各种阈值地设置"><a href="#队列长度及各种阈值地设置" class="headerlink" title="队列长度及各种阈值地设置"></a>队列长度及各种阈值地设置</h4><h5 id="收包队列长度"><a href="#收包队列长度" class="headerlink" title="收包队列长度"></a>收包队列长度</h5><p>收包队列的长度就是每个收包队列分配的收包描述符的个数，每个收包描述符都会分配有对应的Mbuf缓存块。<br>网卡硬件本身限定了可以使用的最大的队列长度。DPDK的默认的收包队列长度是128，是一个适应大多数场景的经验值。但是在某些更高速率的网卡收包或者在某些场景下丢包比较容易地时候，需考虑使用更长地收包队列如512或1024。</p><h5 id="发包队列长度"><a href="#发包队列长度" class="headerlink" title="发包队列长度"></a>发包队列长度</h5><p>发包队列的长度就是每个发包队列分配的发包描述符的个数，每个发包描述符都会分配有对应的Mbuf缓存块。<br>DPDK实力中常用地发包队列长度是512。</p><h5 id="收包队列可释放描述符数量阈值（rx-free-thresh）"><a href="#收包队列可释放描述符数量阈值（rx-free-thresh）" class="headerlink" title="收包队列可释放描述符数量阈值（rx_free_thresh）"></a>收包队列可释放描述符数量阈值（rx_free_thresh）</h5><p>在DPDK驱动女程序收包过程中，每一次收包函数的调用都可能成功读取0、1或者多个包。每读出一个包，与之对应的收包描述符就可以释放。DPDK驱动程序并没有每次收包都更新收包队列尾部索引寄存器，而是在可释放的收包描述符数量达到一个阈值(<code>rx_free_thresh</code>)的时候才真正更新收包队列尾部索引寄存器。这个值一般是32。</p><h5 id="发包队列发送结果报告阈值（tx-rs-thresh）"><a href="#发包队列发送结果报告阈值（tx-rs-thresh）" class="headerlink" title="发包队列发送结果报告阈值（tx_rs_thresh）"></a>发包队列发送结果报告阈值（tx_rs_thresh）</h5><p>任何发包处理完成后，需要有网卡硬件通过一定机制通知软件发包动作已经完成，对应的发包描述符就可以再次使用，对应的Mbuf可以释放或者做其他用途。一般都是通过回写发包描述符特定的字段完成通知，但是每个包发完都回写效率很低，因此<code>tx_rs_thresh</code>出现辽，只有在有回写标记的发包描述符才会回写，而这个标记会每个这个阈值才会设置。<br>阈值太小，回写频繁，性能低；阈值太大占用发包描述符时间长，可能会造成丢包。</p><h5 id="发包描述符释放阈值（tx-free-thresh）"><a href="#发包描述符释放阈值（tx-free-thresh）" class="headerlink" title="发包描述符释放阈值（tx_free_thresh）"></a>发包描述符释放阈值（tx_free_thresh）</h5><p>当网卡硬件读取完发包描述符，并且DMA完成整个包的内容的传送后，硬件会根据发送结果回写标记来通知软件发包完成，可以释放。只有放可以用来重新配置的发包描述符数量少于阈值的时候才会启动描述符和Mbuf的释放动作。DPDK驱动程序中默认是32.</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E7%BD%91%E5%8D%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">网卡性能优化</category>
      
      
      <comments>http://singlewang.top/2022/05/17/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch7/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
