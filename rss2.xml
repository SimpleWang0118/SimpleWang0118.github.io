<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Single Wang&#39;s Blog</title>
    <link>http://singlewang.top/</link>
    
    <atom:link href="http://singlewang.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>这一次，你彻彻底底的抛弃了我，但我不恨你，反而谢谢你，让我明白自己在你心中的位置，从此相逢是路人。</description>
    <pubDate>Wed, 28 Sep 2022 13:20:32 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>IP协议</title>
      <link>http://singlewang.top/2022/09/28/mobile-communication/IP%E7%9B%B8%E5%85%B3/</link>
      <guid>http://singlewang.top/2022/09/28/mobile-communication/IP%E7%9B%B8%E5%85%B3/</guid>
      <pubDate>Wed, 28 Sep 2022 12:16:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;TCP&amp;#x2F;IP的心脏是网络层，这一层主要由IP和ICMP两个协议组成。&lt;/p&gt;
&lt;h2 id=&quot;IP协议-网际协议&quot;&gt;&lt;a href=&quot;#IP协议-网际协议&quot; class=&quot;headerlink&quot; title=&quot;IP协议-网际协议&quot;&gt;&lt;/a&gt;IP协议-网际协议&lt;/h</description>
        
      
      
      
      <content:encoded><![CDATA[<p>TCP&#x2F;IP的心脏是网络层，这一层主要由IP和ICMP两个协议组成。</p><h2 id="IP协议-网际协议"><a href="#IP协议-网际协议" class="headerlink" title="IP协议-网际协议"></a>IP协议-网际协议</h2><h3 id="IP相当于OSI的第三层"><a href="#IP相当于OSI的第三层" class="headerlink" title="IP相当于OSI的第三层"></a>IP相当于OSI的第三层</h3><p>网络层的主要作用是实现<strong>“终端节点之间的通信”</strong>，也叫做<em>点对点通信</em>，网络层的下一层数据链路层的作用在互连同一种数据链路的节点之间进行包传递。</p><h3 id="网络层与数据链路层的关系"><a href="#网络层与数据链路层的关系" class="headerlink" title="网络层与数据链路层的关系"></a>网络层与数据链路层的关系</h3><p>数据链路层提供两个直连设备的通信，而IP则负责在没有直连的两个网络之间进行通信。</p><h2 id="IP基础知识"><a href="#IP基础知识" class="headerlink" title="IP基础知识"></a>IP基础知识</h2><p>IP大致分为三大作用模块，分别是IP寻址、路由以及IP分包与组包。</p><h3 id="IP地址属于网络层地址"><a href="#IP地址属于网络层地址" class="headerlink" title="IP地址属于网络层地址"></a>IP地址属于网络层地址</h3><p>在TCP&#x2F;IP通信中所有主机或路由器必须设定自己的IP地址。在网桥或集线器等物理层或数据链路层转发设备中，不需要设置IP地址。</p><h3 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h3><p>路由控制是指将分组数据发送到最终目的地址的功能。<br>一跳是指利用数据链路层以下分层的功能传输数据帧的一个区间。</p><p>为了将数据包发给目标主机，所有主机都维护着一张路由控制表，该表记录IP数据在下一步应该发给哪个路由器。</p><h3 id="IP属于面向无连接型"><a href="#IP属于面向无连接型" class="headerlink" title="IP属于面向无连接型"></a>IP属于面向无连接型</h3><p>IP面向无连接，即在发包之前不需要建立与对端目标地址之间的连接。原因是：</p><ol><li>简化</li><li>提速</li></ol><p>IP提供尽力服务，上一层的TCP采用面向有连接型</p><h2 id="IP地址的基础知识"><a href="#IP地址的基础知识" class="headerlink" title="IP地址的基础知识"></a>IP地址的基础知识</h2><p>IP地址由网络号和主机号两部分组成。在相同的网络号下不能有相同的主机号，在整个互连的网络中，IP地址具有唯一性。</p><p>IP地址分为A、B、C、D四类:</p><ol><li>A类地址首位以0开头，网络号为1~8位，一个网段内可容纳16777214个主机地址</li><li>B类地址前两位以10开始，网络号位1~16位，一个网段内可容纳65534个主机。</li><li>C类地址以110开始，网络号位1~24位，一个网段内可容纳254个主机地址</li><li>D类地址以1110开始，网络号位1~32位，没有主机号，常被用于多播。</li></ol><p><strong>广播地址</strong><br>广播地址即IP主机地址部分全部为1。<br>分为本地广播和直接广播。<br>路由器不转发广播的包。</p><p><strong>IP多播</strong><br>多播用于将包发送给特定组内的所有主机。同时发送能够提高效率。<br>多播使用D类地址，对于多播，所有的主机必须属于224.0.0.1的组，所有的路由器必须属于224.0.0.2的组。</p><p><strong>路由控制</strong><br>路由控制表中记录着网络地址与下一步应该发送至路由器的地址</p><p>默认路由：0.0.0.0&#x2F;0<br>主机路由：IP地址&#x2F;32，意味整个IP地址所有位都将参与路由。多被用于不希望通过网络地址路由的情况<br>环回地址：127.0.0.1.与该地址具有相同意义的是一个叫做localhost的主机名。使用这个IP或主机名时，数据包不会流向网络。</p><h2 id="IP分割处理与再构成处理"><a href="#IP分割处理与再构成处理" class="headerlink" title="IP分割处理与再构成处理"></a>IP分割处理与再构成处理</h2><p>任何一台主机都有必要对IP分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发出去才会处理。<br>报文重组只能由目标机进行。路由器只做分片不进行重组</p><p><strong>路径MTU发现</strong><br>路径MTU是指从发送端主机到接收端主机之间不需要分片时最大MTU的大小。而路径MTU发现从主机按照路径MTU的大小将数据报分片后进行发送，可以避免在中途的路由器进行分片。</p><h2 id="IPV4首部"><a href="#IPV4首部" class="headerlink" title="IPV4首部"></a>IPV4首部</h2><p>IP头部长度为20字节，其中包括：</p><ol><li><strong>首部长度</strong>,由4比特构成，单位为4字节。对于没有可选项的IP包，首部长度设置为”5”，当没有可选项时IP首部为20字节</li><li><strong>区分服务TOS</strong>,由8比特构成，表明服务指令</li><li><strong>总长度</strong>，表示IP首部与数据部分合起来的总字节数，长16比特。IP包的最大长度为65535</li><li><strong>标识ID</strong>，由16比特构成，用于分片重组。同一个分片的标识相同，每发送一个IP包，它的值也逐渐递增。</li><li><strong>标志Flags</strong>，由3比特构成，表示包被分片的相关信息。</li><li><strong>片偏移</strong>,由13比特构成，用来标识被分片的每一个分段相对于原始数据的位置。</li><li><strong>生存时间</strong>，由8比特构成，指可以中转多少个路由器，每经过一个路由器，TTL减少1，直到变成0丢弃该包。</li><li><strong>协议</strong>，由8比特构成，标识IP首部的下一个首部属于哪个协议。</li><li><strong>首部校验和</strong>，由16比特构成，只校验数据包的首部，不校验数据部分，主要用来保护IP数据报不被破坏。</li><li><strong>源地址</strong></li><li><strong>目的地址</strong></li><li><strong>可选项</strong></li><li><strong>填充</strong>，在有可选项的情况下，首部长度可能不是32比特的整数倍，通过此字段填充0.</li><li><strong>数据</strong>，存入数据。</li></ol>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/mobile-communication/">移动通信</category>
      
      
      <category domain="http://singlewang.top/tags/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/">无线通信</category>
      
      <category domain="http://singlewang.top/tags/IP/">IP</category>
      
      
      <comments>http://singlewang.top/2022/09/28/mobile-communication/IP%E7%9B%B8%E5%85%B3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>套接字编程简介</title>
      <link>http://singlewang.top/2022/09/28/UNIX-netcoding/%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</link>
      <guid>http://singlewang.top/2022/09/28/UNIX-netcoding/%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</guid>
      <pubDate>Wed, 28 Sep 2022 11:47:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;socket函数&quot;&gt;&lt;a href=&quot;#socket函数&quot; class=&quot;headerlink&quot; title=&quot;socket函数&quot;&gt;&lt;/a&gt;socket函数&lt;/h3&gt;&lt;p&gt;为了执行网络I&amp;#x2F;O，一个进程必须做的第一件事情就是调用socket函数，指定期望的</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h3><p>为了执行网络I&#x2F;O，一个进程必须做的第一件事情就是调用socket函数，指定期望的通信协议类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> family,<span class="type">int</span> type,<span class="type">int</span> protocol)</span>;<span class="comment">//成功返回非负的描述符，出错则为-1</span></span><br></pre></td></tr></table></figure><p>family参数为协议族，type为套接字类型，protocol为某个协议类型常值。</p><p><em>family常值有：</em><br>AF_INET       IPV4协议<br>AF_INET6      IPV6协议<br>AF_LOCAL      UNIX域协议<br>AF_ROUTE      路由套接字<br>AF_KEY        密钥套接字</p><p><em>type常值有：</em><br>SOCK_STREAM        字节流套接字<br>SOCK_DGRAM         数据报套接字<br>SOCK_SEQPACKET     有序分组套接字<br>SOCK_RAW           原始套接字</p><p><em>protocol常值有：</em><br>IPPROTO_CP         TCP传输协议<br>IPPROTO_UDP        UDP传输协议<br>IPPROTO_SCTP       SCTP传输协议</p><p>socket函数成功时返回一个小的非负整数值，称为<em>套接字描述符</em>，简称<em>sockfd</em>。</p><p><strong>AF_XXX和PF_XXX</strong></p><blockquote><p>AF_前缀表示地址族，PF前缀表示协议族。</p></blockquote><h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><p>TCP客户用connect函数来建立与TCP服务器的连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">const</span> <span class="keyword">struct</span> sockaddr* servaddr,<span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>客户在调用connect函数前不必非要调用bind函数，如果需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。</p><p>调用connect函数会激发TCP的<strong>三次握手</strong>,出错返回有以下几种情况：</p><ol><li>若客户没有收到SYN分节的响应，则返回ETMIEOUT.</li><li>若对客户的SYN的响应时RST,则表明该服务器主机在我们指定的端口上没有进程在等待与之连接。返回ECONNREFUSED。<blockquote><p>产生RST的条件是：</p><ul><li>目的地为某端口的SYN到达，然而该端口上没有正在监听的服务器。</li><li>TCP想取消一个已有连接。</li><li>TCP收到一个根本不存在的连接上的分节</li></ul></blockquote></li><li>客户发出的SYN在某个路由器上引发了“目的地不可达”ICMP错误，则认为是一种软错误。返回EHOSTUNREACH或ENETUNREACH.</li></ol><h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><p>bind函数把一个本地地址赋予一个套接字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">const</span> <span class="keyword">struct</span> sockaddr *myaddr,<span class="type">socklen_t</span> addrlen)</span>;<span class="comment">//成功返回0，出错返回-1；</span></span><br></pre></td></tr></table></figure><p>第二个参数指向特定于协议的地址结构的指针，第三个参数是该地址结构的长度。对于TCP,bind函数可以指定一个端口号，或指定一个IP地址，也可以二者都指定或都不指定。</p><p>假如不指定端口时，内核会给它一个临时端口。为了得到这个临时端口值，必须调用函数<code>getsockname</code>返回协议地址。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/UNIX-netcoding/">UNIX网络编程</category>
      
      
      <category domain="http://singlewang.top/tags/UNIX/">UNIX</category>
      
      <category domain="http://singlewang.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</category>
      
      
      <comments>http://singlewang.top/2022/09/28/UNIX-netcoding/%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>套接字编程</title>
      <link>http://singlewang.top/2022/09/26/UINX-envcoding/UINX-%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/</link>
      <guid>http://singlewang.top/2022/09/26/UINX-envcoding/UINX-%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/</guid>
      <pubDate>Mon, 26 Sep 2022 13:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;文件和目录&quot;&gt;&lt;a href=&quot;#文件和目录&quot; class=&quot;headerlink&quot; title=&quot;文件和目录&quot;&gt;&lt;/a&gt;文件和目录&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;文件系统&lt;br&gt;UINX所有东西的起点称为&lt;code&gt;root&lt;/code&gt;的目录，这个目录的名称是一个</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><ol><li>文件系统<br>UINX所有东西的起点称为<code>root</code>的目录，这个目录的名称是一个<code>/</code>字符。</li><li>文件名<br>目录中的各个名字称为文件名，只有<code>/</code>和空字符不能出现在文件名中。<br><code>.</code>指向当前目录，<code>..</code>指向父目录。</li><li>路径名<br>以斜线开头的路径称为<strong>绝对路径名</strong>，否则称为<strong>相对路径名</strong>。相对路径名指向相对于当前目录的文件。</li></ol><h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><ol><li>文件描述符</li></ol><p><strong>文件描述符</strong>通常是一个小的非负整数，内核用以标识一个特定进程正在访问的文件。当内核打开一个现有文件或创建一个新文件时，都会返回一个文件描述符<br>2. 不带缓冲的I&#x2F;O<br>函数<code>open、read、write、lseek、close</code>提供了不带缓冲的I&#x2F;O.</p><h3 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h3><ol><li>程序<br>程序指存储在某个目录中的可执行文件。</li><li>进程和进程ID<br>程序的执行实例被称为<strong>进程</strong>，UNIX确保每个进程都有一个唯一的数字标识符，称为<strong>进程ID</strong>。进程ID是一个非负整数。</li><li>进程控制<br>三个用于进程控制的主要函数：<code>fork、exec、waitpid</code>。<br>fork创建一个新进程。新进程时调用进程的一个副本，称调用进程为父进程，新创建的进程为子进程。fork对父进程返回新的子进程的进程ID,对子进程则返回0。</li></ol><p>wait返回子进程的终止状态，其参数为要等待的进程。<br>4. 线程和线程ID<br>通常一个进程只有一个控制线程。一个进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性。线程ID只在它所属的进程内起作用。</p><h3 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h3><p>UNIX系统函数出错时，通常会返回一个负值。<br>C标准定义了两个函数，用于打印出错信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;</span><br></pre></td></tr></table></figure><p>strerror将errnum映射为一个出错消息字符串，返回此字符串的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span></span><br></pre></td></tr></table></figure><p>首先输出由msg指向的字符串，然后指对于errno的出错消息</p><h3 id="时间值"><a href="#时间值" class="headerlink" title="时间值"></a>时间值</h3><p><strong>进程时间</strong>用以度量进程使用的中央处理器资源。以时钟滴答计算。<br>用clock_t保存这种时间值。<br>当度量一个进程的执行时间时，UNIX为一个进程维护三个进程时间值：</p><ul><li>时钟时间</li><li>用户CPU时间</li><li>系统CPU时间</li></ul><p>时钟时间时进程运行的时间总量，其值与系统中同时运行的进程数有关。<br>用户CPU时间时钟执行用户指令所用的时间量。<br>系统CPU时间时为该进程执行内核程序所经历的时间。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%EF%BC%8C%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">UNIX环境编程，第一章基础知识</category>
      
      
      <category domain="http://singlewang.top/tags/UNIX/">UNIX</category>
      
      <category domain="http://singlewang.top/tags/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">高级编程</category>
      
      
      <comments>http://singlewang.top/2022/09/26/UINX-envcoding/UINX-%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>套接字编程简介</title>
      <link>http://singlewang.top/2022/09/26/UNIX-netcoding/UNIX-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <guid>http://singlewang.top/2022/09/26/UNIX-netcoding/UNIX-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <pubDate>Mon, 26 Sep 2022 11:47:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;套接字编程&quot;&gt;&lt;a href=&quot;#套接字编程&quot; class=&quot;headerlink&quot; title=&quot;套接字编程&quot;&gt;&lt;/a&gt;套接字编程&lt;/h2&gt;&lt;h3 id=&quot;IPV4套接字地址结构&quot;&gt;&lt;a href=&quot;#IPV4套接字地址结构&quot; class=&quot;headerlink</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h2><h3 id="IPV4套接字地址结构"><a href="#IPV4套接字地址结构" class="headerlink" title="IPV4套接字地址结构"></a>IPV4套接字地址结构</h3><p>ipv4套接字地址结构通常也称为“网际套接字地址结构”，以<code>sockaddr_in</code>命名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> sin_len;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;  <span class="comment">//无符号短整数</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;  <span class="comment">//</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="通用套接字地址结构"><a href="#通用套接字地址结构" class="headerlink" title="通用套接字地址结构"></a>通用套接字地址结构</h3><p>当作为一个参数传递进任何套接字函数时，套接字地址总是以引用形式来传递。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> sa_len;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ul><li>从进程到内核传递套接字结构的函数有三个：<code>bind、connect、sendto</code>。</li><li>从内核到进程传递套接字地址结构的函数有4个：<code>accept、recvfrom、getsockname、getpeername</code>。</li></ul></blockquote><h3 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h3><p>内存中存储有两种方式:</p><ul><li>小端字节序，低序字节存储在低地址</li><li>大端字节序，高序字节存储在低地址<br>我们某个给定系统所用的字节称为<strong>主机字节序</strong>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*输出主机字节序*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;udp.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">short</span> s;</span><br><span class="line">        <span class="type">char</span>  c[<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125;un;</span><br><span class="line">    un.s=<span class="number">0x0102</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s:&quot;</span>,CPU_VENDOR_OS);<span class="comment">//CPU_VENDOR_OS标识了CPU类型、厂家、操作系统版本</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">sizeof</span>(<span class="type">short</span>==<span class="number">2</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;un.c[<span class="number">1</span>]==<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;big-endian\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">2</span>&amp;&amp;un.c[<span class="number">1</span>]==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;little-endian\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;unknown&quot;</span>\n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网络协议也必须指定一个网络字节序，使用如下四个函数进行两个字节序之间的转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> host16bitvalue)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> host32bitvalue)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> net16bitvalue)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> net32bitvalue)</span>;</span><br></pre></td></tr></table></figure><h3 id="字节操纵函数"><a href="#字节操纵函数" class="headerlink" title="字节操纵函数"></a>字节操纵函数</h3><p>字节操纵函数不对数据做解释，也不假设数据是以空字符串结束的C字符串。</p><p>Berkely函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bzero</span><span class="params">(<span class="type">void</span> *dest,<span class="type">size_t</span> nbytes)</span>;<span class="comment">//将目标字节串中指定数目的字节置为0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bcopy</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *src,<span class="type">void</span> *dest,<span class="type">size_t</span> nbyte)</span>;<span class="comment">//将指定数目的字节从源字节串移到目标字节串</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptrl,<span class="type">const</span> <span class="type">void</span> *ptr2,<span class="type">size_t</span> nbyte)</span>;<span class="comment">//比较两个任意的字节串，相同返回0</span></span><br></pre></td></tr></table></figure><p>ANSI C 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *dest,<span class="type">int</span> c,<span class="type">size_t</span> len)</span>;<span class="comment">//将目标字节串中指定数目的字节置为c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memcpy</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *dest,<span class="type">void</span> *src,<span class="type">size_t</span> nbyte)</span>;<span class="comment">//将指定数目的字节从源字节串移到目标字节串,与bcopy的源和目的相反。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptrl,<span class="type">const</span> <span class="type">void</span> *ptr2,<span class="type">size_t</span> nbyte)</span>;<span class="comment">//比较两个任意的字节串，相同返回0，否则返回一个非0值，若ptrl字节串大于ptr2，则大于0，反之小于0</span></span><br></pre></td></tr></table></figure><p><strong>inet_aton、inet_addr、inet_ntoa</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *strptr,<span class="keyword">struct</span> in_addr *addptr)</span>;<span class="comment">//将点分十进制串转换成32位的网络字节序二进制值，通过指针addrptr存储，陈工返回1。</span></span><br><span class="line"></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *strptr)</span>;<span class="comment">//进行相同的转换，返回值为32位的网络字节序二进制值。但是不能处理ipv4的广播地址。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_ntoa</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> inaddr inaddr)</span>;<span class="comment">//将一个32位的网络字节序二进制ipv4地址转换成相应的点分十进制。</span></span><br></pre></td></tr></table></figure><p><strong>inet_pton、inet_ntop</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> family,<span class="type">const</span> <span class="type">char</span> *strptr,<span class="type">void</span> *addrptr)</span>;<span class="comment">//转换由strptr指向的字符串，通过addrptr指针存放二进制结果。成功返回1，</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> family,<span class="type">const</span> <span class="type">void</span> *addrptr,<span class="type">char</span> *strptr,<span class="type">size_t</span> len)</span>;<span class="comment">//与inet_pton相反。</span></span><br></pre></td></tr></table></figure><p><strong>readn、write、readline</strong></p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/UNIX-netcoding/">UNIX网络编程</category>
      
      
      <category domain="http://singlewang.top/tags/UNIX/">UNIX</category>
      
      <category domain="http://singlewang.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</category>
      
      
      <comments>http://singlewang.top/2022/09/26/UNIX-netcoding/UNIX-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>终于等到你，还好我没放弃</title>
      <link>http://singlewang.top/2022/08/14/informal-essay/life/%E7%BB%88%E4%BA%8E%E7%AD%89%E5%88%B0%E4%BD%A0/</link>
      <guid>http://singlewang.top/2022/08/14/informal-essay/life/%E7%BB%88%E4%BA%8E%E7%AD%89%E5%88%B0%E4%BD%A0/</guid>
      <pubDate>Sun, 14 Aug 2022 15:30:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;时间把你和我变成我们&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;&lt;em&gt;&lt;strong&gt;因为有你&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;&lt;em&gt;&lt;strong&gt;所以步履不停&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;今天，我终于和我心心念念的那个女孩儿在一起了。我等了这</description>
        
      
      
      
      <content:encoded><![CDATA[<p><em><strong>时间把你和我变成我们</strong></em><br><em><strong>因为有你</strong></em><br><em><strong>所以步履不停</strong></em><br>今天，我终于和我心心念念的那个女孩儿在一起了。我等了这一刻太久太久，如果用一句歌词来形容的话，可能就是“终于等到你，还好我没放弃~”，她叫韩林秀，听名字就知道是一个知书达理的女孩，我和她的故事从初二开始，想听吗？那就搬上你的小板凳，听我娓娓道来。</p><p>10年前，有个初二的学生因为学习原因被父亲转了班级，并不是他学习不好，他是那个班的第一，只是因为那个班的学习氛围不好，他的爸爸为了让他有一个更好的成绩，有一个更好的前途，给他安排了转班。尽管有百般不舍，毕竟谁也不愿意突然转到一个陌生的班级，重新认识一些不认识的同学，属实难为这个学生了，但是碍于父亲的强势，不得已转了班级。那天，他走的很静，在班级里没有留下什么惊涛骇浪，只是第二天同学们才发现他的桌仓已经空了。可他却不知道，这次转班却会让他认识生命中胜似亲人重要的一个人。</p><p>转的班级并没有影响他的学习，还是像往常一样早早的来到新转的班级晨读，直到吃早饭的时候，”可以麻烦你交一下语文作业吗？”，他猛然抬头，映入眼帘的是一位清纯可爱的女生，眼睛很好看，笑起来也好看，那一刻，他发现自己已经沉沦在她的微笑中，沉迷于她灵动的眼睛。尽管就是这普普通通的一眼，就已经注定了和她的故事不可能普普通通。没错这位女生就是我的女朋友，这个转班的同学就是我。我和她的故事开始于庆城中学的八年级4班。这时起我就开始默默关注着她，她的一举一动，一颦一笑都会使我的心神荡漾。</p><p>从我们相识到现在已经有了差不多10年，韩林秀–一个刻在我骨子里的名字，从我见到她的那一刻起，我就觉得我注定要和她发生些什么。有人说，爱情是人的自由意志的沉沦，确实如此，有时候爱情就是这么不讲道理，但正因为如此，才使得那么多人向往，无数人幻想着能收获属于自己的那一份甜甜的爱情，我也不例外，但是在今天，一直以来出现在我梦中的她终于走进了现实。</p><p>&#x2F;<em><strong>过去</strong></em>&#x2F;<br>有些遗憾的是，在高中时期，那个情窦初开的时期，我们没能在一个班级，我在1班，她在4班，虽然隔了不远，但是却让我们有了些许距离，我不知道她的日常，她呢，也不了解我的生活，只是偶尔的碰面会让我们寒暄几句。我隐藏着自己对她的爱慕，但也仅仅只是对她隐藏了，毕竟我周围的同学也已经知道我喜欢她，常常调侃到“王力恒的心，路人皆知。”我也没有去争些什么，毕竟这是事实，我就是喜欢她，我想得到她的关注，于是我当了班长，想着能够凭借这个机会和她多有些接触。有时候和她短短的几句话就能让我开心一整天。运动会的开幕式有她的节目，我还特意拿着相机去拍她，我不在意别人的目光，我在意的只有她。还有运动会期间，她在写给运动员的加油词，我也想拍她，但是又怕被发现，现在想想真是为我的怂而着急。但还是让我同学帮忙拍了几张，现在还在我的电脑中。可尽管如此我们能够相处的时间还是太短，毕竟我们不在一个班级。时间就如白驹过隙般从笔尖溜走，写下的是充满期冀的未来。高三的时间更是飞快，整天就是刷题，考试，讲试卷。不过她也找过我讲题，那我当然得好好表现一下了，毕竟谁不想在自己喜欢的女生面前出风头呢。可我又怕自己讲错，那可就尴尬了。不过所幸她问的题也不是很难，我讲的很慢，一是怕她听不明白，二还是想多珍惜和她相处的时间，因为我知道，高考过后我们见面可能真的就越来越少了。高考结束后，我们去了不同的地方，我在武汉，她在河南。就这样在我们面临的第一个重要的人生关卡，我们分道扬镳了。</p><p>当她告诉我愿意和我一起尝试一下，面对一个美好的未来的时候，我竟然有些恍惚，我掐了掐自己，我好怕这是一个梦，我怕像之前无数次那样，醒来之后，梦里的一切都化为乌有。还好，这次醒来，她真的在我身边。真的一种喜极而泣的感觉涌上心头。回想起我第一次和她正面告白的时候，应该是在大二的寒假，放假回来，她在学车，那天我鼓足勇气，和她一起走了走，我们聊了很多，可是当我要说出口的时候，她逃避了，真像一只受了惊吓的小鹿，逃进了冰天雪地的树林，哦，对了，那天刚好下了一点小雪。我在雪中迟迟不肯离去，但是我还是想对她说出我的心里话，我说了很长的一段话，虽然只有十几分钟，但是这十几分钟我却删了又说，说了又删，我忐忑，想表达我全部热烈而又真诚的爱意，却又害怕语言不得体，当颤抖的手按下发送键时，我心中充满了喜悦，那时想至少这辈子应该没有遗憾了吧。但是不出意外的话要出意外了，第一次正面的告白以失败告终。但我并不想着放弃，之后的一段时间我们断断续续的联系着，后来看见她有了男朋友，我的热情仿佛被泼了一盆冷水，本来刚刚燃起的火苗瞬间被熄灭。我知道，此时我不该再区打扰她了，于是慢慢的，我和她淡了联系。直到某天夜里，我梦见了她，我梦见她来我的学校找我，醒来之后，直觉告诉我她应该有什么事，果不其然，在后来不久我们又有了联系，与她的聊天中我知道，她分手，当得知这个消息的时候，我不知道自己该是开心还是难过，于我自己而言，我知道我又有了机会，可是与她而言，应该会很伤心吧。慢慢的我们又开始聊天，一起玩游戏，一切似乎又在朝着美好的方向发展。那时由于疫情的原因我们都在家里复习考研，所以我又鼓起勇气约她出来，想和她再一次告白，我没有了之前的胆怯，直接告诉她我的心意。但是她的回答依旧是那么斩钉截铁，说我们不可能。此时的我的心中仿佛有雨雪在冷冷的拍。我知道，我又失败了，想着又要好久才能缓过来吧。之后我们还是像往常一样聊天，但是总觉得哪里不对劲。可能是我还心存侥幸，觉得我和她还是朋友，还有机会。然而就是这份侥幸，让我又有了一份不可名状的勇气，迎来了我的第三次告白。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/informal-essay/">随笔</category>
      
      <category domain="http://singlewang.top/categories/informal-essay/life/">生活感悟</category>
      
      
      <category domain="http://singlewang.top/tags/%E5%BF%83%E5%BE%97/">心得</category>
      
      <category domain="http://singlewang.top/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/">生活感悟</category>
      
      
      <comments>http://singlewang.top/2022/08/14/informal-essay/life/%E7%BB%88%E4%BA%8E%E7%AD%89%E5%88%B0%E4%BD%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>嵌入式系统开发-ch1</title>
      <link>http://singlewang.top/2022/06/25/embedded/%E5%B5%8C%E5%85%A5%E5%BC%8F-ch1/</link>
      <guid>http://singlewang.top/2022/06/25/embedded/%E5%B5%8C%E5%85%A5%E5%BC%8F-ch1/</guid>
      <pubDate>Sat, 25 Jun 2022 12:20:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;嵌入式系统及其应用&quot;&gt;&lt;a href=&quot;#嵌入式系统及其应用&quot; class=&quot;headerlink&quot; title=&quot;嵌入式系统及其应用&quot;&gt;&lt;/a&gt;嵌入式系统及其应用&lt;/h2&gt;&lt;h3 id=&quot;嵌入式系统&quot;&gt;&lt;a href=&quot;#嵌入式系统&quot; class=&quot;header</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="嵌入式系统及其应用"><a href="#嵌入式系统及其应用" class="headerlink" title="嵌入式系统及其应用"></a>嵌入式系统及其应用</h2><h3 id="嵌入式系统"><a href="#嵌入式系统" class="headerlink" title="嵌入式系统"></a>嵌入式系统</h3><p><em>什么是嵌入式系统</em><br>嵌入式系统是嵌入式计算机系统的简称，是一种嵌入在设备（或系统）内部，为特定应用而设计开发的专用计算机系统。</p><p>&#x3D;&#x3D;特点&#x3D;&#x3D;</p><ol><li>专用性</li><li>隐蔽性</li><li>资源受限</li><li>高可靠性</li><li>实时性</li><li>软件固化</li></ol><p>广义：凡是带有微处理器的专用软硬件系统都可称为嵌入式系统<br>狭义：使用嵌入式微处理器构成的具有自己的操作系统和特定功能、用于特定场合的独立系统</p><h3 id="嵌入式系统的组成与分类"><a href="#嵌入式系统的组成与分类" class="headerlink" title="嵌入式系统的组成与分类"></a>嵌入式系统的组成与分类</h3><p><em>嵌入式系统的逻辑组成</em><br>嵌入式系统由硬件和软件两部分组成。<br>&#x3D;&#x3D;处理器&#x3D;&#x3D;<br>硬件的主体是中央处理器（Central Processing Uint,CPU）,主要负责运行系统软件和应用软件。<br>CPU的字长由4位、8位、16位、32位、64位之分，目前嵌入式系统中使用最多的是8位和16位的CPU，通用计算机的CPU则以64位为主。<br>嵌入式系统的性能很大取决于CPU,影响程序执行速度的因素包括：</p><ol><li>主频（CPU时钟频率），指CPU中门电路的工作频率，主频越高，执行指令的时间越短</li><li>指令系统</li><li>高速缓冲存储器的容量与结构</li><li>逻辑结构</li></ol><p>&#x3D;&#x3D;存储器&#x3D;&#x3D;<br>存储器：</p><ul><li>易失性存储器<ul><li>SRAM，电路复杂，集成度低，成本高，工作速度快</li><li>DRAM，电路简单，集成度高，成本低</li></ul></li><li>非易失性存储器<ul><li>EEPROM</li><li>Flash ROM</li><li>磁盘等</li></ul></li></ul><p>&#x3D;&#x3D;I&#x2F;O设备与I&#x2F;O接口&#x3D;&#x3D;<br>嵌入式常用的I&#x2F;O接口有：</p><ul><li>通用串行总线式接口：USB2.0,USB3.0,IEEE 1394,以太网接口</li><li>异步串行接口：RS-232-C,RS-485</li><li>视频信号接口：VGA,DVI,HDMI</li><li>工业总线接口：CAN,1553B,LIN接口</li><li>无线接口:蓝牙，wifi接口，zigbee接口</li></ul><p>&#x3D;&#x3D;总线&#x3D;&#x3D;<br>数据总线简称总线，是用来在嵌入式系统各组件间进行数据传输，又传输线和控制电路组成</p><p>&#x3D;&#x3D;软件&#x3D;&#x3D;<br>低端嵌入式系统软件很简单，只需配置一个监控程序，若干驱动程序和事件处理程序即可。<br>高端嵌入式系统比较复杂。通常由板级支持包、设备驱动程序、实时操作系统（核心）、中间件及嵌入式应用软件组成，以安卓软件为例，主要由4层组成。最底层是各种驱动程序和Linux内核。第二层是系统库和Android的运行环境。第三层是应用软件框架。第四层是应用程序</p><p><em>嵌入式处理芯片</em><br>嵌入式系统中的CPU一般具有4个特点</p><ol><li>支持实时处理</li><li>低功耗</li><li>结构可扩展</li><li>集成了测试电路</li></ol><p>目前嵌入式处理芯片有一下四种产品类型：</p><ol><li>微处理器</li><li>数字信号处理器</li><li>微控制器（单片机）</li><li>片上系统</li></ol><blockquote><p>第一个公认的现代嵌入式系统是20世纪60年代初美国麻省理工学院开发的阿波罗导航计算机。</p></blockquote><h2 id="嵌入式系统和数字媒体"><a href="#嵌入式系统和数字媒体" class="headerlink" title="嵌入式系统和数字媒体"></a>嵌入式系统和数字媒体</h2><h3 id="数字（电子）文本"><a href="#数字（电子）文本" class="headerlink" title="数字（电子）文本"></a>数字（电子）文本</h3><p>文字信息在计算机中统称为文本，文本是基于特定字符集的一个字符流，每个字符均使用二进制编码表示。<br><em>字符集及其编码</em></p><ol><li>西文字符的编码<br>目前使用最广泛的西文字符集及其编码是ASCII字符集和ASCII码，即美国标准信息交换码。共有128个字符，包括96个可打印字符和32个控制字符</li><li>汉字的编码<br>我国目前广泛使用的汉字编码国家标准有GB2312和GB18030</li><li>USC和Unicode编码</li></ol><p><em>文本的类型</em><br>根据是否具有排版格式可分为：</p><ul><li>简单文本</li><li>丰富格式文本<br>根据文本内容的组织方式来分：</li><li>线性文本</li><li>超文本</li></ul><p><strong>简单文本</strong>：由变大文本内容的一连串字符的编码组成，几乎不包含任何其他的格式信息和结构信息。通常称为纯文本，其文件后缀名是.txt，呈现为线性结构。<br><strong>丰富格式文本</strong>：即常说的富文本，由排版格式等<br><strong>超文本</strong>：采用网状结构来组织信息，文本中各个部分按照其内容逻辑进行连接，例如www网页。</p><h3 id="数字图像"><a href="#数字图像" class="headerlink" title="数字图像"></a>数字图像</h3><p><em>数字图像的获取和主要参数</em><br>图像获取过程的核心是模拟信号的数字化，处理过程大致分为4步：</p><ol><li>扫描</li><li>分色</li><li>取样</li><li>量化<br>图像的基本单位称为像素，彩色图像的像素通常由R、G、B三个分量组成。<br>数字图像在计算机中的表示方法是：</li></ol><ul><li>灰度图像采用一个矩阵表示</li><li>彩色图像用一组矩阵表示，每个矩阵称为一个位平面</li><li>矩阵的行数成文垂直分辨率</li><li>矩阵的列数称为水平分辨率</li></ul><p>数字图像的主要参数如下：</p><ul><li>图像大小，也叫做图像分辨率</li><li>位平面数目，像素分量的数目</li><li>像素深度，指像素用多少个二进制来表示</li><li>颜色模型，例如RGB,CMYK（打印机使用）</li></ul><p><em>数字图像常用文件格式及其应用</em><br>一幅图像的数据量按照如下公式计算（字节位单位）：<br>    <strong>图像数据量&#x3D;图像水平分辨率x图像垂直分率x像素深度&#x2F;8</strong></p><p>数据压缩分为两种类型，一种是无损压缩，另一种是有损压缩。</p><p><strong>无损压缩</strong>：指使用压缩后的数据还原图像时，与原始图像完全一样。例如行程长度编码（RLE），哈夫曼编码等。<br><strong>有损压缩</strong>：指还原的图像与原始图像有一点误差，按时不影响使用，如变换编码，矢量编码。</p><h3 id="数字音频与数字视频"><a href="#数字音频与数字视频" class="headerlink" title="数字音频与数字视频"></a>数字音频与数字视频</h3><p><em>音频&#x2F;视频的数字化</em><br>音频时20hz-20khz的的模拟信号。<br>声音信号数字化的过程如下：</p><ol><li>取样，把时间上连续的声音信号离散为不连续的一系列的样本</li><li>量化</li><li>编码</li></ol><p>视频信号以帧为单位进行，每帧彩色画面有Y（亮度）、UV(色度)三个分量。</p><p><em>数字音频常用文件格式及其应用</em><br>数字音频的主要参数：</p><ul><li>取样频率</li><li>量化位数</li><li>声道数目</li><li>压缩编码方法</li><li>比特率，也称为码率，每秒钟的数据量<br>数字音频未压缩前，码率的计算公式为：<br>  波形声音的码率&#x3D;取样频率x量化位数x声道数(b&#x2F;s)</li></ul><h2 id="数字通信与计算机网络"><a href="#数字通信与计算机网络" class="headerlink" title="数字通信与计算机网络"></a>数字通信与计算机网络</h2><h3 id="数字通信"><a href="#数字通信" class="headerlink" title="数字通信"></a>数字通信</h3><p><em>模拟通信与数字通信</em><br>通信需基本任务时传递信息，至少需要三要素组成：<br>信息的发送者（信源），信息的接收者（信宿），信息的传输通道（信道）。</p><p>通信中信息必须以电或光的形式进行传播，信号的形式有两种：<strong>模拟信号</strong>和<strong>数字信号</strong>。<br>模拟信号通过连续的物理量来表示信息。<br>数字信号电平高低或电流大小只是有限个状态。<br>第一代个人移动通信采用的是模拟传输技术。我国使用的GSM和CDMA都是第二代移动通信系统，简称2G。我国3G通信目前有三种技术标准，中国移动–TD-SCDMA,中国电信–CDMA2000,中国联通–WCDMA。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/embeded/">embeded</category>
      
      
      <category domain="http://singlewang.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</category>
      
      <category domain="http://singlewang.top/tags/%E8%80%83%E8%AF%95/">考试</category>
      
      
      <comments>http://singlewang.top/2022/06/25/embedded/%E5%B5%8C%E5%85%A5%E5%BC%8F-ch1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>c++primer之语句</title>
      <link>http://singlewang.top/2022/06/25/cpp/cpp_primer_ch5/</link>
      <guid>http://singlewang.top/2022/06/25/cpp/cpp_primer_ch5/</guid>
      <pubDate>Sat, 25 Jun 2022 11:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h2&gt;&lt;h3 id=&quot;简单语句&quot;&gt;&lt;a href=&quot;#简单语句&quot; class=&quot;headerlink&quot; title=&quot;简单语句&quot;&gt;&lt;/a&gt;简单语句&lt;/h</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h3><p>正常人都知道一些简单语句，不再赘述。<br><em>空语句</em><br>空语句只有一个单独的分号<br>eg：<code>;</code><br>常见情况是，当循环的全部工作在条件部分可以完成时，通常使用空语句。</p><p><em>别漏写分号，也别多写分号</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(iter!=a.<span class="built_in">end</span>());<span class="comment">//循环体是空语句</span></span><br><span class="line">    ++iter; <span class="comment">//递增运算不属于循环</span></span><br></pre></td></tr></table></figure><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition1)</span><br><span class="line">    statement; <span class="comment">//没有else分支</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(condition2)</span><br><span class="line">    statement1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statement2；</span><br></pre></td></tr></table></figure><p>除此之外，还有嵌套if-else，但是很简单不再赘述。</p><p><strong>悬垂else</strong>：指当if分支多余else分支时，if和else分匹配问题。</p><p>c++规定else与离其最近的尚未匹配的if匹配。<br>通常用花括号控制执行的路径。</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> acnt=<span class="number">0</span>,ecnt=<span class="number">0</span>,icnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">switch</span> (ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        acnt++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        ecnt++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        icnt++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>case的标签必须是整型常量表达式。<br>有时候，我们需要多个值共享一组操作时可以省略掉break语句，只在最后一个符合条件的语句中加break。</p></blockquote><p>一般不要省略break语句。</p><h3 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h3><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure><p>只要condition的求值结果为真就会一直执行statement。<br>当不确定要迭代多少次时，使用while比较合适。</p><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p><em>传统for语句</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(init-statement;condition;express)</span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure><p>for语句头中定义的对象只在for循环体内可见。</p><p><em>范围for语句</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaratioin:expression)</span><br><span class="line">    statement</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;r:v)</span><br><span class="line">    r*=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>expression表示的必须是一个序列，比如数组、vector、string等类型的对象。<br>declaration定义一个变量，序列中的每个元素都能转换成该变量的类型。</p><h4 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h4><p>do while语句与while语句很相似区别是do while语句先执行循环体后检查条件，至少会执行一次循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">    statement</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(condition)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>do while语句最后用一个分号结束</p></blockquote><h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><h4 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h4><p>break语句负责中止离它最近的循环语句，并从这些语句之后的第一天语句开始继续执行。</p><h4 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h4><p>continue语句终止最近的循环中的当前迭代并立即开始下一次迭代。只能出现在for、while、do while循环的内部。<br>continue终止当前迭代，但是仍然执行循环。</p><h4 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> lable;</span><br><span class="line"></span><br><span class="line">lable: <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><blockquote><p>一般不要在程序中使用goto语句，会使得程序即难理解又难修改。</p></blockquote><h3 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h3><p>异常处理机制由异常检测和异常处理两部分协作完成。<br>异常处理包括：</p><ul><li>throw表达式：异常检测部分使用throw表达式来表示它遇到了无法处理的问题。</li><li>try语句块：以关键字try开始，以一个或者多个catch子语句结束。</li></ul><h4 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a!=b)</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;error&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果a不等于b，则抛出一个类型为runtime_error的异常。抛出异常将终止当前的函数，并把控制权交给能处理该异常的代码。</p><p>runtime_error是标准库异常类型的一种。</p><h4 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h4><p>通用形式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    program-statement</span><br><span class="line">&#125;   <span class="built_in">catch</span>(expression)&#123;</span><br><span class="line">    handler</span><br><span class="line">&#125;   <span class="built_in">catch</span>(expression2)&#123;</span><br><span class="line">    handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h4><table><thead><tr><th align="center">异常类型</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">exception</td><td align="center">最常见的问题</td></tr><tr><td align="center">runtime_error</td><td align="center">只有在允许时才能检测出的问题</td></tr><tr><td align="center">range_error</td><td align="center">生成结果超出范围</td></tr><tr><td align="center">logic_error</td><td align="center">程序逻辑错误</td></tr><tr><td align="center">invalid_argument</td><td align="center">无效参数</td></tr><tr><td align="center">length_error</td><td align="center">试图创建一个超出该类型最大长度的对象</td></tr><tr><td align="center">out_of_range</td><td align="center">使用一个超出范围的值</td></tr><tr><td align="center">domain_error</td><td align="center">参数对应的结果不存在</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/CPP/">CPP</category>
      
      
      <category domain="http://singlewang.top/tags/cpp/">cpp</category>
      
      
      <comments>http://singlewang.top/2022/06/25/cpp/cpp_primer_ch5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>c++primer之字符串、向量、数组</title>
      <link>http://singlewang.top/2022/06/24/cpp/cpp_primer_ch3/</link>
      <guid>http://singlewang.top/2022/06/24/cpp/cpp_primer_ch3/</guid>
      <pubDate>Fri, 24 Jun 2022 13:20:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;命名空间的using声明&quot;&gt;&lt;a href=&quot;#命名空间的using声明&quot; class=&quot;headerlink&quot; title=&quot;命名空间的using声明&quot;&gt;&lt;/a&gt;命名空间的using声明&lt;/h2&gt;&lt;p&gt;通过&lt;strong&gt;using声明&lt;/strong&gt;使用命名</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>通过<strong>using声明</strong>使用命名空间，无须专门的前缀也能使用所需的名字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::std;  <span class="comment">//使用std命名空间</span></span><br></pre></td></tr></table></figure><p><em>每个名字都需要独立的using声明</em><br><em>头文件不应包含using声明</em></p><h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>标准库类型string表示可变长的字符序列，使用时必须首先包含string头文件。</p><h3 id="定义和初始化string"><a href="#定义和初始化string" class="headerlink" title="定义和初始化string"></a>定义和初始化string</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">string s2=s1;</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;</span><br><span class="line">string s3=<span class="string">&quot;value&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(n,<span class="string">&#x27;c&#x27;</span>)</span></span>;<span class="comment">//把s4初始化为由n个字符c组成的串</span></span><br></pre></td></tr></table></figure><p><strong>拷贝初始化</strong>：使用&#x3D;初始化一个变量<br><strong>直接初始化</strong>：不使用等号初始化</p><h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p><em>读写string对象</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><em>读取位置数量的string对象</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s)</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>使用getline读取一整行</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin,line))</span><br><span class="line">        cout&lt;&lt;line&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>string::size_type类型</em><br>size_type类型是一个无符号类型的值，足够放下任何string对象的大小。</p><h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><p><em>使用基于范围的for语句</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;helloworld&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> <span class="params">(<span class="keyword">auto</span> c:str)</span></span></span><br><span class="line"><span class="function">    cout&lt;&lt;c&lt;&lt;endl</span>;</span><br></pre></td></tr></table></figure><p><em>使用for语句改变字符串中的字符</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;helloworld&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:str)</span><br><span class="line">    c=<span class="built_in">toupper</span>(c);</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><em>只处理一部分字符</em><br>有两种方式</p><ol><li>使用下标<blockquote><p>string对象的下标必须大于等于0小于s.size()</p></blockquote></li><li>使用迭代器</li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *parr[<span class="number">10</span>];<span class="comment">//含有10个整型指针的数组</span></span><br></pre></td></tr></table></figure><p>定义数组时必须指定数组的类型，不允许使用auto关键字由初始值的列表推断类型。</p><p><em>显示初始化数组</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="comment">//等价于a3[]=&#123;0,1,2,0,0&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em><strong>不允许拷贝和赋值</strong></em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[]=a;<span class="comment">//错误</span></span><br><span class="line">b=a;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h3 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h3><p>通常情况下，使用取地址符获取指向某个对象的指针，取地址符可以用于任何对象，包括数组的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p=&amp;a[<span class="number">0</span>];<span class="comment">//p指向a的第一个元素</span></span><br></pre></td></tr></table></figure><p><em>指针也是迭代器</em><br>可以通过++移动指针。</p><p><em>指针运算</em><br>给一个指针加或减去某个整数值，结果仍然是指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p=arr;</span><br><span class="line"><span class="type">int</span> *p2=p+<span class="number">4</span>;<span class="comment">//指向arr[4]</span></span><br></pre></td></tr></table></figure><p>如果两个指针指向同一个数组的元素，或者指向该数组的尾元素的下一个位置，就能利用关系运算符对其进行比较。如果分别指向不同的对象，则不能比较。</p><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>&#x3D;&#x3D;<em>严格来说，c++语言中没有多维数组，通常所说的多维数组其实是数组的数组</em>&#x3D;&#x3D;</p><p>通常使用两个维度来定义多维数组，一个维度表示数组本身大小，另外一个维度表示其元素大小。</p><p><em>多维数组的初始化</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;<span class="comment">//效果一样</span></span><br></pre></td></tr></table></figure><p><em>多维数组的下标引用</em><br>如果表达式含有的下标运算符和数组的维度一样多，该表达式的结果将是给定类型的元素。如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将式给定索引处的一个内层数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>][<span class="number">3</span>]=arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">int</span> (&amp;row)[<span class="number">4</span>]=a[<span class="number">1</span>];把row绑定到row的第二个<span class="number">4</span>元素数组上。</span><br></pre></td></tr></table></figure><p><em>指针和多维数组</em><br>多维数组实际上式数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">4</span>]=a;<span class="comment">//p指向含有四个整数的数组</span></span><br><span class="line">p=&amp;a[<span class="number">2</span>];<span class="comment">//p指向a的尾元素</span></span><br></pre></td></tr></table></figure><blockquote><p>上述声明中，圆括号必不可少：<br>int *p[4];&#x2F;&#x2F;整型指针的数组<br>int (*p)[4];&#x2F;&#x2F;指向含有4个整数的数组</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/CPP/">CPP</category>
      
      
      <category domain="http://singlewang.top/tags/cpp/">cpp</category>
      
      
      <comments>http://singlewang.top/2022/06/24/cpp/cpp_primer_ch3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>c++primer之变量和基本类型</title>
      <link>http://singlewang.top/2022/06/10/cpp/cpp_primer_ch2/</link>
      <guid>http://singlewang.top/2022/06/10/cpp/cpp_primer_ch2/</guid>
      <pubDate>Fri, 10 Jun 2022 13:20:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;变量和基本类型&quot;&gt;&lt;a href=&quot;#变量和基本类型&quot; class=&quot;headerlink&quot; title=&quot;变量和基本类型&quot;&gt;&lt;/a&gt;变量和基本类型&lt;/h2&gt;&lt;h3 id=&quot;基本内置类型&quot;&gt;&lt;a href=&quot;#基本内置类型&quot; class=&quot;headerlink&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h2><h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><p>基本内置类型包括：</p><ul><li>算术类型(arithmetic type)<ul><li>字符</li><li>整数型</li><li>布尔值</li><li>浮点</li></ul></li><li>空类型(void)<h4 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h4><table><thead><tr><th align="center">类型</th><th align="center">size</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">8位</td></tr><tr><td align="center">wchar_t</td><td align="center">16</td></tr><tr><td align="center">char16_t</td><td align="center">16</td></tr><tr><td align="center">char32_t</td><td align="center">32</td></tr><tr><td align="center">short</td><td align="center">16</td></tr><tr><td align="center">int</td><td align="center">16</td></tr><tr><td align="center">long</td><td align="center">32</td></tr><tr><td align="center">long long</td><td align="center">64</td></tr></tbody></table></li></ul><blockquote><p>c++规定一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大。long long是在c++11中新定义的</p></blockquote><p>浮点型可表示单精度、双精度和扩展精度值。通常float以1个字来表示，double以2个字来表示，long double以3或4个字表示。一般来说类型float和double分别有7个和16个有效位。</p><p><strong>带符号类型和无符号类型</strong><br>整型可以划分为带符号和无符号，在带符号类型前加<code>unsigned</code>即可得到无符号类型。<br>字符型被分成三种：char、signed char、unsigned char。<br>c++标准约定在表示范围内正值和负值量应该平衡。因此8bit的signed char理论上可以表示-127到127区间内的值，大多数现代计算机将实际的表示范围定为-128~127。</p><blockquote><p>选择类型经验准则：</p><ul><li>当明知数值不可能为负，选用无符号类型</li><li>使用int进行整数运算</li><li>在算数表达式中不要使用char或bool</li><li>执行浮点运算选用double</li></ul></blockquote><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。</p><blockquote><p><strong>避免无法预知和依赖于实现环境的行为</strong>：<br>无法预知的行为源于编译器无须检测的错误。即使代码编译通过了，运行时仍然可能产生错误。</p></blockquote><blockquote><p><strong>切勿混用带符号类型和无符号类型</strong></p></blockquote><h4 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h4><p>一个形如42的值被称为<strong>字面值常量</strong>，每个字面值常量对应一种数据类型。它的形式和值决定了它的数据类型</p><blockquote><p>eg: 20<br>20 (十进制)  024(八进制)  0x14(十六进制)</p></blockquote><p><strong>指定字面值的类型</strong><br>字符和字符串字面值</p><table><thead><tr><th align="center">前缀</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">u</td><td align="center">char16_t</td></tr><tr><td align="center">U</td><td align="center">char32_t</td></tr><tr><td align="center">L</td><td align="center">wchar_t</td></tr><tr><td align="center">u8</td><td align="center">char</td></tr><tr><td align="center">整型字面值</td><td align="center"></td></tr><tr><td align="center">后缀</td><td align="center">最小匹配类型</td></tr><tr><td align="center">:–:</td><td align="center">:–:</td></tr><tr><td align="center">u or U</td><td align="center">unsigned</td></tr><tr><td align="center">l or L</td><td align="center">long</td></tr><tr><td align="center">ll or LL</td><td align="center">long long</td></tr></tbody></table><p>浮点型字面值</p><table><thead><tr><th align="center">后缀</th><th align="center">最小匹配类型</th></tr></thead><tbody><tr><td align="center">f or F</td><td align="center">float</td></tr><tr><td align="center">l or L</td><td align="center">long double</td></tr></tbody></table><p><strong>c++语言规定的转义序列</strong>：<br>换行符   \n      横向制表符   \t<br>纵向制表符  \v   退格符      \b<br>反斜线    \     问号     ?<br>回车符   \r      单引号    &#39;</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>基本形式：<strong>类型说明符</strong>+一个或多个变量名组成的列表+分号</p><blockquote><p><strong>什么是对象</strong><br>通常情况下，对象是指一块能存储数据并具有某种类型的内存空间</p></blockquote><p>当对象被创建时获得了一个特定的值，我们就说这个值被<strong>初始化</strong>了。</p><blockquote><p>初始化不是赋值，初始化的含义使创建变量时赋予一个初始值，而赋值的含义是把对象的当前值擦除，以一个新值来替代。</p></blockquote><h4 id="变量声明和定义"><a href="#变量声明和定义" class="headerlink" title="变量声明和定义"></a>变量声明和定义</h4><p><strong>声明</strong>使得名字被程序知道，如果要使用别处定义的名字必须包含该名字的声明。<br><strong>定义</strong>创建与名字关联的实体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i ;<span class="comment">//声明i</span></span><br><span class="line"><span class="type">int</span> j; <span class="comment">//声明并定义j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.1416</span>; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure><blockquote><p>变量能且只能被定义一次，但是可以被多次声明<br>一般来说，在对象第一次使用的地方定义更好。</p></blockquote><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><strong>引用</strong>就是为对象起了另一个名字，并且引用必须被初始化，通过在变量前加&amp;定义引用类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">11</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref = a;</span><br><span class="line">ref = <span class="number">13</span>; <span class="comment">//把13赋值给a</span></span><br></pre></td></tr></table></figure><blockquote><p>为什么引用要被初始化<br>因为引用时，程序把引用和初始值绑定在一起，而不是将初始值拷贝给引用。</p></blockquote><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p><strong>指针</strong>：在变量名前加*来定义指针,指针存放某个对象的地址,要想获得该地址，需要用取地址符&amp;。如果指针指向了一个对象，需要使用解引用符 *来访问对象</p><ol><li>指针本身就是一个对象，允许对指针赋值和拷贝</li><li>指针无需在定义时赋初值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;a; <span class="comment">//指向地址</span></span><br><span class="line"><span class="type">int</span> *ptr2 = ptr; <span class="comment">//指向int对象的指针</span></span><br><span class="line">cout&lt;&lt;*ptr;</span><br></pre></td></tr></table></figure></li></ol><p><strong>指针值</strong>应属于下列4种状态之一：</p><ol><li>指向一个对象</li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针</li><li>无效指针，上述情况以外的值</li></ol><p><strong>空指针</strong>不指向任何对象，生成空指针如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p =<span class="literal">nullptr</span>; <span class="comment">//C++11引入</span></span><br><span class="line"><span class="type">int</span> *p =<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p =<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><blockquote><p>建议初始化所有指针，并且尽量等定义了对象之后再定义指向它的指针。</p></blockquote><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p>加了const限定符的变量不能被改变，相当于一个常量。任何试图修改该值的行为都会引发错误，并且const对象必须初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i=<span class="built_in">get</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j=<span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>默认情况下，const对象仅在文件内有效，但是如果我们要使用的const常量，初始值不是一个常量表达式，但是有需要在文件间共享，只需在const变量前添加extern即可。</p><h4 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h4><p><strong>常量表达式</strong>是指不会改变并且在编译过程就能得到计算结果的表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max =<span class="number">20</span>;<span class="comment">//是</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = max+<span class="number">1</span>;<span class="comment">//是</span></span><br><span class="line"><span class="type">int</span> b=<span class="number">2</span>;<span class="comment">//不是</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="built_in">get_size</span>();<span class="comment">//不是常量表达式</span></span><br></pre></td></tr></table></figure><p>但是在复杂的系统中，很难分辨一个初始值是不是常量表达式，因此c++11标准规定，允许将变量声明为constexpr类型由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，并且必须用常量表达式初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> b=a+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>一般来说，如果认定变量是一个常量表达式，就把其设为constexpr类型。</p><p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。</p><h3 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h3><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名就是给某种类型重新定义一个名字。传统方法是使用关键字typedef:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages; <span class="comment">//wages与double同义</span></span><br><span class="line"><span class="keyword">typedef</span> wages base,*p;<span class="comment">//base是double的同义词，p是double*的同义词。</span></span><br></pre></td></tr></table></figure><p>新标准使用别名声明来定义类型的别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI  Sale_item;<span class="comment">//SI是Sale_item的同义词。</span></span><br></pre></td></tr></table></figure><h4 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h4><p>auto类型说明符是在c++新标准引入的，用它就能让编译器替我们去分析表达式所属的类型。因此auto定义的变量必须有初始值。<br>使用auto可以在一个语句中声明多个变量，但是该语句中所有变量的初始基本数据类型必须一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i=<span class="number">0</span>;*p=&amp;i;</span><br></pre></td></tr></table></figure><h4 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h4><p>decltype类型说明符是选择并返回操作数的数据类型，编译器可以得到它的类型，但是不计算表达式的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum=x;<span class="comment">//sum的类型就是f返回的类型。</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/CPP/">CPP</category>
      
      
      <category domain="http://singlewang.top/tags/cpp/">cpp</category>
      
      
      <comments>http://singlewang.top/2022/06/10/cpp/cpp_primer_ch2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch9硬件加速与功能卸载</title>
      <link>http://singlewang.top/2022/06/09/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch9/</link>
      <guid>http://singlewang.top/2022/06/09/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch9/</guid>
      <pubDate>Thu, 09 Jun 2022 11:22:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;硬件加速与功能卸载&quot;&gt;&lt;a href=&quot;#硬件加速与功能卸载&quot; class=&quot;headerlink&quot; title=&quot;硬件加速与功能卸载&quot;&gt;&lt;/a&gt;硬件加速与功能卸载&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;硬件的缺点：资源局限，功能固化，设计与发布的时间长，更新周</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="硬件加速与功能卸载"><a href="#硬件加速与功能卸载" class="headerlink" title="硬件加速与功能卸载"></a>硬件加速与功能卸载</h3><blockquote><p>硬件的缺点：资源局限，功能固化，设计与发布的时间长，更新周期长。</p></blockquote><h4 id="硬件卸载"><a href="#硬件卸载" class="headerlink" title="硬件卸载"></a>硬件卸载</h4><p>硬件卸载就是将某些功能下移到硬件实现。这些功能原先一般是由软件承担的。<br>对于专有网络设备，为了提高处理数据包的速度，常常将数据面与控制面分离。控制面主要对复杂的数据包进行复杂的控制处理，数据面就是进行简单类似的包处理。<br>基于专门设计的硬件，快速执行数据包的转发和一些简单的报文修改处理可以有效地提高数据的吞吐量和降低发送时延。</p><h4 id="DPDK软件接口"><a href="#DPDK软件接口" class="headerlink" title="DPDK软件接口"></a>DPDK软件接口</h4><p>网卡的硬件卸载功能可能是基于端口设置，也有可能是基于每个包使能设置，需要仔细区分。在包粒度而言，每个包都对应一个或者多个Mbuf，DPDK软件利用<code>rte_mbuf</code>数据结构里的64位的标识(<code>ol_flags</code>)来表征卸载和状态</p><h4 id="硬件与软件功能实现"><a href="#硬件与软件功能实现" class="headerlink" title="硬件与软件功能实现"></a>硬件与软件功能实现</h4><p>如果需要使用硬件卸载功能，网卡驱动需要提供相应的API给上层应用，通过调用API驱动硬件完成相应的工作。<br>硬件提供的接口一般包括寄存器(<code>Register</code>)和描述符(<code>Descriptor</code>)。寄存器是全局的设置，一般用于开启某项功能或者为某项功能设置全局性的参数配置。<br>描述符可以看作是每个数据包的属性，和数据包一起发送给硬件，一般用于携带单个数据包的参数或设置。<br>按照功能的相似性，硬件卸载功能大致可分为三类，分别是&#x3D;&#x3D;计算及更新功能&#x3D;&#x3D;、&#x3D;&#x3D;分片功能&#x3D;&#x3D;、&#x3D;&#x3D;组包功能&#x3D;&#x3D;。</p><h4 id="计算及更新功能卸载"><a href="#计算及更新功能卸载" class="headerlink" title="计算及更新功能卸载"></a>计算及更新功能卸载</h4><h5 id="VLAN硬件卸载"><a href="#VLAN硬件卸载" class="headerlink" title="VLAN硬件卸载"></a>VLAN硬件卸载</h5><p>VLAN只有四个字节，可以实现以太网中逻辑网络隔离功能。<br>如果由软件完成VLAN Tag的插入将给CPU带来额外的负荷，设计一次额外的内存拷贝。VLAN Tag的插入和剥离由网卡硬件完成，可以减轻服务器CPU的负荷。<br><strong>收包时VLAN Tag的过滤</strong><br>VLAN定义了虚拟网络，只有属于相同VLAN的报文，才需要被进一步处理，不属于VLAN的报文会被直接丢弃，网卡最典型的卸载功能之一就是在接收侧针对VLAN进行包过滤。比较典型的实现实在网卡硬件端口设计VLAN过滤表，无法在过滤表中匹配的VLAN包会被丢弃。<br><strong>收包时VLAN Tag的剥离</strong><br>网卡硬件能够对接收到的包的VLAN Tag进行剥离。首先硬件能够对VLAN包进行识别，之后需要在网卡端口的队列上设置使能标志，将剥离特性打开，对应到软件，是驱动写配置入相应的寄存器。网卡硬件会从此寄存器中提取配置信息，用于判断是否对收到的以太网数据进行VLAN剥离。<br>网卡硬件将4字节的VLAN Tag从数据包中剥离，但是 VLAN Tag不能丢弃。DPDK中，驱动对每个接收的数据包进行检测，会依据硬件描述符信息，如果剥离动作发生需要将<code>rte_mbuf</code>中的<code>PKT_RX_VLAN_PKT</code>置位，并且将被剥离的VLAN Tag写入下列字段，供上层使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span>&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> vlan_tci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>发包时VLAN Tag的插入</strong><br>VLAN Tag由两部分组成：<code>TPID(Tag Protocol Identifier)</code>，也就是VLAN的<code>Ether type</code>,和<code>TCI(Tag Control Information)</code>。TPID是一个固定的值，作为一个全局范围内起作用的值，可以通过寄存器进行设置。TCI是每个包相关的，需要逐包设置，在DPDK中，在调用发送函数前，必须提前设置mbuf数据结构。</p><h4 id="分片功能卸载"><a href="#分片功能卸载" class="headerlink" title="分片功能卸载"></a>分片功能卸载</h4><p><strong>TSO</strong><br><code>TSO(TCP Segment Offload)</code>是TCP分片功能的硬件卸载，是发送方向的功能。对于从应用层获取的较大的数据，TCP需要根据下层网络的报文大小限制，将其切分成较小的分片发送。<br>硬件提供的TCP分片硬件卸载功能可以大幅减轻软件对TCP分片的负担。<br>在dpdk&#x2F;testpmd中提供了两条TSO相关的命令行：</p><ol><li>tso set 14000:用于设置tso分片大小</li><li>tso show 0：用于查看tso分片大小</li></ol><h4 id="组包功能卸载"><a href="#组包功能卸载" class="headerlink" title="组包功能卸载"></a>组包功能卸载</h4><p><strong>RSC</strong><br><code>RSC(Receive Side Coalescing，接收方聚合)</code>是TCP组包功能的硬件卸载。硬件组包功能实际上是硬件拆包功能的逆向功能。属于接收方向的功能，可以将拆分的TCP分片聚合成一个大的分片，从而减轻软件的处理。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/">硬件加速</category>
      
      
      <comments>http://singlewang.top/2022/06/09/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch9/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
