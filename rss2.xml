<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Single Wang&#39;s Blog</title>
    <link>http://singlewang.top/</link>
    
    <atom:link href="http://singlewang.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>智者不入爱河，愚者重蹈覆辙</description>
    <pubDate>Fri, 29 Apr 2022 03:12:58 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>DPDK基础</title>
      <link>http://singlewang.top/2022/04/29/dpdk/dpdk-base/dpdk/</link>
      <guid>http://singlewang.top/2022/04/29/dpdk/dpdk-base/dpdk/</guid>
      <pubDate>Fri, 29 Apr 2022 03:12:00 GMT</pubDate>
      
        
        
      <description>&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#-dpdk%E5%AD%A6%</description>
        
      
      
      
      <content:encoded><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#-dpdk%E5%AD%A6%E4%B9%A0"># DPDK学习</a></li><li><a href="#-1dpdk%E7%AE%80%E4%BB%8B">## 1.DPDK简介</a></li><li><a href="#-11dpdk%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84">### 1.1DPDK软件架构</a><ul><li><a href="#111%E5%BA%95%E9%83%A8%E5%86%85%E6%A0%B8%E6%80%81">1.1.1底部内核态</a></li><li><a href="#2%E4%B8%8A%E5%B1%82%E7%94%A8%E6%88%B7%E6%80%81">2上层用户态</a></li><li><a href="#12%E5%B7%A8%E9%A1%B5%E6%8A%80%E6%9C%AF">1.2巨页技术</a></li><li><a href="#13%E8%BD%AE%E8%AF%A2%E6%8A%80%E6%9C%AF">1.3轮询技术</a></li><li><a href="#14cpu%E4%BA%B2%E5%92%8C%E6%8A%80%E6%9C%AF">1.4CPU亲和技术</a></li><li><a href="#15dpdk%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0">1.5DPDK性能影响因素</a></li><li><a href="#16%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">1.6内存管理</a><ul><li><a href="#161%E5%86%85%E5%AD%98%E5%A4%9A%E9%80%9A%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8">1.6.1内存多通道的使用</a></li><li><a href="#162%E5%86%85%E5%AD%98%E5%A4%8D%E5%88%B6">1.6.2内存复制</a></li><li><a href="#163%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">1.6.3内存分配</a></li><li><a href="#164numa%E6%9E%B6%E6%9E%84">1.6.4NUMA架构</a></li><li><a href="#165cpu%E6%A0%B8%E9%97%B4%E6%97%A0%E9%94%81%E9%80%9A%E4%BF%A1">1.6.5CPU核间无锁通信</a></li></ul></li></ul></li><li><a href="#-2dpdk%E5%BA%93%E5%87%BD%E6%95%B0">## 2.DPDK库函数</a><ul><li><a href="#21eal%E5%BA%93">2.1EAL库</a><ul><li><a href="#211%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8">2.1.1内核初始化与启动</a></li><li><a href="#212%E5%86%85%E5%AD%98">2.1.2内存</a></li><li><a href="#213%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BA%B2%E5%92%8C%E6%80%A7">2.1.3多线程与亲和性</a></li></ul></li><li><a href="#2ring%E5%BA%93">2.Ring库</a><ul><li><a href="#221%E5%8D%95%E6%B6%88%E8%B4%B9%E8%80%85%E5%85%A5%E9%98%9F">2.2.1单消费者入队</a></li><li><a href="#222%E5%8D%95%E6%B6%88%E8%B4%B9%E8%80%85%E5%87%BA%E9%98%9F">2.2.2单消费者出队</a></li></ul></li><li><a href="#23mempool%E5%BA%93">2.3Mempool库</a></li><li><a href="#24mbuf%E5%BA%93">2.4mbuf库</a><ul><li><a href="#241%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8">2.4.1数据存储</a></li><li><a href="#242%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE">2.4.2缓冲区分配与释放</a></li><li><a href="#243%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C">2.4.3相关操作</a></li></ul></li><li><a href="#25pmd%E9%A9%B1%E5%8A%A8">2.5PMD驱动</a></li><li><a href="#26ivshmem%E5%BA%93">2.6IVSHMEM库</a></li><li><a href="#27timer%E5%BA%93">2.7Timer库</a></li><li><a href="#28-lpm%E5%BA%93">2.8 LPM库</a></li><li><a href="#29hash%E5%BA%93">2.9Hash库</a></li><li><a href="#210%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%94%AF%E6%8C%81">2.10多进程支持</a></li></ul></li><li><a href="#3dpdk%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2">3DPDK安装与部署</a><ul><li><a href="#31%E8%BF%90%E8%A1%8Cdpdk%E5%BA%94%E7%94%A8%E8%A6%81%E6%B1%82">3.1运行DPDK应用要求</a></li><li><a href="#32%E4%BD%BF%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91dpdk">3.2使用源代码编译DPDK</a><ul><li><a href="#321%E5%AE%89%E8%A3%85dpdk%E5%AE%89%E8%A3%85%E5%8C%85">3.2.1安装DPDK安装包</a></li><li><a href="#322%E5%AE%89%E8%A3%85dpdk%E7%9B%AE%E6%A0%87%E7%8E%AF%E5%A2%83">3.2.2安装DPDK目标环境</a></li><li><a href="#323%E6%9F%A5%E7%9C%8B%E5%B7%B2%E7%BB%8F%E5%AE%89%E8%A3%85%E7%9A%84dpdk%E7%8E%AF%E5%A2%83">3.2.3查看已经安装的DPDK环境</a></li><li><a href="#324%E5%90%AF%E7%94%A8dpdk%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4io%E6%A8%A1%E5%9D%97">3.2.4启用DPDK用户空间I&#x2F;O模块</a></li><li><a href="#325%E5%8A%A0%E8%BD%BDvfio%E6%A8%A1%E5%9D%97">3.2.5加载VFIO模块</a></li><li><a href="#326%E5%9C%A8%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BB%91%E5%AE%9A%E8%A7%A3%E9%99%A4%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3">3.2.6在内核模块绑定&#x2F;解除网络端口</a></li></ul></li><li><a href="#33%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B%E7%A8%8B%E5%BA%8F">3.3编译和运行实例程序</a><ul><li><a href="#331%E7%BC%96%E8%AF%91%E7%A4%BA%E4%BE%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">3.3.1编译示例应用程序</a></li><li><a href="#332%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">3.3.2运行实例应用程序</a></li><li><a href="#333%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%80%BB%E8%BE%91%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8">3.3.3应用程序的逻辑核的使用</a></li></ul></li></ul></li><li><a href="#-34%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E9%85%8D%E7%BD%AE">### 3.4使用脚本配置</a></li><li><a href="#-4dpdk%E8%87%AA%E5%B8%A6%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95">## 4DPDK自带应用软件调试</a><ul><li><a href="#41%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8%E4%BE%8B">4.1命令行应用例</a></li><li><a href="#42helloworld%E5%BA%94%E7%94%A8%E4%BE%8B">4.2HelloWorld应用例</a></li><li><a href="#43l2%E8%BD%AC%E5%8F%91%E5%BA%94%E7%94%A8%E4%BE%8B">4.3L2转发应用例</a><ul><li><a href="#431%E6%A6%82%E8%BF%B0">4.3.1概述</a></li></ul></li></ul></li><li><a href="#-44l3%E8%BD%AC%E5%8F%91%E5%BA%94%E7%94%A8%E4%BE%8B">### 4.4L3转发应用例</a><ul><li><a href="#441%E6%A6%82%E8%BF%B0">4.4.1概述</a></li><li><a href="#442%E8%BF%90%E8%A1%8C%E8%BD%AC%E5%8F%91%E5%BA%94%E7%94%A8%E4%BE%8B">4.4.2运行转发应用例</a></li><li><a href="#443%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E">4.4.3代码说明</a></li><li><a href="#45qos%E8%B0%83%E5%BA%A6%E5%BA%94%E7%94%A8%E4%BE%8B">4.5QoS调度应用例</a><ul><li><a href="#451%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E">4.5.1代码说明</a></li></ul></li><li><a href="#46%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BA%94%E7%94%A8%E4%BE%8B">4.6定时器应用例</a><ul><li><a href="#461%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E">4.6.1代码说明</a></li></ul></li><li><a href="#47%E5%9F%BA%E6%9C%AC%E8%BD%AC%E5%8F%91%E5%BA%94%E7%94%A8%E4%BE%8Bskeleton">4.7基本转发应用例(skeleton)</a><ul><li><a href="#471%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E">4.7.1代码说明</a></li></ul></li></ul></li><li><a href="#5dpdk%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91">5DPDK应用开发</a><ul><li><a href="#51%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87">5.1网卡设备</a><ul><li><a href="#511%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8">5.1.1设备驱动</a></li><li><a href="#512%E5%BA%94%E7%94%A8%E6%8E%A5%E5%8F%A3">5.1.2应用接口</a></li><li><a href="#513%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3">5.1.3设备接口</a></li></ul></li><li><a href="#52%E8%BF%9B%E7%A8%8B">5.2进程</a><ul><li><a href="#521-%E7%BA%BF%E7%A8%8B">5.2.1 线程</a></li><li><a href="#522%E5%8D%95%E8%BF%9B%E7%A8%8B">5.2.2单进程</a></li><li><a href="#523%E5%A4%9A%E8%BF%9B%E7%A8%8B">5.2.3多进程</a></li></ul></li></ul></li></ul><!-- /code_chunk_output --><h1 id="DPDK学习"><a href="#DPDK学习" class="headerlink" title="DPDK学习"></a>DPDK学习</h1><hr><h2 id="1-DPDK简介"><a href="#1-DPDK简介" class="headerlink" title="1.DPDK简介"></a>1.DPDK简介</h2><hr><h3 id="1-1DPDK软件架构"><a href="#1-1DPDK软件架构" class="headerlink" title="1.1DPDK软件架构"></a>1.1DPDK软件架构</h3><hr><h4 id="1-1-1底部内核态"><a href="#1-1-1底部内核态" class="headerlink" title="1.1.1底部内核态"></a>1.1.1底部内核态</h4><p>最底部的内核态有两个模块组成：<code>KNI</code>和<code>IGB_UIO</code>模块，KNI提供给用户一个使用linux内核态的协议栈以及传统的linux网络工具，IGB_UIO借助UIO技术，在初始化过程中件将硬件寄存器映射到用户态。</p><p><em>UIO技术</em></p><hr><h4 id="2上层用户态"><a href="#2上层用户态" class="headerlink" title="2上层用户态"></a>2上层用户态</h4><p>上层用户态主要包括核心部件库，平台相关模块，轮询驱动模式驱动模块。</p><hr><h3 id="1-2巨页技术"><a href="#1-2巨页技术" class="headerlink" title="1.2巨页技术"></a>1.2巨页技术</h3><p>处理器的内存怒管理包含两个概念：物理内存和虚拟内存，linux操作系统中，物理内存按照帧管理，虚拟内存按照页管理。Intel处理使用一块缓存保存地址转换查找的结果，缓存称为<code>TLB(Translation Lookaside Buffer)</code>，如果查找不到相应的映射，就会发生<code>TLB miss</code>，而linux的一般页的大小为4KB，为了减少TLB miss的发生则采用2M或者1GB的大页表。DPDK则利用巨页技术，所有的内存都从巨页里分配，实现对内存池的管理，并预先分配好同样大小的<code>mbuf</code>,給数据分组使用</p><hr><h3 id="1-3轮询技术"><a href="#1-3轮询技术" class="headerlink" title="1.3轮询技术"></a>1.3轮询技术</h3><p>传统网卡的报文接收&#x2F;发送过程中，网卡硬件接收到网络报文，需要发送中断到CPU,通知应用软件有网络报文需要处理。对于高性能的网络处理应用，频繁的中断处理开销极大程度的降低了网络应用程序的性能。</p><p>DPDK使用轮询技术处理网络报文。网卡接收到报文之后，直接将报文保存在处理器缓存中，应用软件周期性的轮询是否有新报文处理。整个过程没有中断。</p><hr><h3 id="1-4CPU亲和技术"><a href="#1-4CPU亲和技术" class="headerlink" title="1.4CPU亲和技术"></a>1.4CPU亲和技术</h3><p>CPU亲和技术就是将某个进程或者线程绑定到特定的一个或者多个核上执行，而不被迁移到其他核上，保证了专用程序的性能。</p><hr><h3 id="1-5DPDK性能影响因素"><a href="#1-5DPDK性能影响因素" class="headerlink" title="1.5DPDK性能影响因素"></a>1.5DPDK性能影响因素</h3><p>&#x3D;&#x3D;CPU频率越高，DPDK性能越高&#x3D;&#x3D;<br>&#x3D;&#x3D;缓存越大，DPDK性能越高&#x3D;&#x3D;<br>&#x3D;&#x3D;PCIe数据通路的数目&#x3D;&#x3D;<br>&#x3D;&#x3D;NUMA&#x3D;&#x3D; </p><p><em>NUMA</em></p><hr><h3 id="1-6内存管理"><a href="#1-6内存管理" class="headerlink" title="1.6内存管理"></a>1.6内存管理</h3><hr><h4 id="1-6-1内存多通道的使用"><a href="#1-6-1内存多通道的使用" class="headerlink" title="1.6.1内存多通道的使用"></a>1.6.1内存多通道的使用</h4><p>现代的内存控制器都支持内存多通道，每个通道都有一个带宽上限，如果内存访问都在一个通道上，就会造成性能瓶颈。<br>DPDK的<code>Mempool</code>库把所有的对象分配在不同的内存通道上，保证尽可能的将内存访问均匀平滑的进行。</p><hr><h4 id="1-6-2内存复制"><a href="#1-6-2内存复制" class="headerlink" title="1.6.2内存复制"></a>1.6.2内存复制</h4><p>不要使用<code>memcpy()</code>或<code>strcpy()</code>,DPDK提供了<code>rte_memcpy()</code>.</p><hr><h4 id="1-6-3内存分配"><a href="#1-6-3内存分配" class="headerlink" title="1.6.3内存分配"></a>1.6.3内存分配</h4><p>不建议使用<code>malloc()</code>，DPDK提供了<code>rte_malloc()</code>。</p><hr><h4 id="1-6-4NUMA架构"><a href="#1-6-4NUMA架构" class="headerlink" title="1.6.4NUMA架构"></a>1.6.4NUMA架构</h4><p><code>NUMA（非统一访问内存）</code>架构<code>SMP(对称多处理)</code>架构是两种典型的内存访问架构</p><hr><h4 id="1-6-5CPU核间无锁通信"><a href="#1-6-5CPU核间无锁通信" class="headerlink" title="1.6.5CPU核间无锁通信"></a>1.6.5CPU核间无锁通信</h4><p>如果想建立一个基于消息传递的核间通信机制，可以使用DPDK ring API，该API是一个无锁的实现。支持批量和突发访问。</p><hr><h2 id="2-DPDK库函数"><a href="#2-DPDK库函数" class="headerlink" title="2.DPDK库函数"></a>2.DPDK库函数</h2><hr><p><code>rte_eal(DPDK环境抽象)</code>以及<code>libc(Linux下的c函数库)</code>是核心组件</p><hr><h3 id="2-1EAL库"><a href="#2-1EAL库" class="headerlink" title="2.1EAL库"></a>2.1EAL库</h3><p>EAL(环境抽象层)用于获取底层资源。主要提供DPDK装载与启动，内核亲和性与分配，系统内存预留等服务。<br>在内存层面，EAL通过<code>mmap()</code>函数在巨页表内进行物理内存分配。以此来提高性能。</p><hr><h4 id="2-1-1内核初始化与启动"><a href="#2-1-1内核初始化与启动" class="headerlink" title="2.1.1内核初始化与启动"></a>2.1.1内核初始化与启动</h4><p>内核初始化由<a href="http://www.dpdk.org/doc/api/"><code>rte_eal_init()</code></a>完成。主要包括内存，日志，PCI等方面的初始化工作。同时启动逻辑核线程。<br>EAL主要由<code>pthread</code>的库的调用组成，主要函数有<code>pthread_self()</code>,<code>pthread_creat()</code>,<code>pthread_setaffinity_np()</code>。</p><hr><h4 id="2-1-2内存"><a href="#2-1-2内存" class="headerlink" title="2.1.2内存"></a>2.1.2内存</h4><p>物理内存映射EAL的特点，物理内存可以是不连续的，EAL通过描述符来描述内存，每一个描述符表示一个连续的内存分配。</p><hr><h4 id="2-1-3多线程与亲和性"><a href="#2-1-3多线程与亲和性" class="headerlink" title="2.1.3多线程与亲和性"></a>2.1.3多线程与亲和性</h4><p>DPDK通常采用一个核匹配一个线程避免过度切换，但是缺乏灵活性。<br>为了提升灵活性，目前方法是设置线程与CPU以及CPU集合的亲和性。有两个公共线程API供使用。<code>rte_thread_set_affinity</code>,<code>rte_pthread_get_affinity</code>。</p><hr><h3 id="2-Ring库"><a href="#2-Ring库" class="headerlink" title="2.Ring库"></a>2.<span class="exturl" data-url="aHR0cDovL3d3dy5kcGRrLm9yZy9kb2MvZ3VpZGVzL3Byb2dfZ3VpZGUvcmluZ19saWIuaHRtbA==">Ring库</span></h3><p>DPDK中的Ring库用于管理队列，主要属性如下：</p><ul><li>FIFO;</li><li>可以设置空间最大值，指针存储在表中；</li><li>多消费者或者单消费者出队，&#x3D;&#x3D;消费者是指数据对象出队机制&#x3D;&#x3D;；</li><li>无锁；</li><li>多生产者或单生产者入队，&#x3D;&#x3D;其中生产者是指数据对象入队机制&#x3D;&#x3D;。</li></ul><p>&#x3D;&#x3D;优点&#x3D;&#x3D;</p><ol><li>数据交换速度相对较快。</li><li>比全无锁队列简单；</li><li>适用于巨型数据的入队和出队操作；</li></ol><p>&#x3D;&#x3D;缺点&#x3D;&#x3D;</p><ol><li>空间大小固定</li><li>Ring很多时，内存消耗很大，一个空的Ring至少包含N个指针。</li></ol><p>&#x3D;&#x3D;特性&#x3D;&#x3D;</p><ol><li>一个Ring用全局唯一的名字标识。</li></ol><hr><h4 id="2-2-1单消费者入队"><a href="#2-2-1单消费者入队" class="headerlink" title="2.2.1单消费者入队"></a>2.2.1单消费者入队</h4><ol><li>对象入队前<br>Ring结构体变量指针<code>ring-&gt;prod_head</code>,<code>ring-&gt;cons_tail</code>被复制到本地变量中，<code>prod_next</code>指向下一个元素。</li><li>入队<br>修改<code>ring-&gt;prod_head</code>的指针位置，和<code>prod_next</code>相同。指向新增对象的指针被复制。</li><li>入队后指针位置调整。<br>当对象入队后，<code>ring-&gt;prod_tail</code>指针位置修改到<code>ring-&gt;prod_head</code>。</li></ol><hr><h4 id="2-2-2单消费者出队"><a href="#2-2-2单消费者出队" class="headerlink" title="2.2.2单消费者出队"></a>2.2.2单消费者出队</h4><p>单消费者从Ring出队，限制条件只有消费者的head和tai可以修改。</p><ol><li>对象出队前<br>将<code>ring-&gt;cons_head</code>,<code>ring-&gt;prod_tail</code>复制到本地变量中，<code>cons_next</code>指向下一个元素。</li><li>对象出队中<br>将<code>ring-&gt;cons_head</code>指向<code>cons_next</code>的位置，指向出队对象的指针由用户给出。</li><li>对象出队后<br>将<code>ring-&gt;cons_tail</code>指向<code>cons_next</code>的位置。</li></ol><hr><h3 id="2-3Mempool库"><a href="#2-3Mempool库" class="headerlink" title="2.3Mempool库"></a>2.3<span class="exturl" data-url="aHR0cDovL3d3dy5kcGRrLm9yZy9kb2MvZ3VpZGVzL3Byb2dfZ3VpZGUvTWVtcG9vbF9saWIuaHRtbA==">Mempool库</span></h3><p>DPDK的Mempool(内存池)库主要供mbuf(内存缓冲区)和EAL使用。<br>DPDK中，Mempool使用字符串名字进行标识，通过Ring方式存储对象。<br>在多核情况中，多个核访问同一个内存池的频率很高，为了避免过多的访问请求，内存池分配器通过几乎无锁的缓存技术保证每一个核的缓存以及大块数据的访问。</p><hr><h3 id="2-4mbuf库"><a href="#2-4mbuf库" class="headerlink" title="2.4mbuf库"></a>2.4mbuf库</h3><p>mbuf库用来分配和释放缓冲区，该缓冲区存储在内存池中，使用Mempool库，Mempool中的数据结构<code>rte_mbuf</code>是承载网络数据分组的缓冲区或一般的控制区。</p><hr><h4 id="2-4-1数据存储"><a href="#2-4-1数据存储" class="headerlink" title="2.4.1数据存储"></a>2.4.1数据存储</h4><p>存储数据分组数据有两种方法：</p><ol><li>使用一个大小固定的单一内存缓冲区存储数据分组；</li><li>使用分散的内存缓冲区来存储数据。</li></ol><p>&#x3D;&#x3D;第一种方法的优点&#x3D;&#x3D;<br>对整个内存的操作只有一对分配和释放操作。<br>&#x3D;&#x3D;第二种方法的优点&#x3D;&#x3D;<br>灵活性好，可以将元数据与数据分组数据完全分离</p><p>&#x3D;&#x3D;DPDP采用第一中方法存储数据&#x3D;&#x3D;</p><hr><h4 id="2-4-2缓冲区分配与释放"><a href="#2-4-2缓冲区分配与释放" class="headerlink" title="2.4.2缓冲区分配与释放"></a>2.4.2缓冲区分配与释放</h4><p>mbuf库使用Mempool库来分配缓冲区<br>内存释放<code>rte_ctrlmbuf_free(m)</code>,<code>rte_pktmbuf_free(m)</code>;</p><h4 id="2-4-3相关操作"><a href="#2-4-3相关操作" class="headerlink" title="2.4.3相关操作"></a>2.4.3相关操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rte_pktmbuf_data_len(m) <span class="comment">//获取数据长度定义宏操作</span></span><br><span class="line">rte_ctrlmbuf_data(m)    <span class="comment">//获取数据起始地址指针宏操作</span></span><br><span class="line">rte_pktmbuf_prepend(<span class="keyword">struct</span> rte_mbuf *m,<span class="type">uint16_t</span> len)           <span class="comment">//在数据前新增数据</span></span><br><span class="line">rte_pktmbuf_append(<span class="keyword">struct</span> rte_mbuf *m,<span class="type">uint16_t</span> len)                    <span class="comment">//在数据后添加数据</span></span><br><span class="line">rte_pktmbuf_adj(<span class="keyword">struct</span> rte_mbuf *m,<span class="type">uint16_t</span> len)                    <span class="comment">//在缓冲区起始位置移除数据</span></span><br><span class="line">rte_pktmbuf_trim(<span class="keyword">struct</span> rte_mbuf *m,<span class="type">uint16_t</span> len)                    <span class="comment">//在缓冲区尾部位置移除数据</span></span><br></pre></td></tr></table></figure><p>所有的网络应用都可以用<code>mbufs</code>传输网络数据分组</p><hr><h3 id="2-5PMD驱动"><a href="#2-5PMD驱动" class="headerlink" title="2.5PMD驱动"></a>2.5PMD驱动</h3><p>DPDK提供1Gbit&#x2F;s,10Gbit&#x2F;s,40Gbit&#x2F;s以及虚拟网卡的<code>PMD(Poll Mode Driver轮询模式驱动)</code>。<br>一个PMD可以无中断的直接访问RX和TX，进而快速的接收、处理和转发数据分组。<br>DPDK环境下的数据分组处理有两种模式：<code>run-to-completion</code>和<code>pipe-line</code></p><ol><li><strong>&#x3D;&#x3D;run-to-completion模式&#x3D;&#x3D;</strong><br>指定端口的RXring被选中接收数据分组，然后数据分组在相同的核上进行处理并放置在该端口的TX ring上通过API发送。<br>&#x3D;&#x3D;这种模式属于同步模式&#x3D;&#x3D;</li><li><strong>&#x3D;&#x3D;pipe-line模式&#x3D;&#x3D;</strong><br>一个核选中一个或者多个端口RX ring，数据分组接收后，通过一个ring传递给另一个核进行处理，处理完成后将数据分组放在该端口的TX ring上，通过API进行转发。<br>&#x3D;&#x3D;这种模式属于异步模式&#x3D;&#x3D;，一些核用来接收数据分组，一些核处理先前接收的分组。</li></ol><p><strong>&#x3D;&#x3D;配置&#x3D;&#x3D;</strong><br>PMD为发送和接收队列提供一些配置：</p><ol><li>发送ring包含的描述符数量</li><li>socket标识符（描述对于DMA内存区的标识），DMA内存区用于在NUMA结构中分配给发送ring</li><li>发送队列相关阈值</li></ol><blockquote><p>当配置DCB操作时，在端口初始化时，发送队列和接收队列的个数必须设置为128.</p></blockquote><h3 id="2-6IVSHMEM库"><a href="#2-6IVSHMEM库" class="headerlink" title="2.6IVSHMEM库"></a>2.6IVSHMEM库</h3><p>DPDK IVSHMEM库主要作用是在虚拟机内快速共享零复制数据。</p><p>此库可以将几个巨页映射为一个单一的IVSHMEM设备，同时，将一个元数据文件映射出一个IVSHMEM段用来区分DPDK和非DPDK的IVSHMEM设备。</p><p><em>元数据文件？</em></p><p>&#x3D;&#x3D;相关API&#x3D;&#x3D;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rte_ivhshmem_metadata_create()   <span class="comment">//创建元数据文件</span></span><br><span class="line">rte_ivhshmem_metadata_add_memzone() <span class="comment">//添加一个内存区（rte_memzone）到元数据文件</span></span><br><span class="line">rte_ivhshmem_metadata_add_ring() <span class="comment">//添加ring到元数据文件</span></span><br><span class="line">rte_ivhshmem_metadata_add_mempool(rte_Mempool) <span class="comment">//添加内存池到元数据文件</span></span><br><span class="line">rte_ivhshmem_matadata_cmdline_generate() <span class="comment">//为QEMU生成命令行</span></span><br></pre></td></tr></table></figure><p><em>数据结构必须完整属于DPDK巨页内存才能正确工作，一个VM可以支持多个元数据文件</em></p><hr><h3 id="2-7Timer库"><a href="#2-7Timer库" class="headerlink" title="2.7Timer库"></a>2.7Timer库</h3><p>Timer（定时器）库为DPDK提供了计时器服务，用于保证执行单元能够执行异步回调功能。特征如下：</p><ol><li>定时器的使用频率可以是周期性或者一次性的</li><li>定时器可以从一个核装载，在另一个核执行</li><li>定时器可以提供较高的精准度</li><li>如果没有应用程序需要，定时器为关闭状态</li></ol><p>定时器的结构主要包含一个状态机，状态机的状态如下：</p><ol><li>STOPPED:没有所属者，不在列表中。</li><li>CONFIG:属于一个核，不能被另外的核修改</li><li>PENDING:属于一个核，存在一个列表中</li><li>RUNNING:属于一个核，不能被另外的核修改，存在与一个列表中。</li></ol><p><em>每一个核的定时器列表维护着那些没有过期的且还在跳表中的定时器。在64bit平台上，定时器的值不需要加锁来检验</em></p><hr><h3 id="2-8-LPM库"><a href="#2-8-LPM库" class="headerlink" title="2.8 LPM库"></a>2.8 LPM库</h3><p>LPM(Longest Prefix Match 最长前缀匹配)，其典型应用场景在IP转发过程中。</p><hr><h3 id="2-9Hash库"><a href="#2-9Hash库" class="headerlink" title="2.9Hash库"></a>2.9Hash库</h3><p>Hash(散列)库，可以通过该库创建散列表，用于快速路由，散列表是一个用于查找数据的优化数据结构，每一个条目由唯一关键字进行标识.<br>DPDK Hash要求在散列创建时，所有关键字具有想通过字节数，。</p><p>主要操作如下：</p><ol><li>增加记录</li><li>删除记录</li><li>查找记录</li></ol><hr><h3 id="2-10多进程支持"><a href="#2-10多进程支持" class="headerlink" title="2.10多进程支持"></a>2.10<span class="exturl" data-url="aHR0cDovL3d3dy5kcGRrLm9yZy9kb2MvZ3VpZGVzL3NhbXBsZV9hcHBfdWcvbXVsdGlfcHJvY2Vzcy5odG1s">多进程支持</span></h3><p>DPDK多线程机制允许一组DPDK进程一起执行数据分组处理或者其他任务<br>EAL允许生成两个DPDK进程，每个进程具有不同的巨页内存权限。</p><ul><li>主进程：可以初始化共享内存，拥有所有共享内存的管理权限。</li><li>辅进程：不能初始化共享内存，但是可以连接预初始化的共享内存并且在该内存中创建对象。<br>命令行参数：</li></ul><ul><li>proc-type：进程类型，primary或secondary</li><li>file-prefix：进程不同步非共同内存区域</li></ul><p>多进程的局限性：</p><ol><li>多进程的特点是要求具有&#x3D;&#x3D;完全相同&#x3D;&#x3D;的巨页内存映射</li><li>所有DPDK进程在使用共享内存时必须遵守严格的核分配</li><li>不能使用辅进程发送中断信息</li><li>DPDK不支持基于不同编译环境的多进程指针</li></ol><hr><h2 id="3DPDK安装与部署"><a href="#3DPDK安装与部署" class="headerlink" title="3DPDK安装与部署"></a>3DPDK安装与部署</h2><hr><h3 id="3-1运行DPDK应用要求"><a href="#3-1运行DPDK应用要求" class="headerlink" title="3.1运行DPDK应用要求"></a>3.1运行DPDK应用要求</h3><ol><li><p>内核版本高于2.6.33</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r //查看内核版本</span><br></pre></td></tr></table></figure></li><li><p>glibc版本高于2.7</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd -version</span><br></pre></td></tr></table></figure></li><li><p>kernel配置<br>大多数linux操作系统中，DPDK提供的内核配置能正常运行。<br>如果是其他操作系统，需打开以下选项：</p></li></ol><ul><li>UIO支持</li><li>HUGETLBFS</li><li>PROC_PAGE_MONITOR</li></ul><ol start="4"><li>巨页的使用</li></ol><ul><li>&#x3D;&#x3D;预留巨页给DPDK使用&#x3D;&#x3D;</li></ul><p>巨页的分配应在开机时或者系统启动后立即进行，防止内存在物理内存中被碎片化。<br>要预留2MB的1024页使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugepages = 1024</span><br></pre></td></tr></table></figure><p>对于其他巨页，如1GB页面，页面尺寸必须特别指定或者将该尺寸设置为系统默认的巨页大小。<br>预留4个1GB页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_hugepagesz=1 Ghugepagesz=1G hugepages=4</span><br></pre></td></tr></table></figure><blockquote><p>一个CPU支持的巨页大小由英特尔架构的CPU标志来决定。</p></blockquote><p>对于2MB的页面，也可以在系统启动后设置。对于单节点系统，使用命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1024 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</span><br></pre></td></tr></table></figure><p>在NUMA架构的系统下，需要对每一个NUMA节点分配巨页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 1024 &gt; /sys/devices/system/node/node0/hugepages/hugepages-2048kB/nr_hugepages</span><br><span class="line">echo 1024 &gt; /sys/devices/system/node/node1/hugepages/hugepages-2048kB/nr_hugepages</span><br></pre></td></tr></table></figure><blockquote><p>对于1GB页面，不能在系统启动后在预留巨页大小</p></blockquote><ul><li>&#x3D;&#x3D;DPDK中使用巨页&#x3D;&#x3D;</li></ul><p>一旦巨页被预留成功就可以在DPDK中使用巨页内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/huge</span><br><span class="line">mount -t hugetlbfs nodev /mnt/huge</span><br></pre></td></tr></table></figure><p>如果需要永久使用一个挂载点，可以将这个挂载点的信息写入&#x2F;etc&#x2F;fstab文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodev /mnt/huge hugetlbfs default 0 0</span><br></pre></td></tr></table></figure><p>对于1GB页面，页面大小必须指定为一个安装选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodev /mnt/huge_1GB hugetlbfs pagesize=1GB 0 0</span><br></pre></td></tr></table></figure><hr><h3 id="3-2使用源代码编译DPDK"><a href="#3-2使用源代码编译DPDK" class="headerlink" title="3.2使用源代码编译DPDK"></a>3.2使用源代码编译DPDK</h3><h4 id="3-2-1安装DPDK安装包"><a href="#3-2-1安装DPDK安装包" class="headerlink" title="3.2.1安装DPDK安装包"></a>3.2.1安装DPDK安装包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unzip DPDK-&lt;version&gt;.zip</span><br><span class="line">cd DPDK-&lt;version&gt;</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>DPDK由以下目录组成：</p><ul><li>lib目录：DPDK库的源代码</li><li>drivers目录：DPDK PMD的源代码</li><li>app目录：DPDK应用程序的源代码</li><li>examples目录：DPDP应用程序示例的源代码</li><li>config，tools，scripts，mkmul：框架相关的生成文件，脚本核配置文件。</li></ul><hr><h4 id="3-2-2安装DPDK目标环境"><a href="#3-2-2安装DPDK目标环境" class="headerlink" title="3.2.2安装DPDK目标环境"></a>3.2.2安装DPDK目标环境</h4><p>使用英特尔C++编译器时（ICC）时，编译编译命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /opt/intel/bin/iccvars.sh intel64</span><br><span class="line">source /opt/intel/bin/iccvars.sh ia32</span><br></pre></td></tr></table></figure><p>要安装核编译目标文件，使用<code>make install T=&lt;target&gt;</code>, T&#x3D; &lt;DPDK根目录&gt;，如使用ICC编译64位DPDK目标文件时，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install T=x86_64-native-linuxapp-icc</span><br></pre></td></tr></table></figure><p>使用gcc编译64位版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install T=x86_64-native-linuxapp-gcc</span><br></pre></td></tr></table></figure><hr><h4 id="3-2-3查看已经安装的DPDK环境"><a href="#3-2-3查看已经安装的DPDK环境" class="headerlink" title="3.2.3查看已经安装的DPDK环境"></a>3.2.3查看已经安装的DPDK环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls x86_64-native-linuxapp-gcc</span><br></pre></td></tr></table></figure><hr><h4 id="3-2-4启用DPDK用户空间I-x2F-O模块"><a href="#3-2-4启用DPDK用户空间I-x2F-O模块" class="headerlink" title="3.2.4启用DPDK用户空间I&#x2F;O模块"></a>3.2.4启用DPDK用户空间I&#x2F;O模块</h4><p>大部分情况下，linux标准内核模块<code>uio_pci_generic</code>可以提供UIO能力，可用如下命令加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe uio_pci_generic</span><br></pre></td></tr></table></figure><p>作为该模块的替代模块komd子目录<code>igb_uio</code>模块，可用如下命令加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe uio</span><br><span class="line">sudo insmod /kmod/igb_uio.ko</span><br></pre></td></tr></table></figure><blockquote><p>对于一些缺少对传统中断支持的设备，如虚拟功能(VF)器件，可能需要用<code>igb_uio</code>模块替代<code>uio_pci_generic</code>模块</p></blockquote><h4 id="3-2-5加载VFIO模块"><a href="#3-2-5加载VFIO模块" class="headerlink" title="3.2.5加载VFIO模块"></a>3.2.5加载VFIO模块</h4><p>对于支持VFIO功能的平台，UIO是可选的，利用VFIO运行DPDK应用程序时，必须加载<code>vfio-PCI</code>模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe vfio-pci</span><br></pre></td></tr></table></figure><blockquote><p>内核必须支持VFIO使用，linux3.6.0内核及以上版本已经包含了VFIO模块，通常默认时加载的。<br>使用VFIO时，服务器系统内核核BIOS必须支持I&#x2F;O虚拟化。 </p></blockquote><h4 id="3-2-6在内核模块绑定-x2F-解除网络端口"><a href="#3-2-6在内核模块绑定-x2F-解除网络端口" class="headerlink" title="3.2.6在内核模块绑定&#x2F;解除网络端口"></a>3.2.6在内核模块绑定&#x2F;解除网络端口</h4><p>使用tools目录下的<code>dpdk_nic_bind.py</code>查看当前网口的驱动状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tools/dpdk_nic_bind.py --status</span><br></pre></td></tr></table></figure><blockquote><p>绑定核接触绑定的操作需要root权限，但是查看网卡信息任何用户都可以</p></blockquote><p>绑定设备的eth1，04:00.1到<code>uio_pci_generic</code>驱动，使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./tools/dpdk_nic_bind.py --bind=ui_pci_generic 04:00.1</span><br><span class="line">或者</span><br><span class="line">./tools/dpdk_nic_bind.py --bind=ui_pci_generic eth1</span><br></pre></td></tr></table></figure><p>恢复设备08:00.1到原来的绑定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./root/dpdk_nic_bind.py --bind=ixgbe 08:00.1</span><br></pre></td></tr></table></figure><hr><h3 id="3-3编译和运行实例程序"><a href="#3-3编译和运行实例程序" class="headerlink" title="3.3编译和运行实例程序"></a>3.3编译和运行实例程序</h3><p> 当应用程序在linux上DPDK环境编译时，必须输出下列变量：<br> &#x3D;&#x3D;RTE_SDK&#x3D;&#x3D;:指向DPDK的安装目录<br> &#x3D;&#x3D;RTE_TARGET&#x3D;&#x3D;:指向DPDK目标环境的目录<br>ex:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export RTE_SDK=$HOME/DPDK</span><br><span class="line">export RTE_TARGET=$HOME</span><br></pre></td></tr></table></figure><hr><h4 id="3-3-1编译示例应用程序"><a href="#3-3-1编译示例应用程序" class="headerlink" title="3.3.1编译示例应用程序"></a>3.3.1编译示例应用程序</h4><p>在应用程序的文件夹中执行<code>make</code>命令即可</p><hr><h4 id="3-3-2运行实例应用程序"><a href="#3-3-2运行实例应用程序" class="headerlink" title="3.3.2运行实例应用程序"></a>3.3.2运行实例应用程序</h4><p>&#x3D;&#x3D;UIO驱动和巨页必须在应用程序运行之前进行设置。应用程序使用的端口必须在应用程序运行之前绑定到相应的内核模块&#x3D;&#x3D;</p><p>每个DPDK应用程序都要设定对应的DPDK目标环境的抽象层（EAL）库，EAL库提供给一些选项给DPDK应用程序使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./rte_app -c COREMASK [-n NUM] [-d &lt;domain:bus:devid.func&gt;]\</span><br><span class="line">[--Socket-mem=MB,...] [-m MB] [-r NUM] [-v] [--file-prefix]\</span><br><span class="line">[--proc-type &lt;primary|secondary|auto&gt;] [-- xen-dom0]</span><br></pre></td></tr></table></figure><p>EAL选项说明：</p><ol><li>-c COREMASK：16位进制掩码，用于指定使用的CPU核的编号</li><li>-n NUM：每个处理器插槽内存通道数</li><li>–use-device：指定使用的以太网设备</li><li>–socket-mem：从巨页中给特定的socket分配的内存</li><li>-m MB:巨页分配的大小，建议用–socket-mem代替</li><li>-v 启动时显示的版本信息</li></ol><p>&#x3D;&#x3D;-c和-n选项必选&#x3D;&#x3D;</p><p>在DPDK应用程序的目录中，假设硬件平台的每个Socket上由4个内存通道，而且0-3号核被应用程序使用，则运行命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./helloworld -c f -n 4</span><br></pre></td></tr></table></figure><hr><h4 id="3-3-3应用程序的逻辑核的使用"><a href="#3-3-3应用程序的逻辑核的使用" class="headerlink" title="3.3.3应用程序的逻辑核的使用"></a>3.3.3应用程序的逻辑核的使用</h4><p>coremask参数一般是DPDK应用程序的必要参数，建议在每个平台上使用coremask时，考虑CPU核的布局分布</p><hr><h3 id="3-4使用脚本配置"><a href="#3-4使用脚本配置" class="headerlink" title="3.4使用脚本配置"></a>3.4使用脚本配置</h3><hr><ol><li>构建DPDK库</li><li>设置环境</li><li>运行应用程序（可选）</li><li>检查系统</li><li>系统清理</li></ol><blockquote><p>setup.sh脚本需要在root权限下运行</p></blockquote><hr><h2 id="4DPDK自带应用软件调试"><a href="#4DPDK自带应用软件调试" class="headerlink" title="4DPDK自带应用软件调试"></a>4DPDK自带应用软件调试</h2><hr><h3 id="4-1命令行应用例"><a href="#4-1命令行应用例" class="headerlink" title="4.1命令行应用例"></a>4.1命令行应用例</h3><p>命令行应用例可以用于在Linux环境中调试各种DPDK应用</p><ul><li>add obj_name IP:用于增加一个带有IP&#x2F;IPv6地址的新对象</li><li>del obj_name:删除特有对象</li><li>show obj_name:显示IP地址所关联的特定对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/cmdline -c f -n 4   //运行实例</span><br></pre></td></tr></table></figure><hr><h3 id="4-2HelloWorld应用例"><a href="#4-2HelloWorld应用例" class="headerlink" title="4.2HelloWorld应用例"></a>4.2HelloWorld应用例</h3><p>在每个CPU的逻辑核上运行“helloworld”语句打印</p><ol><li><p>进入该应用例目录，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export RTE_SDK=/path/to/rte_sdk</span><br><span class="line">cd $(RTE_SDK)/example/helloworld</span><br></pre></td></tr></table></figure></li><li><p>设定RTE目标，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export RTE_TARGET=x86_64-native-linuxapp-gcc</span><br></pre></td></tr></table></figure></li><li><p>编译该应用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/helloworld -c f -n 4</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="4-3L2转发应用例"><a href="#4-3L2转发应用例" class="headerlink" title="4.3L2转发应用例"></a>4.3L2转发应用例</h3><p>L2转发应用例是一个利用DPDK及其SR-IOV进行报文转发处理的简单实例</p><hr><h4 id="4-3-1概述"><a href="#4-3-1概述" class="headerlink" title="4.3.1概述"></a>4.3.1概述</h4><p>L2转发应用实例可以在物理或者虚拟化环境中对每一个从RX_PORT端口收到的报文执行二层转发，目的端口时所允许的端口掩码中的邻接端口，也就是所允许的前四个端口端口1和2转发，端口3和4转发。</p><ul><li>源MAC地址被TX_PORT端口的MAC地址取代</li><li>目的MAC地址被TX_PORT_ID取代</li></ul><blockquote><p>该应用可用于基准性能测试</p></blockquote><p>该应用例无需穿越物理机上的网络设备，可以直接在具有虚拟机的虚拟化环境中使用VF功能。可使用如下命令开启VF功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe ixgbe max_vfs=2,2</span><br></pre></td></tr></table></figure><p>编译该应用同helloworld类似</p><ol><li>该应用实例首先是初始化EAL层使用<code>rte_eal_init</code>初始化，解析EAL参数，然后通过<code>l2fwd_parse_args()</code>函数解析该应用例的特殊参数。</li><li>参数解析完毕，便使用<code>rte_pktmbuf_pool_create()</code>函数创建mbuf pool，mbuf pool中包含了一系列的mbuf对象，用来驱动和应用程序来存放报文。在<code>rte_pktmbuf_pool_creat()</code>函数中，有两个回调函数指针，一个是位于<code>rte_pktmbuf_pool_init()</code>函数中的mp指针，用于初始化驱动程序的私有数据的内存。</li><li>接下来是驱动程序初始化，通过<code>ret_eth_dev_configure()</code>函数配置每个端口上的队列个数。</li><li>然后是RX接收队列初始化，通过<code>rte_eth_rx_queue_setup</code>设置接收队列。</li><li>初始化TX发送队列，发送队列中，每个逻辑核可以在任何端口中发送。通过<code>rte_eth_tx_queue_setup</code>初始化。</li><li>报文的收发与报文处理。通过<code>l2fwd_main_loop</code>函数读取从RX队列接收到的报文。报文被读取到<code>MAX_PKT_BURST</code>大小的内存块中，然后通过<code>rte_eth_rx_burst</code>函数将mbuf指针写入一个本地表，并返回该表中的mbuf个数。然后每个mbuf被<code>l2fwd_simple_forward</code>函数处理。处理过程：从RX端口处理完成后，转送到TX端口发送，替换源MAC和目的MAC。</li><li>报文使用<code>rte_eth_tx_buffer</code>函数发送。</li></ol><hr><h3 id="4-4L3转发应用例"><a href="#4-4L3转发应用例" class="headerlink" title="4.4L3转发应用例"></a>4.4L3转发应用例</h3><hr><h4 id="4-4-1概述"><a href="#4-4-1概述" class="headerlink" title="4.4.1概述"></a>4.4.1概述</h4><p>该应用例展示了DPDK如何利用散列和LPM库进行查表转发处理。L3的转发初始化和确定实时转发路径的过程和L2转发应用例类似。2者的主要区别是L3是基于从输入的报文信息进行转发决策的。</p><blockquote><p>散列查找的键值为报文中的无五元组–源IP,目的IP，源端口,目的端口,协议类型。</p></blockquote><p>每个输入报文的输出接口ID从流表中读取。</p><blockquote><p>注：散列查表可同时转发支持IPv4和IPv6，而LPM查表仅支持IPv4</p></blockquote><p>编译同之前</p><hr><h4 id="4-4-2运行转发应用例"><a href="#4-4-2运行转发应用例" class="headerlink" title="4.4.2运行转发应用例"></a>4.4.2运行转发应用例</h4><p>端口队列逻辑核之间的映射关系</p><table><thead><tr><th align="center">端口</th><th align="center">队列</th><th align="center">逻辑核</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">从端口0映射队列0到逻辑核0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">从端口0映射队列1到逻辑核2</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">从端口1映射队列0到逻辑核1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">3</td><td align="center">从端口1映射队列1到逻辑核3</td></tr></tbody></table><hr><h4 id="4-4-3代码说明"><a href="#4-4-3代码说明" class="headerlink" title="4.4.3代码说明"></a>4.4.3代码说明</h4><p>L3转发大致与L2相似，仅说明L3独有的特性，</p><ol><li>散列初始化<br>散列对象被创建并存放在预先定义的一个全局矩阵中，然后将用户期望的五元组生成为键值，以保持与实际流量一致。通过<code>setup_l3fwd_lookup_tables()</code>函数设置查找的方式，散列的初始化通过<code>setup_hash</code>函数实现，既可以添加ipv4也可以添加ipv6。</li><li>LPM初始化<br>LPM初始化通过<code>setup_lpm</code>函数实现，但是只能添加ipv4。<blockquote><p>LPM和散列表只能选择一种方式，默认情况下选择LPM。</p></blockquote></li><li>基于散列查表的报文转发<br>对于每个输入的报文，通过<code>l3fwd_em_simple_forward()</code>转发，<code>l3fwd_em_simple_forward()</code>支持任何突发方式接收报文，基于散列查表方式分报文转发决策由<code>em_get_ipv4_dst_port</code>和<code>em_get_ipv6_dst_port</code>完成。</li><li>基于LPM的报文转发<br>报文转发操作由<code>l3fwd_lpm_simple_forward()</code>完成，基于LPM查表的报文转发决策由<code>lpm_get_ipv4_dst_port()</code>完成。</li></ol><hr><h3 id="4-5QoS调度应用例"><a href="#4-5QoS调度应用例" class="headerlink" title="4.5QoS调度应用例"></a>4.5QoS调度应用例</h3><p>接收线程从接收端口读取报文，并基于内层和外层VLAN标记，或者IP目的地址的低2byte进行报文分类，最后将这些报文放入环形队列。工作线程将报文从环形队列中取出。如果一个用户使用一个独立的发送核，则报文后续会被送至发送环形队列，发送线程从发送环形队列中读取报文并写入网卡的发送端口。</p><h4 id="4-5-1代码说明"><a href="#4-5-1代码说明" class="headerlink" title="4.5.1代码说明"></a>4.5.1代码说明</h4><p>qos_sched在该应用例中</p><ol><li>一个子接口表示一组预先定义的用户</li><li>一个管道表示一个具体用户</li><li>一个流量类表示具有不同丢包率，时延等需求的流量类型，例如语音，视频和数据传输。</li><li>一个队列承载了属于某类相同用户的一个或多个连接。</li></ol><p>代码流程：</p><ol><li>首先通过<code>app_parse_args</code>函数解析参数。</li><li>然后通过<code>app_init</code>对应用例初始化，初始化每一条流量。通过<code>rte_pktmbuf_pool_create</code>函数创建mbuf pools。通过<code>app_init_sched_port</code>创建调度的端口。</li><li>在<code>app_main_loop</code>函数中循环执行，根据不同的模式执行不同的线程。分别由接收，发送，工作，混合线程。</li></ol><h3 id="4-6定时器应用例"><a href="#4-6定时器应用例" class="headerlink" title="4.6定时器应用例"></a>4.6定时器应用例</h3><p>定时器应用例可以通过定时器设置，有节律的在不同逻辑核上打印出特定信息</p><h4 id="4-6-1代码说明"><a href="#4-6-1代码说明" class="headerlink" title="4.6.1代码说明"></a>4.6.1代码说明</h4><ol><li>首先初始化EAL,通过<code>rte_timer_subsystem_init</code>函数初始化定时器子系统。</li><li>定时器创建后，main注循环体在每个主从逻辑核上使用<code>rte_eal_remote_launch</code>,执行<code>lcore_mainloop</code>循环函数，主循环体内容简单，DPDK推荐使用TCS寄存器，检查是否需要调用<code>rte_timer_manager</code>，此时的定时器的分辨率为10ms。</li><li>在做任何定时器的操作前，首先都需要对定时器初始化，使用<code>rte_timer_init()</code>函数初始化。</li><li>之后对定时器进行配置，使用<code>rte_timer_reset()</code>进行配置</li></ol><ul><li>第一个定时器被放置在主逻辑核，并设置超时门限为1s（hz）,由于提供了，PERIODICAL标志，定时可以由定时器子系统自动重新加载，回调函数为<code>timer0_cb</code></li><li>第二个定时器每隔333ms就在下一个可用的逻辑核中触发，SINGLE标志表示定时器仅当必须被重新手动加载时才会超时。</li></ul><ol start="5"><li>当全局计数器达到20s后，第一个定时器的回调函数显示一段信息，使用<code>rte_timer_stop</code>停止</li><li>第二个定时器的回调函数显示一段信息，并在下一个逻辑核上调用<code>rte_timer_reset</code>重新加载定时器</li></ol><h3 id="4-7基本转发应用例-skeleton"><a href="#4-7基本转发应用例-skeleton" class="headerlink" title="4.7基本转发应用例(skeleton)"></a>4.7基本转发应用例(skeleton)</h3><h4 id="4-7-1代码说明"><a href="#4-7-1代码说明" class="headerlink" title="4.7.1代码说明"></a>4.7.1代码说明</h4><ol><li>收先是EAL层的初始化</li><li>然后通过<code>rte_eth_dev_count_avail</code>函数检查可用的端口是否是偶数</li><li>通过<code>rte_pktmbuf_pool_create</code>函数分配一个内存池，保存应用程序使用的mbufs.</li><li>使用用户自己的函数<code>port_init</code>初始化端口</li><li>通过<code>lcore_main</code>执行应用程序。</li><li>在<code>port_init</code>中，使用<code>rte_eth_dev_configure</code>函数对网络设备进行配置。通过<code>rte_eth_tx_queue_setup</code>和<code>rte_eth_rx_queue_setup</code>分别创建一个发送和接收队列。通过<code>rte_eth_dev_start</code>启动以太网端口。<br>数据包都是通过<code>rte_eth_rx_burst</code>和<code>rte_eth_tx_burst</code>以突发方式进行收发。最后通过<code>rte_pktmbuf_free</code>释放掉没有发送的数据包。</li></ol><hr><h2 id="5DPDK应用开发"><a href="#5DPDK应用开发" class="headerlink" title="5DPDK应用开发"></a>5DPDK应用开发</h2><hr><h3 id="5-1网卡设备"><a href="#5-1网卡设备" class="headerlink" title="5.1网卡设备"></a>5.1网卡设备</h3><h4 id="5-1-1设备驱动"><a href="#5-1-1设备驱动" class="headerlink" title="5.1.1设备驱动"></a>5.1.1设备驱动</h4><p>DPDK采用层次化设计网络设备驱动，由下到上依次是物理层，驱动功能层，设备接口层，应用接口层。</p><blockquote><p>与linuxu不同的是，DPDK采用UIO机制使得网络设备驱动程序运行在用户态。</p></blockquote><hr><h4 id="5-1-2应用接口"><a href="#5-1-2应用接口" class="headerlink" title="5.1.2应用接口"></a>5.1.2应用接口</h4><p>主要为应用程序提供数据分组的收发函数<br><code>rte_eth_rx_burst</code>，<code>rte_eth_tx_burst</code>最终通过Ethernet设备的<code>rx_pkt_burst</code>,<code>tx_pkt_burst</code>,完成报文的收发。<br>报文以<code>rte_mbuf</code>的形式在应用程序中处理。结构如下图</p><table><thead><tr><th align="center">mbuf header</th><th align="center">headroom(保留)</th><th align="center">pkt data</th></tr></thead></table><p>headroom主要预留给报文封装技术，如VLAN，GRE，封装时，在报文数据前填充封装报文头即可，此外同样可用作报文私有区，保存业务的私有数据，从而保持mbuf header的独立。</p><p>rte_mbuf主要分为两类，direct mbuf和indirect mbuf，其中indirect mbuf一般没有pkt data段，主要用作多播处理。</p><hr><h4 id="5-1-3设备接口"><a href="#5-1-3设备接口" class="headerlink" title="5.1.3设备接口"></a>5.1.3设备接口</h4><p>设备接口层，所有的网口抽象封装成Ethernet设备，从而使应用程序能够以相同的方式使用接口。</p><ol><li>rx_pkt_burst,tx_pkt_burst<br>网口的收发处理函数。初始化时，被赋值为与之对应的网卡驱动收发函数。</li><li>data<br>设备相关信息，如网卡名称，队列，链路状态等。</li><li>dev_ops<br>设备的操作函数组，包括MAC地址，链路状态的查询与设定等操作。<br>Ethernet设备的设置，即网口属性的配置，由<code>rte_eth_dev_configure()</code>完成。</li></ol><blockquote><p>队列的注意事项如下：</p><ol><li>队列测个数有限，具体个数根据网卡的类型确定</li><li>同一个队列不支持多线程同时操作</li></ol></blockquote><p>RX队列，通过<code>rte_eth_rx_queue_setup</code>创建<br>TX队列，通过<code>rte_eth_tx_queue_setup</code>创建</p><hr><h3 id="5-2进程"><a href="#5-2进程" class="headerlink" title="5.2进程"></a>5.2进程</h3><h4 id="5-2-1-线程"><a href="#5-2-1-线程" class="headerlink" title="5.2.1 线程"></a>5.2.1 线程</h4><p>默认情况下，DPDK为每个绑定的逻辑核创建一个对应的affinity thread,以降低线程调度切换造成的开销。</p><p>线程创建的初始化流程如下：</p><ol><li>单线程初始化时，运行在master lcore（主核），在初始化函数<code>rte_eal_init()</code>中，通过<code>RTE_LCORE_FOREACH_SLAVE()</code>遍历所有的slave lcore（从核）。</li><li>通过<code>pthread_creat()</code>为从核创建一个线程。，线程的入口函数为<code>eal_thread_loop()</code></li><li>从核执行<code>eal_thread_loop()</code>,获取相应配置及设置相关参数。</li><li>主核通过<code>rte_eal_mp_remote_launch</code>将指定的入口函数通过管道的方式装载到相关的逻辑核中，完成线程初始化。</li></ol><hr><h4 id="5-2-2单进程"><a href="#5-2-2单进程" class="headerlink" title="5.2.2单进程"></a>5.2.2单进程</h4><p>DPDK提供两种单进程方案：</p><ol><li>run-to-completion 报文的收发，处理，接收都在一个逻辑核完成，如l3fwd</li><li>pipeline，报文的额接收，处理，发送在不同的线程完成，线程之间通过ring传递报文核消息。</li></ol><blockquote><p>&#x3D;&#x3D;ring的主要作用就是实现报文的无锁传递。&#x3D;&#x3D;</p></blockquote><p>ring的应用</p><ul><li>属性<br>通过<code>rte_ring_init()</code>创建ring，参数中指定了ring属性：单入，单出，多入，多出</li><li>出入队函数<br>按队列属性，可将出入队函数分为两类：</li></ul><table><thead><tr><th align="center">方式</th><th align="center">主要函数</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">单入单出</td><td align="center">rte_ring_sp_enqueue</td><td align="center">队列属性为单入单出</td></tr><tr><td align="center">多入多出</td><td align="center">rte_ring_sc_dequeue</td><td align="center">队列属性为多入多出</td></tr></tbody></table><p>按照操作方式，可将出队，入队函数分为两类：</p><table><thead><tr><th align="center">方式</th><th align="center">主要函数</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">随机出入</td><td align="center">rte_ring_enqueue_burst()  rte_ring_dequeue_burst()</td><td align="center">返回实际入队、出队报文的个数</td></tr><tr><td align="center">批量出入</td><td align="center">rte_ring_enqueue_bulk() rte_ring_enqueue_bulk()</td><td align="center">一次性完成N个报文的出入队，如失败，则没有报文出入队。</td></tr></tbody></table><h4 id="5-2-3多进程"><a href="#5-2-3多进程" class="headerlink" title="5.2.3多进程"></a>5.2.3多进程</h4><p>在多进程方案中，primary进程用于初始化系统资源，创建巨页共享内容等，secondary进程依赖于primary进程，可通过名称查找找到共享资源。</p><blockquote><p>内存共享的实现：primary进程初始化系统资源时创建了全局配置文件.rte_config,secondary进程查找与之对应的ring和memory的物理地址，从而实现内存共享。</p></blockquote><p>由primary进程共享的资源主要包括如下：</p><ol><li>网口<br>网口共享了Ethermet设备的部分信息<code>struct rte_eth_dev_data</code>,可以实现报文发送，MAC地址的查询，但是无法进行设置和链路状态的查询。</li><li>mbuf_pool<br>实现报恩在进程间零复制，secondary进程通过函数<code>rte_mempool_lookup</code>查找共享的mbuf_pool。</li><li>ring<br>实现进程间无锁传递报文流，secondary进程通过<code>rte_ring_lookup</code>查找共享的ring</li></ol>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-base/">DPDK基础</category>
      
      
      <category domain="http://singlewang.top/tags/DPDK/">DPDK</category>
      
      
      <comments>http://singlewang.top/2022/04/29/dpdk/dpdk-base/dpdk/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>少年啊，前路漫漫</title>
      <link>http://singlewang.top/2022/04/29/informal-essay/life/start/</link>
      <guid>http://singlewang.top/2022/04/29/informal-essay/life/start/</guid>
      <pubDate>Fri, 29 Apr 2022 03:06:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;先随便写点&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>先随便写点</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/informal-essay/">随笔</category>
      
      <category domain="http://singlewang.top/categories/informal-essay/life/">生活感悟</category>
      
      
      <category domain="http://singlewang.top/tags/%E5%BF%83%E5%BE%97/">心得</category>
      
      <category domain="http://singlewang.top/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/">生活感悟</category>
      
      
      <comments>http://singlewang.top/2022/04/29/informal-essay/life/start/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Markdown教程</title>
      <link>http://singlewang.top/2022/04/29/markdown/markdown-base/markdownlearn/</link>
      <guid>http://singlewang.top/2022/04/29/markdown/markdown-base/markdownlearn/</guid>
      <pubDate>Fri, 29 Apr 2022 03:00:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8vscode%E5%86%99markdown&quot;&gt;为什么用Vscode写Markdown&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%8E%E4%B9%88</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8vscode%E5%86%99markdown">为什么用Vscode写Markdown</a><ul><li><a href="#%E6%80%8E%E4%B9%88%E7%94%A8vscode%E5%86%99markdown">怎么用vscode写markdown</a></li><li><a href="#%E9%9A%8F%E4%BE%BF%E5%86%99%E7%82%B9">随便写点</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%AC%E5%9C%B0%E5%86%99markdown">为什么要本地写markdown</a><ul><li><a href="#%E5%A5%BD%E7%94%A8%E5%90%97">好用吗</a><ul><li><a href="#%E6%83%B3%E4%B8%8D%E5%87%BA%E5%86%99%E5%95%A5%E4%BA%86">想不出写啥了</a><ul><li><a href="#%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95">只是一个测试</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><!-- /code_chunk_output --><!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=true} --><!-- code_chunk_output --><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8vscode%E5%86%99markdown">为什么用Vscode写Markdown</a><ul><li><a href="#%E6%80%8E%E4%B9%88%E7%94%A8vscode%E5%86%99markdown">怎么用vscode写markdown</a></li><li><a href="#%E9%9A%8F%E4%BE%BF%E5%86%99%E7%82%B9">随便写点</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%AC%E5%9C%B0%E5%86%99markdown">为什么要本地写markdown</a><ul><li><a href="#%E5%A5%BD%E7%94%A8%E5%90%97">好用吗</a><ul><li><a href="#%E6%83%B3%E4%B8%8D%E5%87%BA%E5%86%99%E5%95%A5%E4%BA%86">想不出写啥了</a><ul><li><a href="#%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95">只是一个测试</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><!-- /code_chunk_output --><h1 id="为什么用Vscode写Markdown"><a href="#为什么用Vscode写Markdown" class="headerlink" title="为什么用Vscode写Markdown"></a>为什么用Vscode写Markdown</h1><h2 id="怎么用vscode写markdown"><a href="#怎么用vscode写markdown" class="headerlink" title="怎么用vscode写markdown"></a>怎么用vscode写markdown</h2><h2 id="随便写点"><a href="#随便写点" class="headerlink" title="随便写点"></a>随便写点</h2><h3 id="为什么要本地写markdown"><a href="#为什么要本地写markdown" class="headerlink" title="为什么要本地写markdown"></a>为什么要本地写markdown</h3><h4 id="好用吗"><a href="#好用吗" class="headerlink" title="好用吗"></a>好用吗</h4><h5 id="想不出写啥了"><a href="#想不出写啥了" class="headerlink" title="想不出写啥了"></a>想不出写啥了</h5><h6 id="只是一个测试"><a href="#只是一个测试" class="headerlink" title="只是一个测试"></a>只是一个测试</h6><p><em><strong>正文直接输入</strong></em></p><p>换行注意。直接换行的话，渲染输出其实是没有换行的，需要空行，使用<code>ctrl+shift+v</code>预览输出,或者使用<code>ctrl+鼠标右键，MPE打开侧边预览</code>，一边写一边看输出结果</p><p>代码段使用两个<code>标记，并且可以在第一个</code>的后面加上自己的语言</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>正文中的代码用<code>helloworld</code>，即两个&#96;&#96;,使用三个—就可以绘制出分割线</p><hr><p>有序列表,加上数字.空格就可以作出有序列表，</p><ol><li>123</li><li>12321</li><li>123123</li><li>123123<ol><li>asdf<ol><li>asdf<ol><li>大声道</li></ol></li></ol></li></ol></li></ol><hr><p>无序列表<br>输入-，然后空格，当然也可以换成*</p><ul><li>123<ul><li>1231<ul><li>12312<ul><li>3214<ul><li>2342</li></ul></li></ul></li></ul></li></ul></li></ul><hr><p><strong>加粗</strong><br><em>倾斜</em><br><em><strong>加粗和倾斜</strong></em> </p><hr><blockquote><p>这段就是引用，引用是加&gt;和空格</p></blockquote><blockquote><p>也许</p></blockquote><hr><p>插入图片，插入图片时，需要md文件的同级目录下建立一个文件夹，然后将图片放在里面即可</p><p><img data-src="/./assets/000002.jpg" alt="随便找的图片"></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tLw==">如果是链接的话，就不需要前面的额感叹号</span></p><hr><p>表格</p><table><thead><tr><th align="left">左对齐</th><th align="center">居中</th><th align="right">右对齐</th></tr></thead><tbody><tr><td align="left">2</td><td align="center">3</td><td align="right">5</td></tr><tr><td align="left">10</td><td align="center">1000</td><td align="right">1111</td></tr></tbody></table><hr><p>加入目录，在 MPE 里最简单的插入目录的方法就是在单独的行里使用 [TOC] 标记。这会在当前位置立即插入一个目录。</p><p><code>&lt;!-- @import &quot;[TOC]&quot; &#123;cmd=&quot;toc&quot; depthFrom=1 depthTo=5 orderedList=false&#125; --&gt;</code></p><p>depthFrom的参数是最高从几级标题开始</p><p>&#x3D;&#x3D;depthTo&#x3D;&#x3D;的参数是到几级标题结束</p><p>orderedList的参数是是否需要序号</p><hr><p>高亮&#x3D;&#x3D;高亮&#x3D;&#x3D;,使用两个&#x3D;&#x3D;对相应语句进行高亮</p><hr>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/markdown/">Markdown</category>
      
      <category domain="http://singlewang.top/categories/markdown/markdown-base/">Markdown基础</category>
      
      
      <category domain="http://singlewang.top/tags/Markdown/">Markdown</category>
      
      <category domain="http://singlewang.top/tags/%E6%95%99%E7%A8%8B/">教程</category>
      
      
      <comments>http://singlewang.top/2022/04/29/markdown/markdown-base/markdownlearn/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
