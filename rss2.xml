<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Single Wang&#39;s Blog</title>
    <link>http://singlewang.top/</link>
    
    <atom:link href="http://singlewang.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>智者不入爱河，愚者重蹈覆辙</description>
    <pubDate>Wed, 25 May 2022 13:04:09 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Linux中断和定时器</title>
      <link>http://singlewang.top/2022/05/24/linux/linux-kernal/linux-kernal-driver/Linux%E4%B8%AD%E6%96%AD%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <guid>http://singlewang.top/2022/05/24/linux/linux-kernal/linux-kernal-driver/Linux%E4%B8%AD%E6%96%AD%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <pubDate>Tue, 24 May 2022 13:27:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;中断与定时器&quot;&gt;&lt;a href=&quot;#中断与定时器&quot; class=&quot;headerlink&quot; title=&quot;中断与定时器&quot;&gt;&lt;/a&gt;中断与定时器&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;中断&lt;/strong&gt;：指CPU在指向程序的过程中，出现某些突发事件时，CPU必须暂停执行当</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="中断与定时器"><a href="#中断与定时器" class="headerlink" title="中断与定时器"></a>中断与定时器</h3><p><strong>中断</strong>：指CPU在指向程序的过程中，出现某些突发事件时，CPU必须暂停执行当前的程序，转去处理突发事件，处理完毕后又返回原程序被中断的位置并继续执行。</p><ul><li>根据中断的来源可分为：</li></ul><ol><li>内部中断：中断源来自CPU内部，如软件中断指令、溢出等。</li><li>外部中断：中断源来自CPU外部，由外设请求</li></ol><ul><li>根据是否可以屏蔽分为：</li></ul><ol><li>可屏蔽中断：通过屏蔽字相应，屏蔽后，该中断不再得到相应</li><li>不屏蔽中断：不能被屏蔽</li></ol><ul><li>根据中断入口跳转方法不同，可分为：</li></ul><ol><li>向量中断：CPU通常为不同的中断分配不同的中断号。（硬件）</li><li>非向量中断：多个中断共享一个入口地址，进入该入口地址后再通过软件判断中断标志来识别具体哪个中断。（软件）</li></ol><h3 id="Linux中断编程"><a href="#Linux中断编程" class="headerlink" title="Linux中断编程"></a>Linux中断编程</h3><h4 id="申请和释放中断"><a href="#申请和释放中断" class="headerlink" title="申请和释放中断"></a>申请和释放中断</h4><ol><li>申请irq<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">                <span class="type">void</span> (*handler)(<span class="type">int</span> irq.<span class="type">void</span> *dev_id,<span class="keyword">struct</span> pt_regs *regs),</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">char</span> * devname,</span></span><br><span class="line"><span class="params">                <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure>irq是要申请的硬件中断号。<br>handler是向系统等级的中断处理函数，是一个回调函数。<br>irqflags是中断处理的属性<blockquote><p>SA_INTERRUPT 表示中断处理程序是快速处理程序<br>SA_SHIRQ 表示多个设备共享中断<br>request_irq()返回0表示成功，返回-INVAL表示中断号无效或函数指针为NULL，返回-EBUSY表示中断已经被占用。</p></blockquote></li></ol><p>2.释放IRQ</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,<span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure><h4 id="使能和屏蔽中断"><a href="#使能和屏蔽中断" class="headerlink" title="使能和屏蔽中断"></a>使能和屏蔽中断</h4><p>以下三个函数用于屏蔽一个中断源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">disable_irq</span><span class="params">(<span class="type">int</span> irq)</span>; <span class="comment">//立即返回</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_irq_nosync</span><span class="params">(<span class="type">int</span> irq)</span>; <span class="comment">//等待目前的中断处理完成</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_irq</span><span class="params">(<span class="type">int</span> irq)</span>; <span class="comment">//作用与可编程中断控制器，对系统内的所有CPU都生效。</span></span><br></pre></td></tr></table></figure><p>以下两个函数将屏蔽本CPU内的所有中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">local_irq_save</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> falgs)</span>;<span class="comment">//将目前的中断状态保留在flags中。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">local_irq_diasble</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//直接禁止中断</span></span><br></pre></td></tr></table></figure><p>恢复中断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">local_irq_restore</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">local_irq_enable</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>硬中断、软中断、信号的区别：</p><ol><li>硬中断是外部设备对&#x3D;&#x3D;CPU&#x3D;&#x3D;的中断</li><li>软中断通常是硬中断服务程序对&#x3D;&#x3D;内核&#x3D;&#x3D;的中断</li><li>信号则是由内核对某个&#x3D;&#x3D;进程&#x3D;&#x3D;的中断</li></ol><h3 id="内核定时器"><a href="#内核定时器" class="headerlink" title="内核定时器"></a>内核定时器</h3><h4 id="内核定时器编程"><a href="#内核定时器编程" class="headerlink" title="内核定时器编程"></a>内核定时器编程</h4><p>软件意义上的定时器最终依赖硬件定时器来实现，内核在时钟中断发生后检测各定时器是否到期，到期后的定时器处理函数将作为软中断在底半部执行。</p><p>linux内核所提供的用于操作定时器的数据结构和函数如下：</p><ol><li>timer_list</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span> <span class="comment">//定时器列表</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires; <span class="comment">//定时器到期时间</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">//定时器处理函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;  <span class="comment">//作为参数被传入</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_base_s</span> *<span class="title">base</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">my_timer</span>;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>初始化定时器<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span>;</span><br></pre></td></tr></table></figure></li></ol><p><code>TIMER_INITIALIZER(_function,_expires,_data)</code>宏用于赋值定时结构体的function、expires、data、base成员。</p><ol start="3"><li><p>增加定时器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span>; <span class="comment">//注册内核定时器，将定时器加入到内核动态定时器链表中。</span></span><br></pre></td></tr></table></figure></li><li><p>删除定时器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">del_timer</span><span class="params">(sturct timer_list * timer)</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="内核延时"><a href="#内核延时" class="headerlink" title="内核延时"></a>内核延时</h3><h4 id="短延时"><a href="#短延时" class="headerlink" title="短延时"></a>短延时</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ndelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nsecs)</span>; <span class="comment">//纳秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">udelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> usecs)</span>; <span class="comment">//微秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mdelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span>; <span class="comment">//毫秒</span></span><br></pre></td></tr></table></figure><p>在内核中，最好不要直接使用毫秒级别的延时，这将无所谓地耗费CPU资源。对于毫秒级以上地时延，内核提供了下述函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">msleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>; <span class="comment">//不能被打断</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">msleep_interruptible</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>; <span class="comment">//可以被打断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ssleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>; <span class="comment">//不能被打断</span></span><br></pre></td></tr></table></figure><h4 id="长延时"><a href="#长延时" class="headerlink" title="长延时"></a>长延时</h4><p>内核中进行延时地很直观地方法时比较当前地jiffies和目标jiffies，知道未来地jiffies达到目标jiffies。</p><h4 id="睡着延时"><a href="#睡着延时" class="headerlink" title="睡着延时"></a>睡着延时</h4><p>睡着延时比忙等待更好，随着延迟在等待地时间到来之间进程处于睡眠状态，CPU资源被其他进程使用。<code>schedule_timeout()</code>可以使当前任务睡眠指定地jiffies之后重新被调度执行。<br>实际上<code>schedule_timeout()</code>地实现原理时向系统添加一个定时器，在定时器处理函数中唤醒参数对应地进程。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/linux-kernal-driver/">Linux内核驱动</category>
      
      
      <category domain="http://singlewang.top/tags/Linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/">Linux网络设备</category>
      
      <category domain="http://singlewang.top/tags/Linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/">Linux内核驱动</category>
      
      
      <comments>http://singlewang.top/2022/05/24/linux/linux-kernal/linux-kernal-driver/Linux%E4%B8%AD%E6%96%AD%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我真的有机会被爱吗</title>
      <link>http://singlewang.top/2022/05/20/informal-essay/life/520%E9%9A%8F%E6%83%B3/</link>
      <guid>http://singlewang.top/2022/05/20/informal-essay/life/520%E9%9A%8F%E6%83%B3/</guid>
      <pubDate>Fri, 20 May 2022 03:06:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;红豆生南国，&lt;br&gt;春来发几枝。&lt;br&gt;愿君多采撷，&lt;br&gt;此物最相思。&lt;br&gt;         –《相思》唐·王维&lt;br&gt;讲真，这个标题属实有点矫情了，但是仔细一想，其实也没那么肉麻，更多的是基于我目前现状的一种感叹吧。&lt;br&gt;今天恰好是5月20日，也就是不知道从什么时候</description>
        
      
      
      
      <content:encoded><![CDATA[<p>红豆生南国，<br>春来发几枝。<br>愿君多采撷，<br>此物最相思。<br>         –《相思》唐·王维<br>讲真，这个标题属实有点矫情了，但是仔细一想，其实也没那么肉麻，更多的是基于我目前现状的一种感叹吧。<br>今天恰好是5月20日，也就是不知道从什么时候演变成一个节日的日期，在这一天，朋友圈，微博无处不在秀着各自的恩爱，在从前我还会有些许的羡慕，羡慕情侣之间的浪漫，也曾幻想着自己也能和自己心爱的姑娘在这一天过着属于自己二人世界，可如今我的羡慕之情却已暗淡，因为不知道什么时候起，爱情对我来说就像是不存在一般，仿佛神话故事中那些未曾见过的神兽般虚无缥缈。我不知道自己是否还需要它，因为就目前我的现状来看自己好像也并不是没它不行，一个人的生活也很潇洒，但是看着路边的情侣卿卿我我，也不免会从心底有一丝孤单。<br>我是一个沉默寡言的人，性格随和却又内向，想起昨天玩游戏的时候，碰见一对情侣很有意思，一边聊天一边玩，说找对象要靠口才，乍一听好像有些片面了，但是仔细想想，许多时候人们的邂逅不就是第一次打招呼开始吗，现实中那些滔滔不绝，口若悬河的人也往往更能获得女生的关注，而我则可能呆在角落里看他们嬉戏打闹，我并不是不想参与，只是性格的原因导致我放不开，看见一个心动的女生也不敢上前打招呼，唯一一个令自己心动了那么多年的女生还在前不久和我断联，只能说是我咎由自取吧。但是老实话少就该被嫌弃吗，又或者说得不到关注，说到这儿又想起实验室即将毕业的学长，和他女朋友谈了几年了，工作也找好了，华为的一年40多w，能力强，却在前不久分手了，女方给出的原因是他太没有情趣了，随后就和另一个男生无缝衔接（我也只是听实验室的同学所说），女生的脑回路真的想不明白，当然每个人都有自己的选择，孰是孰非作为一个旁观者不好做评论，只是为这个学长感到不值罢了。<br>我曾经给我爸妈说过，我反正是不会走相亲这条路的。如果找不到互相喜欢的，那就这样一个人挺好的，努力赚钱，做自己想做的事，虽然知道对不起爸妈，但是我实在不想在感情这件事上妥协，我实在做不到和一个自己不喜欢的人去共度余生，那真的会是一场灾难。我不是不想谈，只是不想抱着试一试的态度去谈了。<br>昨晚莫名其妙又梦见她了，也不知道她现在过的怎样，我努力克制自己不去想她，让自己变得忙碌起来，大概两个月的时间没有想她，可是昨晚又做了一个很清晰的梦，让我不愿醒来。渐渐的我也想开了，有些人并不一定非要在一起，遇见已经是最好的结果了。</p><p>今天就随便写写，感情这事遇见了说明是缘分，遇不见也可能是缘分未到，只能不断的提升自己，静待花开。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/informal-essay/">随笔</category>
      
      <category domain="http://singlewang.top/categories/informal-essay/life/">生活感悟</category>
      
      
      <category domain="http://singlewang.top/tags/%E5%BF%83%E5%BE%97/">心得</category>
      
      <category domain="http://singlewang.top/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/">生活感悟</category>
      
      
      <comments>http://singlewang.top/2022/05/20/informal-essay/life/520%E9%9A%8F%E6%83%B3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch6PCIe与包处理</title>
      <link>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch6/</link>
      <guid>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch6/</guid>
      <pubDate>Thu, 19 May 2022 12:49:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;PCIe与包处理I-x2F-O&quot;&gt;&lt;a href=&quot;#PCIe与包处理I-x2F-O&quot; class=&quot;headerlink&quot; title=&quot;PCIe与包处理I&amp;#x2F;O&quot;&gt;&lt;/a&gt;PCIe与包处理I&amp;#x2F;O&lt;/h2&gt;&lt;h3 id=&quot;从PCIe事务的角度看</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="PCIe与包处理I-x2F-O"><a href="#PCIe与包处理I-x2F-O" class="headerlink" title="PCIe与包处理I&#x2F;O"></a>PCIe与包处理I&#x2F;O</h2><h3 id="从PCIe事务的角度看包处理"><a href="#从PCIe事务的角度看包处理" class="headerlink" title="从PCIe事务的角度看包处理"></a>从PCIe事务的角度看包处理</h3><h4 id="PCIe概览"><a href="#PCIe概览" class="headerlink" title="PCIe概览"></a>PCIe概览</h4><p>PCI Express（Peripheral Component Interconnect Express） 又称PCIe，是一种高速串行通信互联标准。<br>其规范遵循开放系统互联参考模型（OSI），自上而下分为事务传输层，数据链路层，物理层。把物理层朝PCIe根组件（Root Complex）方向的流量叫做上游流量（<code>upstream/inbound</code>）,反之叫做下游流量（<code>downstrean/outbound</code>）。</p><h4 id="PCIe事务传输"><a href="#PCIe事务传输" class="headerlink" title="PCIe事务传输"></a>PCIe事务传输</h4><p>在PCIe的线路上抓取一个TLP（Transaction Layer Packet，事务传输层数据包），它是一种分组形式，层层嵌套，最内层是事务传输层，有头部、数据和校验部分，头部定义了一组事务类型。从CPU网卡收发包来说，用到的PCIe的事务类型主要以<code>Memory Read/Write（MRd/MWr）</code>，<code>Completioin with Data</code>和次外层是数据链路层,最外层是物理层。</p><blockquote><p>对于一个完整的TLP包来说，除去有效载荷，额外还有24B的开销（TLP头部以16B计算）。</p></blockquote><p>应用层数据作为有效载荷被承载在事务传输层上，网卡从线路上接收的以太网包整个作为有效载荷在PCIe的事务传输层上进行内部传输。</p><h3 id="网卡DMA描述符环形队列"><a href="#网卡DMA描述符环形队列" class="headerlink" title="网卡DMA描述符环形队列"></a>网卡DMA描述符环形队列</h3><p>DMA(Direct Memory Access，直接存储器访问)是一种高速的数据传输方式，允许在外部设备和存储器之间直接读写数据。数据及不通过CPU，也不需要CPU干预。整个数据传输操作在DMA控制器的控制下进行。</p><p>网卡DMA控制器通过环形队列与CPU进行交互。环形队列由一组控制寄存器和一块物理上连续的缓存构成。主要的控制寄存器有Base、Size、Head、Tail。</p><ul><li>Base寄存器，可以将分配的一段物理连续的内存地址作为环形队列的起始地址，通告给DMA控制器。</li><li>Size寄存器，通告内存块的大小。</li><li>Head寄存器表示硬件当前访问的描述符单元</li><li>Tail寄存器则由软件来填写更新。</li></ul><p>无论网卡工作在中断方式还是轮询方式下，判断包是否接收成功，或者包是否发送成功，都需要检查描述符中的完成状态位(Descripteor Done,DD)。</p><p>无论进行收包还是发包，网卡驱动需要完成的基本操作包括：</p><ol><li>填充缓冲区地址到描述符</li><li>移动尾指针</li><li>判断描述符中的完成状态位</li></ol><blockquote><p>对于收方向，还有申请重填所需的缓冲区的操作。<br>对于发方向，还有释放已发送数据缓冲区的操作。</p></blockquote><h3 id="数据包收发"><a href="#数据包收发" class="headerlink" title="数据包收发"></a>数据包收发</h3><h4 id="全景分析"><a href="#全景分析" class="headerlink" title="全景分析"></a>全景分析</h4><p><strong>接收方向</strong></p><ol><li>CPU 填充缓冲地址到接受侧描述符</li><li>网卡读取接收侧描述符获取缓冲区地址（outbound）</li><li>网卡将包的内容写到缓冲区地址处（inbound）</li><li>网卡回写接受侧描述符更新状态（inbound）</li><li>CPU读取接收侧描述符以确定包接收完毕</li><li>CPU读取包内容做转发判断</li><li>CPU填充更改包内容，做发送判断</li></ol><p><strong>发送方向</strong></p><ol><li>CPU读发送侧描述符，检查是否有发送完成的标志</li><li>CPU将准备发送的缓冲区地址填充到发送侧描述符</li><li>网卡读取发送侧描述符中的地址（outbound）</li><li>网卡根据描述符中地址，读取缓冲区中的数据内容（outbound）</li><li>网卡写发送侧描述符，更新发送已完成标记（inbound）</li></ol><blockquote><p>由于读请求和完成确认是成对出现的，因此对于inbound方向的读操作其实仍旧有outbound方向上的完成确认消息。这也是inbound方向上的带宽压力更大的原因。</p></blockquote><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>从带宽调优的角度可以用到的方法：</p><ol><li>减少MMIO访问的频度</li><li>提高PCIe传输的效率</li><li>尽量避免Cache Line的部分写</li></ol><h3 id="Mbuf和Mempool"><a href="#Mbuf和Mempool" class="headerlink" title="Mbuf和Mempool"></a>Mbuf和Mempool</h3><h4 id="Mbuf"><a href="#Mbuf" class="headerlink" title="Mbuf"></a>Mbuf</h4><p>为了高效访问数据，DPDK将内存封装在Mbuf结构体内。Mbuf主要用来封装网络帧缓存，也可以用来封装通用控制信息缓存。<br>现在Mbuf头部已经调整成两个Cache Line，将基础性，频繁访问的数据放在第一个Cache Line字节，而将功能性扩展的数据放在第二个Cache Line字节。Mbuf报头包含包处理所需的所有数据，对于单个Mbuf存放不下的巨型帧，Mbuf还有指向下一个Mbuf结构的指针来形成帧链表结构。</p><p>对于网络帧的封装及处理有两种方式：</p><ol><li>将网络帧元数据和帧本身存放在固定大小的同一段缓存中。</li></ol><p><strong>优点</strong>：高效，对缓存的申请及释放只需要一个指令。<br><strong>缺点</strong>：缓存长度固定而网络帧大小不一，大部分帧只能使用填0填满整个换粗，较为耗费空间<br>2. 将元数据和网络帧分开存放在两段缓存里。<br><strong>优点</strong>：相对自由<br><strong>缺点</strong>：低效，因为无法保证数据存在于一个Cache Line中，可能造成未命中。</p><p>为了保持包处理的效率，DPDK采用了前者。<br>网络帧元数据的一部分内容由DPDK的网卡驱动写入。<br>对于巨型帧，网络帧元数据仅出现在第一个帧的Mbuf结构中，其他的帧该信息为空。</p><table><thead><tr><th align="center">rte_mbuf</th><th align="center">head room</th><th align="center">网络数据帧内容</th><th align="center">tail room</th></tr></thead></table><p>数据帧的实际长度可以通过调用<code>rte_pktmbuf_pktlen(Mbuf)</code>或<code>rte_pktmbuf_datalen(Mbuf)</code>获得，但是仅限于单帧Mbuf。<br>对于巨型帧<code>rte_pktmbuf_pktlen(Mbuf)</code>等于所有<br><code>rte_pktmbuf_datalen(Mbuf)</code>的和。</p><p>创建一个新的Mbuf缓存需从所属内存池申请，创建的函数为<code>rte_ptmbuf_alloc()</code>(创建网络帧Mbuf)或<code>rte_ctrlmbuf_alloc()</code>(创建控制帧Mbuf),初始化该Mbuf使用<code>rte_pktmbuf_init()</code>或<code>rte_ctrlmbuf_init()</code>,初始化函数被作为<code>rte_mempool_creat()</code>的回调函数。</p><p>释放一段Mbuf实际等于将其放回所属的内存池，其缓存内容在被 重新创建前不会被初始化。</p><p>对Mbuf可执行的操作还包括：</p><ul><li>获得数据帧长度–rte_pktmbuf_datalen()</li><li>获得指向数据的指针–rte_pktmbuf_mtod()</li><li>在帧数据前插入一段内容–rte_pktmbuf_prepend()</li><li>在帧数据后增加一段内容–rte_pktmbuf_append()</li><li>在帧数据前删除一段内容–rte_pktmbuf_adj()</li><li>将帧数据后截掉一段内容–rte_pktmbuf_trim()</li><li>连接两段缓存–rte_pktmbuf_attach(),仅将此函数用于网络帧的复制或分段</li><li>分开两段缓存–rte_pktmbuf_datach()</li><li>克隆Mbuf–rte_pktmbuf_clone()</li></ul><h4 id="Mempool"><a href="#Mempool" class="headerlink" title="Mempool"></a>Mempool</h4><p>当一个网络帧被网卡接收时，DPDK的网卡驱动将其存储在一个高效的环形缓存区中，同时在Mbuf的环形缓存区中创建一个Mbuf对象。<br>Mbuf对象创建好后，网卡驱动根据分析出的帧信息将其初始化，并将其和实际帧对象逻辑相连。对网络帧的分析处理都集中在Mbuf中</p><p>多核CPU访问同一个内存池或者同一个环形缓存区时，因为每次读写时都要进行Compare-and-Set操作来保证期间数据未被其他核心修改，所以存取效率较低。DPDK的解决方法是使用单核本地缓存一部分数据，实时对环形缓存区进行块读写操作，以减少访问环形缓存区的次数。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91/">报文转发</category>
      
      
      <comments>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch7网卡性能优化</title>
      <link>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch7/</link>
      <guid>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch7/</guid>
      <pubDate>Thu, 19 May 2022 12:49:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;网卡性能优化&quot;&gt;&lt;a href=&quot;#网卡性能优化&quot; class=&quot;headerlink&quot; title=&quot;网卡性能优化&quot;&gt;&lt;/a&gt;网卡性能优化&lt;/h3&gt;&lt;h4 id=&quot;DPDK的轮询模式&quot;&gt;&lt;a href=&quot;#DPDK的轮询模式&quot; class=&quot;headerlink</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="网卡性能优化"><a href="#网卡性能优化" class="headerlink" title="网卡性能优化"></a>网卡性能优化</h3><h4 id="DPDK的轮询模式"><a href="#DPDK的轮询模式" class="headerlink" title="DPDK的轮询模式"></a>DPDK的轮询模式</h4><p>DPDK采用了轮询或者轮询混杂中断的模式来进行收包和发包，此 前主流运行在操作系统内核态的网卡驱动程序基本都是基于异步中断处理模式。</p><h5 id="异步中断模式"><a href="#异步中断模式" class="headerlink" title="异步中断模式"></a>异步中断模式</h5><p>当有包进入网卡收包队列后，网卡会产生硬件中断，进而触发CPU中断，进入中断服务程序，在中断服务程序中完成收包的处理。<br>基于异步中断信号处理模式的收包，不断地在做中断处理，在CPU比I&#x2F;O速率高很多时，处理地负荷可以被忽略，但是如果是高速网卡且I&#x2F;O频繁，开销就会很大。中断是异步方式，因此CPU无需等待，有效利用率高。<br>当有包需要发送出去地时候，基于异步中断信号地驱动程序会准备奥需要发送地包，配置号发送队列地各个描述符。包被真正发送完成时，网卡同样会产生硬件中断信号，进而触发CPU中断，进入中断服务。</p><h5 id="轮询模式"><a href="#轮询模式" class="headerlink" title="轮询模式"></a>轮询模式</h5><p>DPDK最初地纯轮询模式指收发包完全不使用任何中断，集中所有运算资源用于报文处理，但这不是意味着DPDK部可以支持任何中断。</p><p>DPDK所有地收发包有关的中断在物理端口初始化的时候都会关闭，也就是说，CPU在任何时候都不会收到中断。</p><p>每一个收包队列，DPDK都会有一个对应的软件线程负责轮询里面的收包描述符的收包成功的标志。一旦发现某一个收包描述符的收包成功标志被硬件置位了，驱动程序会解析相应的收包描述符，提取各种有用的信息，然后填充对应的缓冲内存块头部。然后把收包缓冲内存块存放到收包函数提供的数组里面，同时分配好一个新的缓冲内存块给这个描述符，以便下一次收包。</p><p>每一个发包队列，DPDK都会有一个对应的软件线程负责设置需要发送出去的包，DPDK的驱动程序负责提取发包缓冲内存块的有效信息。DPDK的轮询驱动程序根据内存缓存块中的包的内容来负责初始化好每一个发包描述符，驱动程序会把每个包翻译成为一个或者多个发包描述符里能够理解的内容，然后写入发包描述符。最关键的有两个，一个是标识完整的包结束的标志<code>EOP(End Of Packet)</code>,另一个就是请求报告发送状态<code>RS(Report Status)</code>。EOP就是驱动程序用来通知网卡硬件一个完整的包结束的标志。RS是驱动程序告诉网卡什么时候需要报告发送结果的标志。</p><p>发包的轮询就是轮询发包结束的硬件标志位。</p><h5 id="混合中断轮询模式"><a href="#混合中断轮询模式" class="headerlink" title="混合中断轮询模式"></a>混合中断轮询模式</h5><p>由于实际网络应用中可能存在的潮汐效应，在某些时间段网络数据流量可能很低，甚至完全没有需要处理的包，这样就会出现在高速端口下低负荷运行的场景，而完全轮询的方式会让处理器一直全速运行，明显浪费处理能力和不节能。<br>因此DPDK引入了收包中断与轮询的混合模式的支持，用户可以根据实际应用场景来选择完全轮询模式，或者混合中断轮询模式。<br>PDK的混合中断轮询机制是基于UIO或VFIO来实现其收包中断通知与处理流程的。如果是基于VFIO的实现，该中断机制是可以支持队列级别的，即一个接收队列对应一个中断号，这是因为VFIO支持多MSI-X 中断号。但如果是基于UIO的实现，该中断机制就只支持一个中断号，所有的队列共享一个中断号。</p><h4 id="网卡I-x2F-O性能优化"><a href="#网卡I-x2F-O性能优化" class="headerlink" title="网卡I&#x2F;O性能优化"></a>网卡I&#x2F;O性能优化</h4><h5 id="Burst收发包的优点"><a href="#Burst收发包的优点" class="headerlink" title="Burst收发包的优点"></a>Burst收发包的优点</h5><p>Burst收发包是DPDK的优化模式，它把收发包复杂的处理过程进行分解，使之成为相对较小的处理阶段，把相邻的数据访问、相似的数据运算集中处理。</p><p>Burst可以理解为突发模式，是一次完成多个数据包的收发，由DPDK函数调用者来决定。</p><p>网卡的收发包描述符一般为16或32字节，而网卡对收包描述符的回写都会一次处理4个或者8个。处理器缓存的预取机制会每次存取相邻的多个缓存单位，Burst充分利用这种机制，明显提高收发包效率。</p><p>Burst收发包是DPDK普遍使用的软件接口，用户可以设定每次收发包函数调用所处理的包的个数，具体函数接口如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">rte_eth_rx_burst</span><span class="params">(<span class="type">uint8_t</span> port_id,<span class="type">uint16_t</span> queue_id,<span class="keyword">struct</span> rte_mbuf  **rx_pkts,<span class="type">const</span> <span class="type">uint16_t</span> nb_pkts)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">rte_eth_tx_burst</span><span class="params">(<span class="type">uint8_t</span> port_id,<span class="type">uint16_t</span> queue_id,<span class="keyword">struct</span> rte_mbuf  **tx_pkts,<span class="type">const</span> <span class="type">uint16_t</span> nb_pkts)</span>;</span><br></pre></td></tr></table></figure><h5 id="批处理和时延隐藏"><a href="#批处理和时延隐藏" class="headerlink" title="批处理和时延隐藏"></a>批处理和时延隐藏</h5><p><strong>时延</strong>：处理器核心执行单元完成一条指令所需要的时钟周期数<br><strong>吞吐</strong>：处理器指令发射端口再次允许接受相同指令所需等待的时钟周期数。<br>时延描述了前后两个关联操作的等待时间，吞吐则描述了指令的并发能力。</p><p>利用CPU指令乱序多发的能力，掩藏指令延迟的一个有效方法是批量处理无数据前后依赖关系的独立事务。对于重复事务执行，通常采用循环逐次操作。对于较复杂的事务，编译器很难大量地区乱序不同迭代序列下地指令。常用到的做法是在一个序列中铺开执行多个事务，以一个合理地步进迭代。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91/">报文转发</category>
      
      
      <comments>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch3并行计算</title>
      <link>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch3/</link>
      <guid>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch3/</guid>
      <pubDate>Thu, 19 May 2022 12:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;并行计算&quot;&gt;&lt;a href=&quot;#并行计算&quot; class=&quot;headerlink&quot; title=&quot;并行计算&quot;&gt;&lt;/a&gt;并行计算&lt;/h2&gt;&lt;p&gt;处理器性能提升主要有两个途径：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提高IPC(每个时钟周期内可执行的指令条数)&lt;/li&gt;
&lt;li&gt;提</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h2><p>处理器性能提升主要有两个途径：</p><ol><li>提高IPC(每个时钟周期内可执行的指令条数)</li><li>提高处理器主频(一味提高会触及频率墙，处理器的功耗正比与主频的三次方)</li></ol><p>可以通过提高指令执行的并行度提高IPC，有两种方法：</p><ol><li>提高微架构的指令并行度</li><li>多核并发</li></ol><h3 id="多核性能和可扩展性"><a href="#多核性能和可扩展性" class="headerlink" title="多核性能和可扩展性"></a>多核性能和可扩展性</h3><h4 id="追求性能水平扩展"><a href="#追求性能水平扩展" class="headerlink" title="追求性能水平扩展"></a>追求性能水平扩展</h4><blockquote><p>Amdahl定律告诉我们，假设一个工作的任务量不变，多核并行计算理论时延加速上限取决于那些不能并行处理部分的比例。</p></blockquote><blockquote><p>Gustafson定律指出，多核并行计算额吞吐率随核数增加而线性扩展，可并行处理部分占整个任务的比例越高，增长的斜率越大。</p></blockquote><h4 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h4><p>CPU物理核中的基本组件可以简化为：CPU寄存器集合、中断逻辑、执行单元和Cache。<br>多核处理器就是指多颗单独封装的CPU通过外部总线连接构成统一的计算平台。</p><blockquote><p>一个物理封装的CPU(通过physical id区分)可以有多个核(通过core id区分)。每个核可以有多个逻辑CPU(通过processor区分判断)。</p></blockquote><h4 id="亲和性"><a href="#亲和性" class="headerlink" title="亲和性"></a>亲和性</h4><p>CPU亲和性指一个特定的任务要在某个给定的CPU上尽量长时间的运行而不被迁移到其他处理器上的倾向性。</p><p>线程迁移的频率小就意味着产生的负载小。</p><h5 id="Linux内核对亲和性的支持"><a href="#Linux内核对亲和性的支持" class="headerlink" title="Linux内核对亲和性的支持"></a>Linux内核对亲和性的支持</h5><p>在Linux内核中，所有的线程都有一个相关的数据结构，称为<code>mask_struct</code>。与亲和性相关度最高的是<code>cpus_allowed</code>位掩码。这个位掩码由n位组成，与系统中的n个逻辑核一一对应。如果针对某个线程设置了相关的位，那么这个线程就可以在相关的CPU上运行。</p><p>Linux相关API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sched_set_affinity() <span class="comment">//用来修改位掩码</span></span><br><span class="line">sched_get_affinity() <span class="comment">//用来查看当前的位掩码</span></span><br></pre></td></tr></table></figure><blockquote><p><code>cpu_affinity</code>会被传递给子线程，因此应该适当的调用<code>sched_set_affinity</code>。</p></blockquote><h5 id="为什么使用亲和性"><a href="#为什么使用亲和性" class="headerlink" title="为什么使用亲和性"></a>为什么使用亲和性</h5><p>将线程与CPU绑定，最直观的好处就是提高了Cache的命中率，减少内存方位损耗，提高程序的速度。<br>减少了线程来回迁移的性能消耗，线程之间干扰也会减少。</p><p>使用亲和性的三个原因：</p><ol><li>有大量计算要做</li><li>测试复杂的应用程序</li><li>运行时间敏感的、决定性的线程</li></ol><h5 id="线程独占"><a href="#线程独占" class="headerlink" title="线程独占"></a>线程独占</h5><p>DPDK通过把线程绑定到逻辑核的方法避免跨核任务中的切换开销，但对于绑定运行的当前逻辑核，仍然可能会有线程切换的发生。因此可以进一步采取把逻辑核从内核调度系统剥离的方法。</p><p>linux内核提供了启动参数<code>isolcpus</code>。对于有4个CPU的服务器，在启动的时候加入启动参数isolcpus&#x3D;2，3.那么系统启动后将不使用CPU3和CPU4;但是还是可以通过<code>taskset</code>指定哪些程序在这些核心中运行。</p><p>步骤如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /boot/grub2.cfg <span class="comment">//在Linux kernel启动参数里面加入isolcpus参数，isolcpu=2， 3</span></span><br><span class="line"></span><br><span class="line">cat /proc/cmdline  <span class="comment">//等待系统重新启动之后查看启动参数BOOT_IMAGE=/boot/vmlinuz3.17.8-200.fc20.x86_64root=UUID=3ae47813-79ea-4805-a732-</span></span><br><span class="line"><span class="number">21b</span>edcbdb0b5ro LANG=en_US.UTF<span class="number">-8</span>isolcpus=<span class="number">2</span>，<span class="number">3</span>。</span><br></pre></td></tr></table></figure><h5 id="DPDK的多线程"><a href="#DPDK的多线程" class="headerlink" title="DPDK的多线程"></a>DPDK的多线程</h5><p>DPDK的线程基于<code>pthread</code>接口创建，属于抢占式线程模型，受内核调度支配。</p><ol><li>EAL中的lcore</li></ol><p>DPDK的lcore指的是EAL线程，本质是基于<code>pthread</code>(Linux&#x2F;FreeBSD)封装实现。<code>lcore</code>由<code>remote_launch</code>指定的任务创建并管理。在每个EAL pthread中， 有一个TLS（Thread Local Storage）称为_lcore_id。当使用DPDK的 EAL‘-c’参数指定coremask时，EAL pthread生成相应个数lcore并默 认是1：1亲和到coremask对应的CPU逻辑核，_lcore_id和CPU ID是一致的。</p><p><em><strong>DPDK中lcore的初始化及执行任务的注册</strong></em></p><ul><li>初始化<ul><li><code>rte_eal_cpu_init()</code>函数中，通过读取<code>/sys/devices/system/cpu/cpuX/</code>,确定当前系统有哪些CPU核，以及每个核属于哪个CPU Socket。</li><li><code>eal_parse_args()</code>函数，解析-c参数。</li><li>为每一个SLAVE核创建线程，并调用<code>eal_thread_set_affinity()</code>绑定CPU。线程的执行体是<code>eal_thread_loop()</code></li></ul></li><li>注册<br>不同的模块需要调用<code>rte_eal_mp_remote_launch()</code>,将自己的回调处理函数注册到lcore_config[]中。</li></ul>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/">并行计算</category>
      
      
      <comments>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch4同步互斥机制</title>
      <link>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch4/</link>
      <guid>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch4/</guid>
      <pubDate>Thu, 19 May 2022 12:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;DPDK原子操作实现和应用&quot;&gt;&lt;a href=&quot;#DPDK原子操作实现和应用&quot; class=&quot;headerlink&quot; title=&quot;DPDK原子操作实现和应用&quot;&gt;&lt;/a&gt;DPDK原子操作实现和应用&lt;/h3&gt;&lt;p&gt;原子操作在DPD代码中的定义都在&lt;code&gt;rte_</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="DPDK原子操作实现和应用"><a href="#DPDK原子操作实现和应用" class="headerlink" title="DPDK原子操作实现和应用"></a>DPDK原子操作实现和应用</h3><p>原子操作在DPD代码中的定义都在<code>rte_atomic.h</code>中，主要包含两部分：<strong>内存屏蔽和原16、32和64位的原子操作API</strong></p><blockquote><p>Linux内核的原子操作见linux驱动</p></blockquote><h4 id="内存屏障API"><a href="#内存屏障API" class="headerlink" title="内存屏障API"></a>内存屏障API</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rte_mb()  <span class="comment">//内存屏障读写API</span></span><br><span class="line">rte_wmb()  <span class="comment">//内存屏障写API</span></span><br><span class="line">rte_rmb()  <span class="comment">//内存屏障读API</span></span><br></pre></td></tr></table></figure><h3 id="DPDK读写锁实现和应用"><a href="#DPDK读写锁实现和应用" class="headerlink" title="DPDK读写锁实现和应用"></a>DPDK读写锁实现和应用</h3><p>DPDK的读写锁的定义在<code>rte_rwlock.h</code>中，</p><blockquote><p>linux读写锁的API见linux驱动</p></blockquote><p><code>rte_rwlock_init(rte_rwlock_t *rwl)</code>:初始化读写锁到unlocked状态<br><code>rte_rwlock_read_lock(rte_rwlock_t *rwl)</code>:尝试获取读锁直到锁被占用<br><code>rte_rwlock_read_unlock(rte_rwlock_t *rwl)</code>:释放读锁<br><code>rte_rwlock_write_lock(rte_rwlock_t *rwl)</code>:获取写锁<br><code>rte_rwlock_write_unlock(rte_rwlock_t *rwl)</code>:释放写锁</p><p>读写锁在DPDK中主要应用在如下几个地方：</p><ol><li>在查找空闲的<code>memory segment</code>的时候，使用读写锁来保护<code>memseg</code>结构，LPM表的创建、查找和释放</li><li><code>Memory ring</code>的创建、查找、释放</li><li>ACL表的创建、查找、释放</li><li>Memzone的创建、查找、释放</li></ol><h3 id="DPDK自旋锁实现和应用"><a href="#DPDK自旋锁实现和应用" class="headerlink" title="DPDK自旋锁实现和应用"></a>DPDK自旋锁实现和应用</h3><p>DPDK自旋锁API的定义在<code>rte_spinlock.h</code>中，下面三个API被广泛应用在告警、日志、中断机制、内存共享、link bonding中用于临界资源的保护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rte_spinlock_init(<span class="type">rte_spinlock_t</span> *sl)</span><br><span class="line">rte_spinlock_lock(<span class="type">rte_spinlock_t</span> *sl)</span><br><span class="line">rte_spinlock_unlock(<span class="type">rte_spinlock_t</span> *sl)</span><br></pre></td></tr></table></figure><h3 id="DPDK无锁环形缓冲"><a href="#DPDK无锁环形缓冲" class="headerlink" title="DPDK无锁环形缓冲"></a>DPDK无锁环形缓冲</h3><p>DPDK提供了一套无锁环形缓冲区队列管理代码，支持单生产者产品入队，单消费者产品出队；多生产者入队，多消费者出队</p><blockquote><p>见DPDK基础</p></blockquote><p>单生产者单消费者模型不需要加锁<br>（一）多对多（一）模型中正常逻辑操作是要对队列操作进行加锁处理。加锁的性能开销较大，一般采用无锁实现。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/">同步互斥</category>
      
      
      <comments>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch5报文转发</title>
      <link>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch5/</link>
      <guid>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch5/</guid>
      <pubDate>Thu, 19 May 2022 11:40:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;报文转发&quot;&gt;&lt;a href=&quot;#报文转发&quot; class=&quot;headerlink&quot; title=&quot;报文转发&quot;&gt;&lt;/a&gt;报文转发&lt;/h2&gt;&lt;h3 id=&quot;网络处理模块划分&quot;&gt;&lt;a href=&quot;#网络处理模块划分&quot; class=&quot;headerlink&quot; title=&quot;网</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="报文转发"><a href="#报文转发" class="headerlink" title="报文转发"></a>报文转发</h2><h3 id="网络处理模块划分"><a href="#网络处理模块划分" class="headerlink" title="网络处理模块划分"></a>网络处理模块划分</h3><p>网络报文的处理和转发主要分为硬件处理部分和软件处理部分：</p><ol><li>报文输入</li><li>对保温进行比较粗粒度的处理</li><li>对保温进行比较细粒度的分流</li><li>提供基于描述符的队列FIFO</li><li>根据队列优先级和CPU状态进行调度</li><li>提供加解密和压缩&#x2F;解压缩等硬件功能</li><li>在出口上根据QOS等级进行调度</li><li>后期报文处理释放缓存</li><li>从硬件上发送出去</li></ol><h3 id="转发框架介绍"><a href="#转发框架介绍" class="headerlink" title="转发框架介绍"></a>转发框架介绍</h3><p>传统的专用网络处理器转发的模型可以分为<code>run to completion</code>模型和<code>pipeline</code>模型</p><ol><li>pipeline模型<br>将一个功能分解成多个独立的阶段，不同阶段间通过队列传递。</li><li>run to completion模型<br><code>run to completion</code>（运行至终结）模型时主要针对DPDK一般程度的运行方法，一个程序中一般会分为几个不同的逻辑功能，但是这几个逻辑功能会在一个CPU的核上运行，我们可以进行水平扩展使得在SMP的系统中多个核上执行一个逻辑的程序，从而提高单位时间内事务处理的量。<h4 id="DPDK-run-to-completion模型"><a href="#DPDK-run-to-completion模型" class="headerlink" title="DPDK run to completion模型"></a>DPDK run to completion模型</h4>DPDK的轮询模式能够通过一些参数设置哪些核可以被DPDK使用，最后再把处理对应收发队列的线程绑定到对应的核上。每个报文的生命周期只可能再一个线程中出现。但是针对单个报文的处理始终集中在一个逻辑单元上，无法利用其他运算单元，并且逻辑的耦合性太强，而流水线模型正好解决了以上的问题。<h4 id="DPDK-pipeline模型"><a href="#DPDK-pipeline模型" class="headerlink" title="DPDK pipeline模型"></a>DPDK pipeline模型</h4>pipeline的主要思想就是不同的工作交给不同的模块，每个模块单独处理特定的事务，每个模块都有输入和输出，通过输入输出将这些模块联系起来，完成复杂的网络功能。<br>DPDK的pipeline是由三大部分组成，逻辑端口(port)、查找表（table）和处理逻辑（action）。DPDK的pipeline模型中把网络端口作为每个处理模块的输入，所有的报文输入都通过这个端口进行。查找表是每个处理模块的处理逻辑核心，转发逻辑指明了报文的流向和处理。<br>用户可以根据这三大类构建属于自己的pipeline。<br>现在DPDK支持的pipeline有以下几种：</li></ol><ul><li>Packet I&#x2F;O</li><li>Flow classification</li><li>Firewall</li><li>Routing</li><li>Metering</li><li>Traffic Mgmt</li></ul>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91/">报文转发</category>
      
      
      <comments>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux网络设备驱动</title>
      <link>http://singlewang.top/2022/05/11/linux/linux-kernal/linux-kernal-driver/linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</link>
      <guid>http://singlewang.top/2022/05/11/linux/linux-kernal/linux-kernal-driver/linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</guid>
      <pubDate>Wed, 11 May 2022 11:57:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;linux网络设备驱动&quot;&gt;&lt;a href=&quot;#linux网络设备驱动&quot; class=&quot;headerlink&quot; title=&quot;linux网络设备驱动&quot;&gt;&lt;/a&gt;linux网络设备驱动&lt;/h2&gt;&lt;h3 id=&quot;linux网络设备驱动的体系结构&quot;&gt;&lt;a href=&quot;#l</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="linux网络设备驱动"><a href="#linux网络设备驱动" class="headerlink" title="linux网络设备驱动"></a>linux网络设备驱动</h2><h3 id="linux网络设备驱动的体系结构"><a href="#linux网络设备驱动的体系结构" class="headerlink" title="linux网络设备驱动的体系结构"></a>linux网络设备驱动的体系结构</h3><p>linux网络设备体系结构从上往下分为4层，依次为网络协议接口层、网络设备接口层、提供实际功能的设备驱动功能层以及网路设备与媒介层。四层作用如下：</p><ol><li><strong>网络协议接口层</strong>向网络层协议提供统一的数据包发送接口，通过<code>dev_queue_xmit()</code>发送数据，通过<code>netif_rx()</code>接收数据。</li><li><strong>网络设备接口层</strong>向协议接口层提供统一的用于描述网络设备属性和操作的结构体<code>net_device</code>。</li><li><strong>设备驱动功能层</strong>个函数是网络接口层<code>net_device</code>数据结构的成员，通过<code>hard_start_xmit()</code>函数启动发送操作，并通过网络设备上的中断触发接收操作。</li><li><strong>网络设备与媒介层</strong>是完成数据包发送和接收的物理实体。对于Linux系统而言，网络设备和媒介都可以是虚拟的。</li></ol><h4 id="网络协议接口层"><a href="#网络协议接口层" class="headerlink" title="网络协议接口层"></a>网络协议接口层</h4><p>网络协议接口层最主要的功能是给上层协议提供了透明的数据包发送和接收接口。<br><code>dev_queue_xmit()</code>的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev_queue_xmit(<span class="keyword">struct</span> sk_buff *skb);</span><br></pre></td></tr></table></figure><p><code>netif_rx()</code>的函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">netif_rx</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><code>sk_buff</code>结构提非常重要，含义为<strong>套接字缓冲区</strong>，用于在Linux网路子系统中的各层之间传送数据。</p></blockquote><ol><li>套接字缓冲区成员<br>（1）各层协议头<code>h</code>、<code>nh</code>、<code>mac</code><br>传输层协议头<code>h</code>，网络层协议头<code>nh</code>，链路层协议头<code>mac</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udphdr</span> *<span class="title">uh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmphdr</span> *<span class="title">icmph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">igmphdr</span> *<span class="title">igmph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span>   * <span class="title">iph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipv6hdr</span> *<span class="title">ipv6h</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *raw; <span class="comment">//数据链路层头部 </span></span><br><span class="line">&#125;h;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipv6hdr</span> *<span class="title">ipv6h</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arphdr</span> *<span class="title">arph</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *raw;<span class="comment">//数据链路层头部</span></span><br><span class="line">&#125;nh;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *raw;</span><br><span class="line">&#125;mac;</span><br></pre></td></tr></table></figure></li></ol><p>(2)数据缓冲区指针<code>head、data、tail、end</code></p><ul><li><code>head</code>指针指向内存中已分配的用于承载网络数据缓冲区的起始地址。</li><li><code>data</code>指针指向对应当前协议层有效数据的起始地址</li><li><code>tail</code>指针指向对应当前协议层有效数据负载的结尾地址。</li><li><code>end</code>指针指向内存中分配的主机缓冲区的结尾</li></ul><p>(3)长度信息<code>len、data_len、truesize</code></p><ul><li><code>len</code>指数据包有效长度，包括协议头和负载(payload)</li><li><code>data_len</code>记录分片的数据长度</li><li><code>truesize</code>表示缓存区的整体长度。</li></ul><ol start="2"><li>套接字缓冲区操作</li></ol><p>(1)分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">alloc_skb</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> len,<span class="type">int</span> priority)</span>;<span class="comment">//priority为内存分配的优先级</span></span><br><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">dev_alloc_skb</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure><p>分配成功后，<code>sk_buff</code>的<code>data</code>，<code>tail</code>指针都指向存储空间的起始地址<code>head</code>。<code>len</code>的大小为0。</p><p>(2)释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_kfree_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_kfree_skb_irq</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_kfree_skb_any</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br></pre></td></tr></table></figure><p>上述函数用于释放分配的套接字缓冲区和数据缓冲区。linux内核使用<code>kfree_skb()</code>,网络设备驱动程序中必须使用其他三个。<code>dev_kfree_skb()</code>用于非中断上下文，<code>dev_kfree_skb_irq()</code>用于中断上下文，any均可采用。<br>(3)指针移动</p><ul><li>put操作<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_put</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len)</span>; <span class="comment">//会对数据进行检查</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *__skb_put(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len); <span class="comment">//不会对数据进行检查</span></span><br></pre></td></tr></table></figure></li></ul><p>上述函数将<code>tail</code>指针下移，增加<code>sk_buff</code>的<code>len</code>，并返回<code>skb-&gt;tail</code>的当前值。主要用于在缓冲区尾部添加数据。</p><ul><li><p>push操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_push</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *__skb_push(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len);</span><br></pre></td></tr></table></figure><p>主要用于在数据包发送给是添加头部。</p></li><li><p>pull操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_pull</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure><p>此函数将<code>data</code>指针下移，减小<code>len</code>的值，一般用于下层协议向上层协议移交数据包，使<code>data</code>指针指向上层协议的协议头</p></li><li><p>reserve操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skb_reserve</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure><p>主要用于在存储空间的头部预留<code>len</code>长度的空隙。</p></li></ul><h4 id="网络设备接口层"><a href="#网络设备接口层" class="headerlink" title="网络设备接口层"></a>网络设备接口层</h4><p><code>net_device</code>结构体在内核中指代一个网络设备，只需通过填充<code>net_device</code>的具体成员并注册即可实现硬件操作函数与内核的挂接</p><ol><li><p>全局信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[IFNAMESIZE];</span><br><span class="line"><span class="type">int</span> (*init)(<span class="keyword">struct</span> net_device *dev);</span><br></pre></td></tr></table></figure><p><code>name</code>是网络设备的名称。<code>init</code>为设备初始化函数指针，如果这个指针被设置了，则网络设备被注册时将调用该函数完成对<code>net_device</code>结构体的初始化。</p></li><li><p>硬件信息</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mem_end;<span class="comment">//共享内存的结束地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mem_start;<span class="comment">//共享内存的起始地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> base_addr;<span class="comment">//网络设备I/O基地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> irq;<span class="comment">//中断号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> if_port;<span class="comment">//使用的端口</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dma;<span class="comment">//分配给设备的DMA通道</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>接口信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> hard_header_len;<span class="comment">//网络设备的硬件头长度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> type<span class="comment">//接口的硬件类型</span></span><br><span class="line"><span class="type">unsigned</span> mtu; <span class="comment">//最大传输单元</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dev_addr[MAX_ADDR_LEN];<span class="comment">//存放硬件地址，需由驱动程序从硬件上读出并填充到dev_addr[]中。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> broadcast[MAX_ADDR_LEN];<span class="comment">//存放广播地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> flags;<span class="comment">//网络接口标志</span></span><br></pre></td></tr></table></figure></li><li><p>设备操作函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*open)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//打开网络接口设备</span></span><br><span class="line"><span class="type">int</span> (*stop)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//停止网络接口设备</span></span><br><span class="line"><span class="type">int</span> (*hard_start_xmit)(<span class="keyword">struct</span> sk_buff *skb,<span class="keyword">struct</span> net_device *dev);<span class="comment">//启动数据包的发送</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_dev_stats</span>* (*<span class="title">get_stats</span>)(<span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>);</span><span class="comment">//用于获得网络设备的状态信息，net_dev_stats保存了网络设备的详细的流量信息，如发送和接收到的数据包数、字节数等</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="设备驱动功能层。"><a href="#设备驱动功能层。" class="headerlink" title="设备驱动功能层。"></a>设备驱动功能层。</h4><p><code>net_device</code>结构体的成员需要被设备驱动功能层的具体数值和函数赋予，驱动开发主要就是在这一层进行。</p><h4 id="网络设备与媒介层"><a href="#网络设备与媒介层" class="headerlink" title="网络设备与媒介层"></a>网络设备与媒介层</h4><p>网络设备与媒介层直接对应于与实际的硬件设备。</p><h3 id="网络设备驱动的注册与注销"><a href="#网络设备驱动的注册与注销" class="headerlink" title="网络设备驱动的注册与注销"></a>网络设备驱动的注册与注销</h3><p>网络设备驱动的注册于注销分别使用<code>register_netdev()</code>和<code>unregister_netdev()</code>完成，这两个函数的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_netdev</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_netdev</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure><p><code>net_device</code>的成员可以里用下面的函数帮助我们填充</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> net_device *<span class="title function_">alloc_netdev</span><span class="params">(<span class="type">int</span> sizeof_priv,<span class="type">const</span> <span class="type">char</span> *name,<span class="type">void</span>(*setup)(<span class="keyword">struct</span> net_device*))</span>;</span><br><span class="line"><span class="keyword">struct</span> net_device *<span class="title function_">alloc_etherdev</span><span class="params">(<span class="type">int</span> sizeof_priv)</span>;</span><br></pre></td></tr></table></figure><p>释放net_device结构体的函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free_netdev(<span class="keyword">struct</span> net_device *dev);</span><br></pre></td></tr></table></figure><p><code>net_device</code>结构体的分配和网络设备驱动注册需在网络设备驱动程序的模块加载函数中进行，而<code>net_device</code>结构体的释放和网络设备驱动的注销需要在模块卸载函数中完成。</p><h3 id="网络设备的初始化"><a href="#网络设备的初始化" class="headerlink" title="网络设备的初始化"></a>网络设备的初始化</h3><p>网络设备的初始化主要需要完成如下几个方面的工作：</p><ul><li>进行硬件上的准备工作，检查网络设备是否存在。</li><li>进行软件接口上的准备工作，分配net_device结构体并对其数据和函数指针成员赋值</li><li>获得设备的私有信息指针并初始化其成员的值。如果私有信息中包括自旋锁或信号量等并发或同步机制，则需对其进行初始化。</li></ul><h3 id="网络设备的打开与释放"><a href="#网络设备的打开与释放" class="headerlink" title="网络设备的打开与释放"></a>网络设备的打开与释放</h3><p>网络设备的打开函数需要完成如下工作：</p><ul><li>使能设备使用的硬件资源，申请I&#x2F;O区域、中断和DMA通道等。</li><li>调用Linux内核提供的<code>netif_start_queue()</code>函数，激活设备发送队列。</li></ul><p>网络设备的关闭函数需要完成如下工作：</p><ul><li>调用Linux内核提供的<code>netif_stop_queue()</code>函数，停止设备传输包</li><li>释放设备所使用的I&#x2F;O区域、中断和DMA资源。</li></ul><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_start_queue</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">netif_stop_queue</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure><h3 id="数据发送流程"><a href="#数据发送流程" class="headerlink" title="数据发送流程"></a>数据发送流程</h3><p>网络设备驱动完成数据包发送的流程如下：</p><ol><li>网络设备驱动程序从上层协议传递过来的<code>sk_buff</code>参数获得数据包的有效数据和长度，将有效数据放入临时缓冲区。</li><li>对于以太网，如果有效数据的长度小于以太网冲突检测锁要求数据帧的最小长度<code>ETH_ZLEN</code>,则给临时缓冲区的末尾填充0。</li><li>设置硬件的寄存器，驱使网络设备进行数据发送操作。</li></ol><p>数据包发送函数模板：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">xxx_tx</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,<span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> *data,shortpkt[ETH_ZLEN];</span><br><span class="line"></span><br><span class="line">    data = skb-&gt;data;</span><br><span class="line">    len = skb-&gt;len;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;ETH_ZLEN)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(shortpkt,<span class="number">0</span>,ETH_ZLEN);</span><br><span class="line">        <span class="built_in">memcpy</span>(shortpkt,skb-&gt;data,skb-&gt;len);</span><br><span class="line">        len=ETH_ZLEN;</span><br><span class="line">        data = shortpkt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev-&gt;trans_start = jiffies;<span class="comment">//记录发送时间戳</span></span><br><span class="line"></span><br><span class="line">    xxx_hw_tx(data,len,dev);<span class="comment">//设置硬件寄存器让硬件把数据包发送出去。</span></span><br><span class="line">    ···;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数据传输超时时，数据包发送超时处理函数<code>xxx_tx_timeout()</code>将被调用。这个函数需要Linux内核提供的<code>netif_wake_queue</code>函数重新启动设备发送队列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">xxx_tx_timeout</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ···</span><br><span class="line">    netif_wake_queue(dev);<span class="comment">//重新启动设备发送队列。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据接收流程"><a href="#数据接收流程" class="headerlink" title="数据接收流程"></a>数据接收流程</h3><p>网络设备接收数据的主要方法是由中断引发设备的中断处理函数，中断处理函数判断中断类型，如果为接收中断，则读取接收到的数据，分配<code>sk_buffer</code>数据结构和数据缓冲区，将接收到的数据复制到数据缓冲区，并调用<code>netif_rx()</code>函数将sk_buffer传递给上层协议。</p><h3 id="网络连接状态"><a href="#网络连接状态" class="headerlink" title="网络连接状态"></a>网络连接状态</h3><p>网络适配器硬件电路可以检测出链路上是否有载波，载波反映了网络的连接是否正常。网络设备驱动可以通过<code>netif_carrier_on()</code>和<code>netif_carrier_off()</code>改变设备的连接状态，如果驱动检测到连接状态发生变化，也可以以<code>netif_carrier_on()</code>和<code>netif_carrier_off()</code>函数显示地通知内核。</p><p>网络设备驱动程序中往往设置一个定时器来对链路状态进行周期性地检查。当定时器到期之后，在定时器处理函数中读取物理设备地相关寄存器获得载波状态，从而更新设备地连接状态。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/linux-kernal-driver/">Linux内核驱动</category>
      
      
      <category domain="http://singlewang.top/tags/Linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/">Linux网络设备</category>
      
      <category domain="http://singlewang.top/tags/Linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/">Linux内核驱动</category>
      
      
      <comments>http://singlewang.top/2022/05/11/linux/linux-kernal/linux-kernal-driver/linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Markdown公式编辑</title>
      <link>http://singlewang.top/2022/05/11/markdown/markdown-base/markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/</link>
      <guid>http://singlewang.top/2022/05/11/markdown/markdown-base/markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/</guid>
      <pubDate>Wed, 11 May 2022 09:43:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;公式编辑&quot;&gt;&lt;a href=&quot;#公式编辑&quot; class=&quot;headerlink&quot; title=&quot;公式编辑&quot;&gt;&lt;/a&gt;公式编辑&lt;/h3&gt;&lt;p&gt;一般公式分为两种形式，&lt;strong&gt;行内公式&lt;/strong&gt;和&lt;strong&gt;行间公式&lt;/strong&gt;&lt;/p&gt;
&lt;ul</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="公式编辑"><a href="#公式编辑" class="headerlink" title="公式编辑"></a>公式编辑</h3><p>一般公式分为两种形式，<strong>行内公式</strong>和<strong>行间公式</strong></p><ul><li>行内公式：$\Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt,. $</li><li>行间公式：$$\Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt,.$$</li></ul><p>行内公式实在公式代码块的基础上前面加上$,后面加上$组成的eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,. $</span><br></pre></td></tr></table></figure><p>行间公式在前后加上$$。eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,.$$</span><br></pre></td></tr></table></figure><h4 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h4><table><thead><tr><th align="center">名称</th><th align="center">大写</th><th align="center">code</th><th align="center">小写</th><th align="center">code</th></tr></thead><tbody><tr><td align="center">alpha</td><td align="center">A</td><td align="center">A</td><td align="center">α</td><td align="center">\alpha</td></tr><tr><td align="center">beta</td><td align="center">B</td><td align="center">B</td><td align="center">β</td><td align="center">\beta</td></tr><tr><td align="center">gamma</td><td align="center">Γ</td><td align="center">\Gamma</td><td align="center">γ</td><td align="center">\gamma</td></tr><tr><td align="center">delta</td><td align="center">Δ</td><td align="center">\Delta</td><td align="center">δ</td><td align="center">\delta</td></tr><tr><td align="center">theta</td><td align="center">Θ</td><td align="center">\Theta</td><td align="center">θ</td><td align="center">\theta</td></tr><tr><td align="center">lambda</td><td align="center">Λ</td><td align="center">\Lambda</td><td align="center">λ</td><td align="center">\lambda</td></tr><tr><td align="center">sigma</td><td align="center">Σ</td><td align="center">\Sigma</td><td align="center">σ</td><td align="center">\sigma</td></tr><tr><td align="center">omega</td><td align="center">Ω</td><td align="center">\Omega</td><td align="center">ω</td><td align="center">\omega</td></tr></tbody></table><h4 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h4><p>上标<code>^</code>,下标<code>_</code>,例如<code>$x_i^2$</code>表示的是：$x_i^2$。<br>默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用<code>&#123;..&#125;</code>包裹起来的内容。</p><h4 id="小括号与方括号"><a href="#小括号与方括号" class="headerlink" title="小括号与方括号"></a>小括号与方括号</h4><p>使用原始的( ) ，[ ] 即可，如<code>$(2+3)[4+4]$ </code>:$(2+3)[4+4]$<br>使用\left(或\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如<code>$\left(\frac&#123;x&#125;&#123;y&#125;\right)$ </code>：$\left(\frac{x}{y}\right)$</p><h4 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h4><p>由于大括号{} 被用于分组，因此需要使用<code>\&#123;</code>和<code>\&#125;</code>表示大括号，也可以使用<code>\lbrace </code>和<code>\rbrace</code>来表示。如<code>$\&#123;a\*b\&#125;:a\∗b$ </code>或<code>$\lbrace a\*b\rbrace :a\*b$</code></p><h4 id="尖括号"><a href="#尖括号" class="headerlink" title="尖括号"></a>尖括号</h4><p>区分于小于号和大于号，使用<code>\langle</code> 和<code>\rangle</code> 表示左尖括号和右尖括号。如<code>$\langle x \rangle$</code> 表示：$\langle x \rangle$。</p><h4 id="上取整"><a href="#上取整" class="headerlink" title="上取整"></a>上取整</h4><p>使用<code>\lceil</code> 和 <code>\rceil</code> 表示。 如，<code>$\lceil x \rceil$</code>：$\lceil x \rceil$</p><h4 id="下取整"><a href="#下取整" class="headerlink" title="下取整"></a>下取整</h4><p>使用<code>\lfloor</code> 和 <code>\rfloor</code> 表示。如，<code>$\lfloor x \rfloor$</code>：$\lfloor x \rfloor$</p><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><p><code>\sum</code> 用来表示求和符号，其下标表示求和下限，上标表示上限。如:<br><code>$\sum_&#123;r=1&#125;^n$</code>表示：$\sum_{r&#x3D;1}^n$。</p><h4 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h4><p><code>\int</code> 用来表示积分符号，同样地，其上下标表示积分的上下限。如，<code>$\int_&#123;r=1&#125;^\infty$</code>：$\int_{r&#x3D;1}^\infty$。<br>多重积分同样使用 int ，通过 i 的数量表示积分导数：<br><code>$\iint$</code> ：$\iint$<br><code>$\iiint$</code> ：$\iiint$</p><h4 id="连乘"><a href="#连乘" class="headerlink" title="连乘"></a>连乘</h4><p><code>$\prod &#123;a+b&#125;$</code>，输出：$\prod {a+b}$。<br><code>$\prod_&#123;i=1&#125;^&#123;K&#125;$</code>，输出：$\prod_{i&#x3D;1}^{K}$。<br><code>$$\prod_&#123;i=1&#125;^&#123;K&#125;$$</code>，输出：$$\prod_{i&#x3D;1}^{K}$$</p><h4 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h4><ul><li>第一种，使用<code>\frac ab</code>，<code>\frac</code>作用于其后的两个组<code>a </code>，<code>b</code> ，结果为$\frac ab$。如果你的分子或分母不是单个字符，请使用{..}来分组，比如<code>$\frac &#123;a+c+1&#125;&#123;b+c+2&#125;$</code>表示$\frac {a+c+1}{b+c+2}$。</li><li>第二种，使用<code>\over</code>来分隔一个组的前后两部分，如<code>$&#123;a+1\over b+1&#125;$</code>：${a+1\over b+1}$。</li></ul><h4 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h4><p>根式使用<code>\sqrt</code> 来表示。<br>如开4次方：<code>$\sqrt[4]&#123;\frac xy&#125;$</code> ：$\sqrt[4]{\frac xy}$。<br>开平方：<code>$\sqrt &#123;a+b&#125;$</code>：$\sqrt {a+b}$。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/markdown/">Markdown</category>
      
      <category domain="http://singlewang.top/categories/markdown/markdown-base/">Markdown基础</category>
      
      
      <category domain="http://singlewang.top/tags/Markdown%E5%85%AC%E5%BC%8F/">Markdown公式</category>
      
      <category domain="http://singlewang.top/tags/%E6%95%99%E7%A8%8B/">教程</category>
      
      
      <comments>http://singlewang.top/2022/05/11/markdown/markdown-base/markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TCP窗口与拥塞控制</title>
      <link>http://singlewang.top/2022/05/10/mobile-communication/TCP%E7%AA%97%E5%8F%A3/</link>
      <guid>http://singlewang.top/2022/05/10/mobile-communication/TCP%E7%AA%97%E5%8F%A3/</guid>
      <pubDate>Tue, 10 May 2022 11:47:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;TCP的特点及其目的&quot;&gt;&lt;a href=&quot;#TCP的特点及其目的&quot; class=&quot;headerlink&quot; title=&quot;TCP的特点及其目的&quot;&gt;&lt;/a&gt;TCP的特点及其目的&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;TCP&lt;/strong&gt;和&lt;strong&gt;UDP&lt;/stro</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="TCP的特点及其目的"><a href="#TCP的特点及其目的" class="headerlink" title="TCP的特点及其目的"></a>TCP的特点及其目的</h3><p><strong>TCP</strong>和<strong>UDP</strong>协议都位于传输层中，TCP主要提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p><p><em>TCP是面向连接的可靠的流协议，流就是指不简短的数据结构。采用TCP发送消息时，虽然可以保证发送的顺序，但是还是犹如没有任何间隔的数据流发送给接收端</em></p><blockquote><p><strong>连接</strong>是指各种设备，线路，或网络中进行通信的两个应用程序为了相互传递消息而转悠的、虚拟的通信线路，也叫虚拟电路。</p></blockquote><p>TCP为提供可靠性传输，实行“顺序控制”或“重传控制”机制。此外还有“流控制”，“拥塞控制”等众多功能。</p><h3 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h3><p>在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知，这个消息叫做<strong>确认应答（ACK）</strong>,如果有确认应答，说明数据已经成功到达对端，反之，则数据丢失的可能性很大，倘若在一段时间内没有ACK,则发送端进行数据的重发。</p><p>未收到ACK,有如下几种情况：</p><ol><li>发出去的数据包丢失</li><li>接收端发回来的ACK在途中丢失。</li></ol><p>虽然在发送端可以按照机制重传，但是对于接收端会重复收到相同的数据，为了对上层应用提供可靠的传输，必须放弃重复的数据包。需要引入一种机制识别是否已经接收数据，判断是否需要接收。</p><p>使用<strong>序列号</strong>解决上述问题。</p><p>序列号时按顺序发送给数据的每一个字节都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序号作为ACK返回，这样就可以是心啊可靠传输。</p><h3 id="重发超时如何确定"><a href="#重发超时如何确定" class="headerlink" title="重发超时如何确定"></a>重发超时如何确定</h3><p><strong>重发超时</strong>指在重发数据之前，等待ACK的那个特定时间间隔，如果超过了这个时间还未收到ACK，发送端就进行数据重发。</p><p>最理想的时间是，找一个最小时间，能保证 <em><strong>确认应答一定能在这个时间内返回</strong></em>。但是TCP要求在任何网络环境下都要提供高性能通信，无论网络拥塞情况如何，都要保持这一特性。因此每次发包时都会计算<strong>往返时间（RTT）</strong>及其偏差，将这个RTT和偏差相加，重发超时的时间就是比这个总和稍微大一点的值。</p><p>在linux系统中，一般以0.5秒为单位进行控制。最初的数据包的重发超时一般设置为6s。<br>数据被重发之后还是收不到ACK，则进行再次重发，但是等待的时间以2倍，4倍指数函数进行增长。达到一定次数后，如果仍然欸有收到ACK，则通知应用通信异常，强行关闭。</p><h3 id="TCP以段为单位发送数据"><a href="#TCP以段为单位发送数据" class="headerlink" title="TCP以段为单位发送数据"></a>TCP以段为单位发送数据</h3><p>建立TCP连接的同时，可以确定发送数据包的单位，称其为<strong>最大消息长度</strong>(MSS)。最理想的情况时最大消息长度正好是IP中不会被分片处理的最大数据长度。</p><p>MSS实在三次握手的时候，在两端主机之间被计算得出。两端主机在建立连接的时候，在TCP首部写入MSS选项，告诉对方自己的接口能适应的MSS的大小，然后选一个较小的值使用。</p><h3 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h3><p>TCP以段为单位，每发一个段进行一次ACK的处理。但是这样一来，包的往返时间越长通信性能就越低。</p><p>于是乎，TCP引入<strong>窗口</strong>这个概念，即发送端主机，发送了一个段后不必一直等待ACK,而是继续发送。<br><strong>窗口大小</strong>就是指无需等待确认应答就可以继续阿松数据的最大值。这个机制实现使用了大量的<strong>缓冲区</strong>。<br>在窗口内的数据即便没有收到确认应答也可以发送出去。而在滑动窗口以外的部分包括尚未发送的数据以及已经确认对端已收到的数据。当数据发出后若收到确认则不必重发，此时数据就可以从缓冲区清除。<br>这种机制也被称为 <strong>滑动窗口控制</strong>。</p><h3 id="窗口控制与重发控制"><a href="#窗口控制与重发控制" class="headerlink" title="窗口控制与重发控制"></a>窗口控制与重发控制</h3><p>窗口控制时，若出现段丢失该怎么办？</p><ol><li><p><strong>确认应答未能返回的情况</strong><br>这种情况下，数据已经到达对端，不需要进行重发，窗口在一定程度上较大时，即使有少部分的确认应答丢失也不会进行数据重发。可以通过下一个确认应答进行确认。</p></li><li><p><strong>报文段丢失的情况</strong><br>当某一报文段丢失后，发送段会一直收到某个序号的ACK，同一个序号的ACK会被重复不断地返回。而发送端主机如果连续三次收到同一个ACK，就会将其对应的数据进行重发。这种机制被称为 <strong>高速重发控制</strong></p></li></ol><h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><p><strong>流控制</strong>是一种可以让发送端根据接收端的实际接收能力控制发送的数据量的机制。具体操作是接收端主机向发送店主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。该大小限度被称为<strong>窗口大小</strong>。</p><p>TCP首部中，专门有一个字段来通知窗口大小，<em><strong>这个字段的值越大，说明网络的吞吐量越高</strong></em>。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>一般来说，计算机网络都处在一个共享的环境，如果当其他主机之间的通信使得网络拥堵，此时如果突然发送大量的数据，极有可能导致网络瘫痪。</p><p>TCP为了防止此类问题的出现，通信一开始通过一个<strong>慢启动</strong>的算法，对发送数据量进行控制。</p><p>为了在发送端调节要发送的数据量，定义了一个<strong>拥塞窗口</strong>的概念。于是慢启动的时候，将这个拥塞窗口的大小设置为1个数据段发送数据，之后每收到一次ACK，拥塞窗口的值就加1。发送数据包时，将拥塞窗口的大小和接收端通知的窗口大小作比较，按照二者中的较小值，发送比其还要小的数据量。</p><blockquote><p>连续发包的情况也叫<strong>爆发（burst）</strong>，慢启动真是减少爆发等网络拥堵情况的一种机制。</p></blockquote><p>随着包的每次往返，拥塞窗口以指数函数增长，就有可能导致网络拥塞的发生，为了防止此类情况，引入<strong>慢启动阈值</strong>。只要拥塞窗口超过这个阈值，每次收到ACK时，只允许以如下比例放大拥塞窗口：$$\frac{1个数据段的字节数}{拥塞窗口(字节)}*1个数据段字节数$$</p><p>TCP通信开始时，并没有设置相应的慢启动阈值，而是在超时重发时，才会设置为当时拥塞窗口一半的大小。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/mobile-communication/">移动通信</category>
      
      
      <category domain="http://singlewang.top/tags/TCP/">TCP</category>
      
      <category domain="http://singlewang.top/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">拥塞控制</category>
      
      
      <comments>http://singlewang.top/2022/05/10/mobile-communication/TCP%E7%AA%97%E5%8F%A3/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
