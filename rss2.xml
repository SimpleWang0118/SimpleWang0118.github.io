<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Single Wang&#39;s Blog</title>
    <link>http://singlewang.top/</link>
    
    <atom:link href="http://singlewang.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>智者不入爱河，愚者重蹈覆辙</description>
    <pubDate>Thu, 09 Jun 2022 12:34:40 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>深入浅出dpdk-ch9硬件加速与功能卸载</title>
      <link>http://singlewang.top/2022/06/09/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch9/</link>
      <guid>http://singlewang.top/2022/06/09/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch9/</guid>
      <pubDate>Thu, 09 Jun 2022 11:22:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;硬件加速与功能卸载&quot;&gt;&lt;a href=&quot;#硬件加速与功能卸载&quot; class=&quot;headerlink&quot; title=&quot;硬件加速与功能卸载&quot;&gt;&lt;/a&gt;硬件加速与功能卸载&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;硬件的缺点：资源局限，功能固化，设计与发布的时间长，更新周</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="硬件加速与功能卸载"><a href="#硬件加速与功能卸载" class="headerlink" title="硬件加速与功能卸载"></a>硬件加速与功能卸载</h3><blockquote><p>硬件的缺点：资源局限，功能固化，设计与发布的时间长，更新周期长。</p></blockquote><h4 id="硬件卸载"><a href="#硬件卸载" class="headerlink" title="硬件卸载"></a>硬件卸载</h4><p>硬件卸载就是将某些功能下移到硬件实现。这些功能原先一般是由软件承担的。<br>对于专有网络设备，为了提高处理数据包的速度，常常将数据面与控制面分离。控制面主要对复杂的数据包进行复杂的控制处理，数据面就是进行简单类似的包处理。<br>基于专门设计的硬件，快速执行数据包的转发和一些简单的报文修改处理可以有效地提高数据的吞吐量和降低发送时延。</p><h4 id="DPDK软件接口"><a href="#DPDK软件接口" class="headerlink" title="DPDK软件接口"></a>DPDK软件接口</h4><p>网卡的硬件卸载功能可能是基于端口设置，也有可能是基于每个包使能设置，需要仔细区分。在包粒度而言，每个包都对应一个或者多个Mbuf，DPDK软件利用<code>rte_mbuf</code>数据结构里的64位的标识(<code>ol_flags</code>)来表征卸载和状态</p><h4 id="硬件与软件功能实现"><a href="#硬件与软件功能实现" class="headerlink" title="硬件与软件功能实现"></a>硬件与软件功能实现</h4><p>如果需要使用硬件卸载功能，网卡驱动需要提供相应的API给上层应用，通过调用API驱动硬件完成相应的工作。<br>硬件提供的接口一般包括寄存器(<code>Register</code>)和描述符(<code>Descriptor</code>)。寄存器是全局的设置，一般用于开启某项功能或者为某项功能设置全局性的参数配置。<br>描述符可以看作是每个数据包的属性，和数据包一起发送给硬件，一般用于携带单个数据包的参数或设置。<br>按照功能的相似性，硬件卸载功能大致可分为三类，分别是&#x3D;&#x3D;计算及更新功能&#x3D;&#x3D;、&#x3D;&#x3D;分片功能&#x3D;&#x3D;、&#x3D;&#x3D;组包功能&#x3D;&#x3D;。</p><h4 id="计算及更新功能卸载"><a href="#计算及更新功能卸载" class="headerlink" title="计算及更新功能卸载"></a>计算及更新功能卸载</h4><h5 id="VLAN硬件卸载"><a href="#VLAN硬件卸载" class="headerlink" title="VLAN硬件卸载"></a>VLAN硬件卸载</h5><p>VLAN只有四个字节，可以实现以太网中逻辑网络隔离功能。<br>如果由软件完成VLAN Tag的插入将给CPU带来额外的负荷，设计一次额外的内存拷贝。VLAN Tag的插入和剥离由网卡硬件完成，可以减轻服务器CPU的负荷。<br><strong>收包时VLAN Tag的过滤</strong><br>VLAN定义了虚拟网络，只有属于相同VLAN的报文，才需要被进一步处理，不属于VLAN的报文会被直接丢弃，网卡最典型的卸载功能之一就是在接收侧针对VLAN进行包过滤。比较典型的实现实在网卡硬件端口设计VLAN过滤表，无法在过滤表中匹配的VLAN包会被丢弃。<br><strong>收包时VLAN Tag的剥离</strong><br>网卡硬件能够对接收到的包的VLAN Tag进行剥离。首先硬件能够对VLAN包进行识别，之后需要在网卡端口的队列上设置使能标志，将剥离特性打开，对应到软件，是驱动写配置入相应的寄存器。网卡硬件会从此寄存器中提取配置信息，用于判断是否对收到的以太网数据进行VLAN剥离。<br>网卡硬件将4字节的VLAN Tag从数据包中剥离，但是 VLAN Tag不能丢弃。DPDK中，驱动对每个接收的数据包进行检测，会依据硬件描述符信息，如果剥离动作发生需要将<code>rte_mbuf</code>中的<code>PKT_RX_VLAN_PKT</code>置位，并且将被剥离的VLAN Tag写入下列字段，供上层使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span>&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> vlan_tci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>发包时VLAN Tag的插入</strong><br>VLAN Tag由两部分组成：<code>TPID(Tag Protocol Identifier)</code>，也就是VLAN的<code>Ether type</code>,和<code>TCI(Tag Control Information)</code>。TPID是一个固定的值，作为一个全局范围内起作用的值，可以通过寄存器进行设置。TCI是每个包相关的，需要逐包设置，在DPDK中，在调用发送函数前，必须提前设置mbuf数据结构。</p><h4 id="分片功能卸载"><a href="#分片功能卸载" class="headerlink" title="分片功能卸载"></a>分片功能卸载</h4><p><strong>TSO</strong><br><code>TSO(TCP Segment Offload)</code>是TCP分片功能的硬件卸载，是发送方向的功能。对于从应用层获取的较大的数据，TCP需要根据下层网络的报文大小限制，将其切分成较小的分片发送。<br>硬件提供的TCP分片硬件卸载功能可以大幅减轻软件对TCP分片的负担。<br>在dpdk&#x2F;testpmd中提供了两条TSO相关的命令行：</p><ol><li>tso set 14000:用于设置tso分片大小</li><li>tso show 0：用于查看tso分片大小</li></ol><h4 id="组包功能卸载"><a href="#组包功能卸载" class="headerlink" title="组包功能卸载"></a>组包功能卸载</h4><p><strong>RSC</strong><br><code>RSC(Receive Side Coalescing，接收方聚合)</code>是TCP组包功能的硬件卸载。硬件组包功能实际上是硬件拆包功能的逆向功能。属于接收方向的功能，可以将拆分的TCP分片聚合成一个大的分片，从而减轻软件的处理。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/">硬件加速</category>
      
      
      <comments>http://singlewang.top/2022/06/09/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>VLAN基本知识</title>
      <link>http://singlewang.top/2022/05/31/mobile-communication/VLAN/</link>
      <guid>http://singlewang.top/2022/05/31/mobile-communication/VLAN/</guid>
      <pubDate>Tue, 31 May 2022 13:21:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;什么是VLAN&quot;&gt;&lt;a href=&quot;#什么是VLAN&quot; class=&quot;headerlink&quot; title=&quot;什么是VLAN&quot;&gt;&lt;/a&gt;什么是VLAN&lt;/h2&gt;&lt;p&gt;&lt;code&gt;VLAN(Virtual Local Area Network)&lt;/code&gt;即虚拟局域</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="什么是VLAN"><a href="#什么是VLAN" class="headerlink" title="什么是VLAN"></a>什么是VLAN</h2><p><code>VLAN(Virtual Local Area Network)</code>即虚拟局域网，是将一个物理的LAN再逻辑上划分成多个广播域的通信技术。<br>每个VLAN是一个广播域，VLAN内的主机间可以直接通信，而VLAN间不能直接互通。这样广播报文就被限制在一个VLAN内。</p><h2 id="为什么需要VLAN"><a href="#为什么需要VLAN" class="headerlink" title="为什么需要VLAN"></a>为什么需要VLAN</h2><p>早期以太网是一种基于CSMA&#x2F;CD（Carrier Sense Multiple Access&#x2F;Collision Detection）的共享通讯介质的数据网络通讯技术。当主机数目较多时会导致冲突严重、广播泛滥、性能显著下降甚至造成网络不可用等问题。通过二层设备实现LAN互连虽然可以解决冲突严重的问题，但仍然不能隔离广播报文和提升网络质量。</p><p>在这种情况下出现了VLAN技术。这种技术可以把一个LAN划分成多个逻辑的VLAN，每个VLAN是一个广播域，VLAN内的主机间通信就和在一个LAN内一样，而VLAN间则不能直接互通，广播报文就被限制在一个VLAN内。</p><p>VLAN的优点：</p><ul><li><strong>限制广播域</strong>：广播域被限制在一个VLAN内，节省了带宽，提高了网络处理能力。</li><li><strong>增强局域网的安全性</strong>：不同VLAN内的报文在传输时相互隔离，即一个VLAN内的用户不能和其它VLAN内的用户直接通信。</li><li><strong>提高了网络的健壮性</strong>：故障被限制在一个VLAN内，本VLAN内的故障不会影响其他VLAN的正常工作。</li><li><strong>灵活构建虚拟工作组</strong>：用VLAN可以划分不同的用户到不同的工作组，同一工作组的用户也不必局限于某一固定的物理范围，网络构建和维护更方便灵活。</li></ul><h2 id="VLAN与子网"><a href="#VLAN与子网" class="headerlink" title="VLAN与子网"></a>VLAN与子网</h2><p><strong>区别</strong></p><ol><li>VLAN用于划分二层网络，子网用于划分三层网络</li><li>VLAN在配置VLANIF接口的基础上实现路由互通后，属于不同VLAN用户才能互访；子网只要通过路由实现网络互通，属于不同子网的用户就能互访</li><li>VLAN内的设备数量不受限制；子网划分的网段会影响各个子网内的设备最大数</li></ol><p><strong>联系</strong></p><ul><li>同一个VLAN内可以划分一个或多个网段，同一子网内，可以划分一个或多个VLAN。</li></ul><h2 id="VLAN的基本概念"><a href="#VLAN的基本概念" class="headerlink" title="VLAN的基本概念"></a>VLAN的基本概念</h2><h3 id="VLAN-Tag"><a href="#VLAN-Tag" class="headerlink" title="VLAN Tag"></a>VLAN Tag</h3><p>为了使设备能够分辨不同VLAN的报文，需要在报文中添加VLAN信息的字段。802.11Q协议规定，在以太网数据帧的目的MAC地址和源MAC地址字段之后、协议类型字段之前加入四个字节的VLAN tag，用来标识VLAN信息。</p><h3 id="VLAN帧格式"><a href="#VLAN帧格式" class="headerlink" title="VLAN帧格式"></a>VLAN帧格式</h3><table><thead><tr><th align="center">Destination address</th><th align="center">Source address</th><th align="center">VLAN tag</th><th align="center">length&#x2F;type</th><th align="center">Data</th><th align="center">FCS</th></tr></thead><tbody><tr><td align="center">6Byte</td><td align="center">6Byte</td><td align="center">4Byte</td><td align="center">2Byte</td><td align="center">46-1500Byte</td><td align="center">4Byte</td></tr></tbody></table><p>VLAN tag包括TPID（数据帧类型）、PRI（数据帧的优先级，0~7，值越大优先级越高）、CFI（标准格式指示位）、VID（VLAN ID）</p><blockquote><p>设备利用VLAN标签中的VID来识别数据帧所属的VLAN,广播帧只在同一VLAN内转发，这就将广播域限制在一个VLAN内。VLAN ID取值范围使0<del>4095，有效范围使1</del>4094。</p></blockquote><h3 id="链路类型和接口类型"><a href="#链路类型和接口类型" class="headerlink" title="链路类型和接口类型"></a>链路类型和接口类型</h3><p>在一个VLAN交换网络中，以太网帧主要有以下两种格式：</p><ul><li><strong>有标记帧（Tagged帧）</strong>：加入了4字节VLAN标签的帧</li><li><strong>无标记帧（untagged帧）</strong>：原始的、未加入4字节VLAN标签的帧</li></ul><p>设备内部处理的数据帧一律都是Tagged帧。</p><p>为了适应不同的连接和组网，设备定义了<strong>Access</strong>接口、<strong>Trunk</strong>接口、<strong>Hybrid</strong>接口，以及<strong>接入链路（Access Link）</strong>和<strong>干道链路（Trunk Link）</strong>。</p><h4 id="链路类型"><a href="#链路类型" class="headerlink" title="链路类型"></a>链路类型</h4><p>根据链路中需要承载的VLAN数目的不同，以太网链路分为：</p><ul><li>接入链路<br>接入链路只可以承载1个VLAN的数据帧，用于连接设备和用户终端，用户终端并不需要知道自己属于哪个VLAN，也不能识别带有Tag的帧，所以在接入链路上传输的帧都是untagged帧</li><li>干道链路<br>干道链路可以承载多个不同VLAN的数据帧，用于设备间互联。因此需要给数据帧加VLAN Tag。</li></ul><h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h4><p>根据接口连接对象以及对收发数据帧处理的不同，以太网接口分别为：</p><ul><li>Access接口<br>Access接口一般用于和不能识别Tag的用户终端相连，或者不需要区分不同VLAN成员时使用，只能收发Untagged帧。</li><li>Trunk接口<br>Trunk接口一般用于连接交换机、路由器、AP以及可同时收发Tagged帧和Untagged帧的语音终端。它可以允许多个VLAN的帧带Tag通过，但只允许一个VLAN的帧从该类接口上发出时不带Tag。</li><li>Hybrid接口<br>Hybrid接口同时综合了以上两种接口的方式，且允许从该类接口发出的某些帧带Tag，某些帧不带Tag。</li></ul>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/mobile-communication/">移动通信</category>
      
      
      <category domain="http://singlewang.top/tags/VLAN/">VLAN</category>
      
      
      <comments>http://singlewang.top/2022/05/31/mobile-communication/VLAN/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch7多队列与流分类</title>
      <link>http://singlewang.top/2022/05/31/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch8/</link>
      <guid>http://singlewang.top/2022/05/31/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch8/</guid>
      <pubDate>Tue, 31 May 2022 11:28:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;流分类与多队列&quot;&gt;&lt;a href=&quot;#流分类与多队列&quot; class=&quot;headerlink&quot; title=&quot;流分类与多队列&quot;&gt;&lt;/a&gt;流分类与多队列&lt;/h3&gt;&lt;h4 id=&quot;多队列&quot;&gt;&lt;a href=&quot;#多队列&quot; class=&quot;headerlink&quot; title=</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="流分类与多队列"><a href="#流分类与多队列" class="headerlink" title="流分类与多队列"></a>流分类与多队列</h3><h4 id="多队列"><a href="#多队列" class="headerlink" title="多队列"></a>多队列</h4><h5 id="网卡多队列的由来"><a href="#网卡多队列的由来" class="headerlink" title="网卡多队列的由来"></a>网卡多队列的由来</h5><p>网卡多队列技术是一个硬件手段，利用该技术，可以做到分而治之。比如视频数据强调实时性，对数据的准确性要求不高，这样我们可以为其队列设置更高的发送优先级，或者说使用更高优先级的队列，为了达到较好的实时性，我们可以减小队列对应的带宽。</p><h5 id="Linux内核对多队列的支持"><a href="#Linux内核对多队列的支持" class="headerlink" title="Linux内核对多队列的支持"></a>Linux内核对多队列的支持</h5><ol><li>多队列对应的结构<br>Linux的网卡由结构体<code>net_device</code>表示，一个该结构体 可对应多个可以调度的数据包发送队列，数据包的实体在内核中以结构体<code>sk_buff（skb）</code>表示。</li><li>接收端<br>网卡驱动程序为每个接收队列设定相应的中断号，通过中断的均衡处理，或者设置中断的亲和性（<code>SMP IRQ Affinity</code>）,从而实现队列绑定到不同的核。</li><li>发送端<br><code>dev_pick_tx</code>用于选取发送队列，可以是driver定制的策略，也可以根据队列优先级选取，按照hash来做均衡。也就是利用<code>XPS(Transmit Packet Steering)</code>机制，智能地选择多队列设备的队列来发送数据包。</li><li>收发队列一般会被绑在同一个中断上。如果从收队列1收上来的包从发队列1发出去，cache命中率高，效率也会高。</li></ol><h5 id="DPDK与多队列"><a href="#DPDK与多队列" class="headerlink" title="DPDK与多队列"></a>DPDK与多队列</h5><p>再某个核上运行的程序从指定的队列上接收，往指定的队列上发送，可以达到很高的cache命中率，效率就会更高。<br>以<code>run to completion</code>为例，可以从核、内存与网卡队列之间的关系来理解DPDK是如何利用网卡多队列技术带来性能的提升。</p><ul><li>将网卡的某个接收队列分配给某个核，从该队列中收到的所有报文都应当在该指定的核上处理结束。</li><li>从核对应的本地存储中分配内存池，接收报文和对应的报文描述符都位于该核和发送队列对应的本地内存池中。</li><li>为每个核分配一个单独的发送队列，发送报文核对应的报文描述符都位于该核和发送队列对应的本地内存池中。</li></ul><p>不同的核，操作的是不同的队列，从而避免了多个线程同时访问一个队列带来的锁的开销。但是如果逻辑核的数目大于每个接口上所含的发送队列的数目，那么就需要有机制将队列分配给这些核。</p><h5 id="队列分配"><a href="#队列分配" class="headerlink" title="队列分配"></a>队列分配</h5><p>包的接收从网卡侧来看分为以下几步：</p><ol><li>监听到线上的报文。</li><li>按照地址过滤报文。</li><li>DMA队列分配。</li><li>将报文暂存在接收数据的先进先出缓存中。</li><li>将报文转移到主存中的指定队列中。</li><li>更新接收描述符的状态。</li></ol><h4 id="流分类"><a href="#流分类" class="headerlink" title="流分类"></a>流分类</h4><h5 id="包的类型"><a href="#包的类型" class="headerlink" title="包的类型"></a>包的类型</h5><p>对于DPDK而言，Mbuf结构中含有相应的字段来表示网卡分析出的包的类型，<code>Packet_type</code>由二层，三层，四层以及tunnel的信息组成。<br>网卡设备同时可以根据报的类型确定其关键字，从而根据关键字确定其收包队列。</p><blockquote><p>不是所有网卡都支持这项功能，支持功能的复杂度也有差异</p></blockquote><h5 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h5><p>负载均衡就是将负载分摊到多个执行单元上执行，对于<code>Packet IO</code>而言，就是将数据包收发处理分摊到多个核上。<br><code>RSS（Receive-Side Scaling）</code>接收方扩展技术可以将流量分散到不同的队列中的技术。它和硬件相关联，必须要有网卡的硬件进行支持。RSS把数据包分配到不同的队列中。<br>简单的说RSS就是根据关键字通过哈希函数计算出哈希值，再由哈希值确定队列。网卡会根据不同的数据包类型选取出不同的关键字。<br>RSS是否能将数据包均匀散开再多个队列中，取决于真实环境中的数据包构成和哈希函数的选取。哈希函数一般选取微软的托普利兹算法。</p><h5 id="服务质量"><a href="#服务质量" class="headerlink" title="服务质量"></a>服务质量</h5><p>多队列应用于服务质量（Qos）流量类别：</p><ul><li>把发送队列分配给不同的流量类别，可以让网卡再发送侧做调度</li><li>把收包队列分配给不同的流量类别，可以做到基于流的限速</li></ul><h5 id="流过滤"><a href="#流过滤" class="headerlink" title="流过滤"></a>流过滤</h5><p>流的合法性验证的主要任务是决定哪些数据包是合法的、可被接收的。&#x3D;&#x3D;合法性检查主要包括对外部来的流和内部流的验证&#x3D;&#x3D;<br>可以被接收的数据包会被网卡送到主机或者网卡内置的管理控制器，其过滤主要集中再以太网的二层功能，包括VLAN及MAC过滤。<br>流的过滤可以分为以下几步：</p><ol><li>MAC地址的过滤（L2Filter）</li><li>VLAN标签的过滤</li><li>管理数据包的过滤</li></ol>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E6%B5%81%E5%88%86%E7%B1%BB/">流分类</category>
      
      
      <comments>http://singlewang.top/2022/05/31/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WIFI基本知识</title>
      <link>http://singlewang.top/2022/05/30/mobile-communication/WIFI%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</link>
      <guid>http://singlewang.top/2022/05/30/mobile-communication/WIFI%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</guid>
      <pubDate>Mon, 30 May 2022 11:47:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;WIFI的连接过程&quot;&gt;&lt;a href=&quot;#WIFI的连接过程&quot; class=&quot;headerlink&quot; title=&quot;WIFI的连接过程&quot;&gt;&lt;/a&gt;WIFI的连接过程&lt;/h2&gt;&lt;p&gt;一般如果STA要和AP建立连接，要经过三个阶段才能够接入：&lt;/p&gt;
&lt;ol&gt;
&lt;li</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="WIFI的连接过程"><a href="#WIFI的连接过程" class="headerlink" title="WIFI的连接过程"></a>WIFI的连接过程</h2><p>一般如果STA要和AP建立连接，要经过三个阶段才能够接入：</p><ol><li>扫描阶段(SCAN)</li><li>认证关联(Authentication)</li><li>关联(Association)</li></ol><h3 id="WIFI扫描"><a href="#WIFI扫描" class="headerlink" title="WIFI扫描"></a>WIFI扫描</h3><p>STA在加入任何网络之前必须识别现有网络，这个过程称为扫描，扫描又分为 <strong>主动扫描</strong> 和 <strong>被动扫描</strong>。</p><ol><li>主动扫描：STA会在每个信道上发出<code>Probe request</code>,携带相关的SSID信息，寻找相同SSID的AP，若找不到，一直扫描下去，找到后等待接收<code>Probe response</code>。</li><li>被动扫描：STA会在各个信道之间不断切换，通过监听AP定期发送的<code>Beacon</code>帧来发现网络，<code>Beacon</code>帧标示了相关的BSS信息（可以理解为对应的路由器的信息就是BSS信息）</li></ol><p>选网原则：</p><ul><li>选择相同SSID的网络做认证</li><li>优先选择信号强度最强或最近使用的网络</li></ul><h3 id="WIFI认证"><a href="#WIFI认证" class="headerlink" title="WIFI认证"></a>WIFI认证</h3><blockquote><p>只有通过STA和AP之间的认证，才能进一步接入无线网络<br>认证可以通过MAC地址认证，或者用户名和密码口令认证</p></blockquote><p>认证的方式有两种：</p><ol><li>开放式认证：STA发送认证请求，AP直接通过认证请求，安全风险较高</li><li>共享密钥认证：STA向AP 发送认证请求，AP随机产生字符串，STA接收到字符串后进行密钥加密后发给AP，AP收到信息后用密钥解密得到随机字符串，如果AP判断字符串与原始发的字符串相同，则认证通过。</li></ol><h3 id="WIFI关联"><a href="#WIFI关联" class="headerlink" title="WIFI关联"></a>WIFI关联</h3><p>STA一旦完成身份认证，便可以发送<code>Association Request</code>,请求获得网络的完全访问权。关联能让AP记录每个STA的位置，以便将帧正确送达。</p><ul><li>STA与AP认证成功后，就可以向AP发送关联请求</li><li>AP将STA的信息添加到数据库，并向STA发出关联响应，则注册成功，完成关联</li><li>关联建立后，即可接入无线网络，实现数据通信</li><li>当STA需要接入新的网络时，需要去关联后，重新认证，和新AP再关联。</li><li>每个STA只能关联到一个AP，但是关联总是由STA发起。</li></ul><p><strong>去关联</strong>是一个单向的，无需确认的过程，可由STA发起也可以由AP发起。只需发送一个通知性质的<code>deauth</code>帧或者<code>disassoc</code>帧，因此容易造成状态不同步</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/mobile-communication/">移动通信</category>
      
      
      <category domain="http://singlewang.top/tags/WIFI/">WIFI</category>
      
      
      <comments>http://singlewang.top/2022/05/30/mobile-communication/WIFI%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux中断和定时器</title>
      <link>http://singlewang.top/2022/05/24/linux/linux-kernal/linux-kernal-driver/Linux%E4%B8%AD%E6%96%AD%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <guid>http://singlewang.top/2022/05/24/linux/linux-kernal/linux-kernal-driver/Linux%E4%B8%AD%E6%96%AD%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <pubDate>Tue, 24 May 2022 13:27:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;中断与定时器&quot;&gt;&lt;a href=&quot;#中断与定时器&quot; class=&quot;headerlink&quot; title=&quot;中断与定时器&quot;&gt;&lt;/a&gt;中断与定时器&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;中断&lt;/strong&gt;：指CPU在指向程序的过程中，出现某些突发事件时，CPU必须暂停执行当</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="中断与定时器"><a href="#中断与定时器" class="headerlink" title="中断与定时器"></a>中断与定时器</h3><p><strong>中断</strong>：指CPU在指向程序的过程中，出现某些突发事件时，CPU必须暂停执行当前的程序，转去处理突发事件，处理完毕后又返回原程序被中断的位置并继续执行。</p><ul><li>根据中断的来源可分为：</li></ul><ol><li>内部中断：中断源来自CPU内部，如软件中断指令、溢出等。</li><li>外部中断：中断源来自CPU外部，由外设请求</li></ol><ul><li>根据是否可以屏蔽分为：</li></ul><ol><li>可屏蔽中断：通过屏蔽字相应，屏蔽后，该中断不再得到相应</li><li>不屏蔽中断：不能被屏蔽</li></ol><ul><li>根据中断入口跳转方法不同，可分为：</li></ul><ol><li>向量中断：CPU通常为不同的中断分配不同的中断号。（硬件）</li><li>非向量中断：多个中断共享一个入口地址，进入该入口地址后再通过软件判断中断标志来识别具体哪个中断。（软件）</li></ol><h3 id="Linux中断编程"><a href="#Linux中断编程" class="headerlink" title="Linux中断编程"></a>Linux中断编程</h3><h4 id="申请和释放中断"><a href="#申请和释放中断" class="headerlink" title="申请和释放中断"></a>申请和释放中断</h4><ol><li>申请irq<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">                <span class="type">void</span> (*handler)(<span class="type">int</span> irq.<span class="type">void</span> *dev_id,<span class="keyword">struct</span> pt_regs *regs),</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">char</span> * devname,</span></span><br><span class="line"><span class="params">                <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure>irq是要申请的硬件中断号。<br>handler是向系统等级的中断处理函数，是一个回调函数。<br>irqflags是中断处理的属性<blockquote><p>SA_INTERRUPT 表示中断处理程序是快速处理程序<br>SA_SHIRQ 表示多个设备共享中断<br>request_irq()返回0表示成功，返回-INVAL表示中断号无效或函数指针为NULL，返回-EBUSY表示中断已经被占用。</p></blockquote></li></ol><p>2.释放IRQ</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,<span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure><h4 id="使能和屏蔽中断"><a href="#使能和屏蔽中断" class="headerlink" title="使能和屏蔽中断"></a>使能和屏蔽中断</h4><p>以下三个函数用于屏蔽一个中断源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">disable_irq</span><span class="params">(<span class="type">int</span> irq)</span>; <span class="comment">//立即返回</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_irq_nosync</span><span class="params">(<span class="type">int</span> irq)</span>; <span class="comment">//等待目前的中断处理完成</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_irq</span><span class="params">(<span class="type">int</span> irq)</span>; <span class="comment">//作用与可编程中断控制器，对系统内的所有CPU都生效。</span></span><br></pre></td></tr></table></figure><p>以下两个函数将屏蔽本CPU内的所有中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">local_irq_save</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> falgs)</span>;<span class="comment">//将目前的中断状态保留在flags中。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">local_irq_diasble</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//直接禁止中断</span></span><br></pre></td></tr></table></figure><p>恢复中断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">local_irq_restore</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">local_irq_enable</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>硬中断、软中断、信号的区别：</p><ol><li>硬中断是外部设备对&#x3D;&#x3D;CPU&#x3D;&#x3D;的中断</li><li>软中断通常是硬中断服务程序对&#x3D;&#x3D;内核&#x3D;&#x3D;的中断</li><li>信号则是由内核对某个&#x3D;&#x3D;进程&#x3D;&#x3D;的中断</li></ol><h3 id="内核定时器"><a href="#内核定时器" class="headerlink" title="内核定时器"></a>内核定时器</h3><h4 id="内核定时器编程"><a href="#内核定时器编程" class="headerlink" title="内核定时器编程"></a>内核定时器编程</h4><p>软件意义上的定时器最终依赖硬件定时器来实现，内核在时钟中断发生后检测各定时器是否到期，到期后的定时器处理函数将作为软中断在底半部执行。</p><p>linux内核所提供的用于操作定时器的数据结构和函数如下：</p><ol><li>timer_list</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span> <span class="comment">//定时器列表</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires; <span class="comment">//定时器到期时间</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">//定时器处理函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;  <span class="comment">//作为参数被传入</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_base_s</span> *<span class="title">base</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">my_timer</span>;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>初始化定时器<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span>;</span><br></pre></td></tr></table></figure></li></ol><p><code>TIMER_INITIALIZER(_function,_expires,_data)</code>宏用于赋值定时结构体的function、expires、data、base成员。</p><ol start="3"><li><p>增加定时器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span>; <span class="comment">//注册内核定时器，将定时器加入到内核动态定时器链表中。</span></span><br></pre></td></tr></table></figure></li><li><p>删除定时器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">del_timer</span><span class="params">(sturct timer_list * timer)</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="内核延时"><a href="#内核延时" class="headerlink" title="内核延时"></a>内核延时</h3><h4 id="短延时"><a href="#短延时" class="headerlink" title="短延时"></a>短延时</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ndelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nsecs)</span>; <span class="comment">//纳秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">udelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> usecs)</span>; <span class="comment">//微秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mdelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span>; <span class="comment">//毫秒</span></span><br></pre></td></tr></table></figure><p>在内核中，最好不要直接使用毫秒级别的延时，这将无所谓地耗费CPU资源。对于毫秒级以上地时延，内核提供了下述函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">msleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>; <span class="comment">//不能被打断</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">msleep_interruptible</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>; <span class="comment">//可以被打断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ssleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>; <span class="comment">//不能被打断</span></span><br></pre></td></tr></table></figure><h4 id="长延时"><a href="#长延时" class="headerlink" title="长延时"></a>长延时</h4><p>内核中进行延时地很直观地方法时比较当前地jiffies和目标jiffies，知道未来地jiffies达到目标jiffies。</p><h4 id="睡着延时"><a href="#睡着延时" class="headerlink" title="睡着延时"></a>睡着延时</h4><p>睡着延时比忙等待更好，随着延迟在等待地时间到来之间进程处于睡眠状态，CPU资源被其他进程使用。<code>schedule_timeout()</code>可以使当前任务睡眠指定地jiffies之后重新被调度执行。<br>实际上<code>schedule_timeout()</code>地实现原理时向系统添加一个定时器，在定时器处理函数中唤醒参数对应地进程。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/linux-kernal-driver/">Linux内核驱动</category>
      
      
      <category domain="http://singlewang.top/tags/Linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/">Linux网络设备</category>
      
      <category domain="http://singlewang.top/tags/Linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/">Linux内核驱动</category>
      
      
      <comments>http://singlewang.top/2022/05/24/linux/linux-kernal/linux-kernal-driver/Linux%E4%B8%AD%E6%96%AD%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我真的有机会被爱吗</title>
      <link>http://singlewang.top/2022/05/20/informal-essay/life/520%E9%9A%8F%E6%83%B3/</link>
      <guid>http://singlewang.top/2022/05/20/informal-essay/life/520%E9%9A%8F%E6%83%B3/</guid>
      <pubDate>Fri, 20 May 2022 03:06:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;红豆生南国，&lt;br&gt;春来发几枝。&lt;br&gt;愿君多采撷，&lt;br&gt;此物最相思。&lt;br&gt;         –《相思》唐·王维&lt;br&gt;讲真，这个标题属实有点矫情了，但是仔细一想，其实也没那么肉麻，更多的是基于我目前现状的一种感叹吧。&lt;br&gt;今天恰好是5月20日，也就是不知道从什么时候</description>
        
      
      
      
      <content:encoded><![CDATA[<p>红豆生南国，<br>春来发几枝。<br>愿君多采撷，<br>此物最相思。<br>         –《相思》唐·王维<br>讲真，这个标题属实有点矫情了，但是仔细一想，其实也没那么肉麻，更多的是基于我目前现状的一种感叹吧。<br>今天恰好是5月20日，也就是不知道从什么时候演变成一个节日的日期，在这一天，朋友圈，微博无处不在秀着各自的恩爱，在从前我还会有些许的羡慕，羡慕情侣之间的浪漫，也曾幻想着自己也能和自己心爱的姑娘在这一天过着属于自己二人世界，可如今我的羡慕之情却已暗淡，因为不知道什么时候起，爱情对我来说就像是不存在一般，仿佛神话故事中那些未曾见过的神兽般虚无缥缈。我不知道自己是否还需要它，因为就目前我的现状来看自己好像也并不是没它不行，一个人的生活也很潇洒，但是看着路边的情侣卿卿我我，也不免会从心底有一丝孤单。<br>我是一个沉默寡言的人，性格随和却又内向，想起昨天玩游戏的时候，碰见一对情侣很有意思，一边聊天一边玩，说找对象要靠口才，乍一听好像有些片面了，但是仔细想想，许多时候人们的邂逅不就是第一次打招呼开始吗，现实中那些滔滔不绝，口若悬河的人也往往更能获得女生的关注，而我则可能呆在角落里看他们嬉戏打闹，我并不是不想参与，只是性格的原因导致我放不开，看见一个心动的女生也不敢上前打招呼，唯一一个令自己心动了那么多年的女生还在前不久和我断联，只能说是我咎由自取吧。但是老实话少就该被嫌弃吗，又或者说得不到关注，说到这儿又想起实验室即将毕业的学长，和他女朋友谈了几年了，工作也找好了，华为的一年40多w，能力强，却在前不久分手了，女方给出的原因是他太没有情趣了，随后就和另一个男生无缝衔接（我也只是听实验室的同学所说），女生的脑回路真的想不明白，当然每个人都有自己的选择，孰是孰非作为一个旁观者不好做评论，只是为这个学长感到不值罢了。<br>我曾经给我爸妈说过，我反正是不会走相亲这条路的。如果找不到互相喜欢的，那就这样一个人挺好的，努力赚钱，做自己想做的事，虽然知道对不起爸妈，但是我实在不想在感情这件事上妥协，我实在做不到和一个自己不喜欢的人去共度余生，那真的会是一场灾难。我不是不想谈，只是不想抱着试一试的态度去谈了。<br>昨晚莫名其妙又梦见她了，也不知道她现在过的怎样，我努力克制自己不去想她，让自己变得忙碌起来，大概两个月的时间没有想她，可是昨晚又做了一个很清晰的梦，让我不愿醒来。渐渐的我也想开了，有些人并不一定非要在一起，遇见已经是最好的结果了。</p><p>今天就随便写写，感情这事遇见了说明是缘分，遇不见也可能是缘分未到，只能不断的提升自己，静待花开。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/informal-essay/">随笔</category>
      
      <category domain="http://singlewang.top/categories/informal-essay/life/">生活感悟</category>
      
      
      <category domain="http://singlewang.top/tags/%E5%BF%83%E5%BE%97/">心得</category>
      
      <category domain="http://singlewang.top/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/">生活感悟</category>
      
      
      <comments>http://singlewang.top/2022/05/20/informal-essay/life/520%E9%9A%8F%E6%83%B3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch7网卡性能优化</title>
      <link>http://singlewang.top/2022/05/17/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch7/</link>
      <guid>http://singlewang.top/2022/05/17/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch7/</guid>
      <pubDate>Tue, 17 May 2022 12:49:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;网卡性能优化&quot;&gt;&lt;a href=&quot;#网卡性能优化&quot; class=&quot;headerlink&quot; title=&quot;网卡性能优化&quot;&gt;&lt;/a&gt;网卡性能优化&lt;/h3&gt;&lt;h4 id=&quot;DPDK的轮询模式&quot;&gt;&lt;a href=&quot;#DPDK的轮询模式&quot; class=&quot;headerlink</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="网卡性能优化"><a href="#网卡性能优化" class="headerlink" title="网卡性能优化"></a>网卡性能优化</h3><h4 id="DPDK的轮询模式"><a href="#DPDK的轮询模式" class="headerlink" title="DPDK的轮询模式"></a>DPDK的轮询模式</h4><p>DPDK采用了轮询或者轮询混杂中断的模式来进行收包和发包，此 前主流运行在操作系统内核态的网卡驱动程序基本都是基于异步中断处理模式。</p><h5 id="异步中断模式"><a href="#异步中断模式" class="headerlink" title="异步中断模式"></a>异步中断模式</h5><p>当有包进入网卡收包队列后，网卡会产生硬件中断，进而触发CPU中断，进入中断服务程序，在中断服务程序中完成收包的处理。<br>基于异步中断信号处理模式的收包，不断地在做中断处理，在CPU比I&#x2F;O速率高很多时，处理地负荷可以被忽略，但是如果是高速网卡且I&#x2F;O频繁，开销就会很大。中断是异步方式，因此CPU无需等待，有效利用率高。<br>当有包需要发送出去地时候，基于异步中断信号地驱动程序会准备奥需要发送地包，配置号发送队列地各个描述符。包被真正发送完成时，网卡同样会产生硬件中断信号，进而触发CPU中断，进入中断服务。</p><h5 id="轮询模式"><a href="#轮询模式" class="headerlink" title="轮询模式"></a>轮询模式</h5><p>DPDK最初地纯轮询模式指收发包完全不使用任何中断，集中所有运算资源用于报文处理，但这不是意味着DPDK部可以支持任何中断。</p><p>DPDK所有地收发包有关的中断在物理端口初始化的时候都会关闭，也就是说，CPU在任何时候都不会收到中断。</p><p>每一个收包队列，DPDK都会有一个对应的软件线程负责轮询里面的收包描述符的收包成功的标志。一旦发现某一个收包描述符的收包成功标志被硬件置位了，驱动程序会解析相应的收包描述符，提取各种有用的信息，然后填充对应的缓冲内存块头部。然后把收包缓冲内存块存放到收包函数提供的数组里面，同时分配好一个新的缓冲内存块给这个描述符，以便下一次收包。</p><p>每一个发包队列，DPDK都会有一个对应的软件线程负责设置需要发送出去的包，DPDK的驱动程序负责提取发包缓冲内存块的有效信息。DPDK的轮询驱动程序根据内存缓存块中的包的内容来负责初始化好每一个发包描述符，驱动程序会把每个包翻译成为一个或者多个发包描述符里能够理解的内容，然后写入发包描述符。最关键的有两个，一个是标识完整的包结束的标志<code>EOP(End Of Packet)</code>,另一个就是请求报告发送状态<code>RS(Report Status)</code>。EOP就是驱动程序用来通知网卡硬件一个完整的包结束的标志。RS是驱动程序告诉网卡什么时候需要报告发送结果的标志。</p><p>发包的轮询就是轮询发包结束的硬件标志位。</p><h5 id="混合中断轮询模式"><a href="#混合中断轮询模式" class="headerlink" title="混合中断轮询模式"></a>混合中断轮询模式</h5><p>由于实际网络应用中可能存在的潮汐效应，在某些时间段网络数据流量可能很低，甚至完全没有需要处理的包，这样就会出现在高速端口下低负荷运行的场景，而完全轮询的方式会让处理器一直全速运行，明显浪费处理能力和不节能。<br>因此DPDK引入了收包中断与轮询的混合模式的支持，用户可以根据实际应用场景来选择完全轮询模式，或者混合中断轮询模式。<br>PDK的混合中断轮询机制是基于UIO或VFIO来实现其收包中断通知与处理流程的。如果是基于VFIO的实现，该中断机制是可以支持队列级别的，即一个接收队列对应一个中断号，这是因为VFIO支持多MSI-X 中断号。但如果是基于UIO的实现，该中断机制就只支持一个中断号，所有的队列共享一个中断号。</p><h4 id="网卡I-x2F-O性能优化"><a href="#网卡I-x2F-O性能优化" class="headerlink" title="网卡I&#x2F;O性能优化"></a>网卡I&#x2F;O性能优化</h4><h5 id="Burst收发包的优点"><a href="#Burst收发包的优点" class="headerlink" title="Burst收发包的优点"></a>Burst收发包的优点</h5><p>Burst收发包是DPDK的优化模式，它把收发包复杂的处理过程进行分解，使之成为相对较小的处理阶段，把相邻的数据访问、相似的数据运算集中处理。</p><p>Burst可以理解为突发模式，是一次完成多个数据包的收发，由DPDK函数调用者来决定。</p><p>网卡的收发包描述符一般为16或32字节，而网卡对收包描述符的回写都会一次处理4个或者8个。处理器缓存的预取机制会每次存取相邻的多个缓存单位，Burst充分利用这种机制，明显提高收发包效率。</p><p>Burst收发包是DPDK普遍使用的软件接口，用户可以设定每次收发包函数调用所处理的包的个数，具体函数接口如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">rte_eth_rx_burst</span><span class="params">(<span class="type">uint8_t</span> port_id,<span class="type">uint16_t</span> queue_id,<span class="keyword">struct</span> rte_mbuf  **rx_pkts,<span class="type">const</span> <span class="type">uint16_t</span> nb_pkts)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">rte_eth_tx_burst</span><span class="params">(<span class="type">uint8_t</span> port_id,<span class="type">uint16_t</span> queue_id,<span class="keyword">struct</span> rte_mbuf  **tx_pkts,<span class="type">const</span> <span class="type">uint16_t</span> nb_pkts)</span>;</span><br></pre></td></tr></table></figure><h5 id="批处理和时延隐藏"><a href="#批处理和时延隐藏" class="headerlink" title="批处理和时延隐藏"></a>批处理和时延隐藏</h5><p><strong>时延</strong>：处理器核心执行单元完成一条指令所需要的时钟周期数<br><strong>吞吐</strong>：处理器指令发射端口再次允许接受相同指令所需等待的时钟周期数。<br>时延描述了前后两个关联操作的等待时间，吞吐则描述了指令的并发能力。</p><p>利用CPU指令乱序多发的能力，掩藏指令延迟的一个有效方法是批量处理无数据前后依赖关系的独立事务。对于重复事务执行，通常采用循环逐次操作。对于较复杂的事务，编译器很难大量地区乱序不同迭代序列下地指令。常用到的做法是在一个序列中铺开执行多个事务，以一个合理地步进迭代。</p><h4 id="队列长度及各种阈值地设置"><a href="#队列长度及各种阈值地设置" class="headerlink" title="队列长度及各种阈值地设置"></a>队列长度及各种阈值地设置</h4><h5 id="收包队列长度"><a href="#收包队列长度" class="headerlink" title="收包队列长度"></a>收包队列长度</h5><p>收包队列的长度就是每个收包队列分配的收包描述符的个数，每个收包描述符都会分配有对应的Mbuf缓存块。<br>网卡硬件本身限定了可以使用的最大的队列长度。DPDK的默认的收包队列长度是128，是一个适应大多数场景的经验值。但是在某些更高速率的网卡收包或者在某些场景下丢包比较容易地时候，需考虑使用更长地收包队列如512或1024。</p><h5 id="发包队列长度"><a href="#发包队列长度" class="headerlink" title="发包队列长度"></a>发包队列长度</h5><p>发包队列的长度就是每个发包队列分配的发包描述符的个数，每个发包描述符都会分配有对应的Mbuf缓存块。<br>DPDK实力中常用地发包队列长度是512。</p><h5 id="收包队列可释放描述符数量阈值（rx-free-thresh）"><a href="#收包队列可释放描述符数量阈值（rx-free-thresh）" class="headerlink" title="收包队列可释放描述符数量阈值（rx_free_thresh）"></a>收包队列可释放描述符数量阈值（rx_free_thresh）</h5><p>在DPDK驱动女程序收包过程中，每一次收包函数的调用都可能成功读取0、1或者多个包。每读出一个包，与之对应的收包描述符就可以释放。DPDK驱动程序并没有每次收包都更新收包队列尾部索引寄存器，而是在可释放的收包描述符数量达到一个阈值(<code>rx_free_thresh</code>)的时候才真正更新收包队列尾部索引寄存器。这个值一般是32。</p><h5 id="发包队列发送结果报告阈值（tx-rs-thresh）"><a href="#发包队列发送结果报告阈值（tx-rs-thresh）" class="headerlink" title="发包队列发送结果报告阈值（tx_rs_thresh）"></a>发包队列发送结果报告阈值（tx_rs_thresh）</h5><p>任何发包处理完成后，需要有网卡硬件通过一定机制通知软件发包动作已经完成，对应的发包描述符就可以再次使用，对应的Mbuf可以释放或者做其他用途。一般都是通过回写发包描述符特定的字段完成通知，但是每个包发完都回写效率很低，因此<code>tx_rs_thresh</code>出现辽，只有在有回写标记的发包描述符才会回写，而这个标记会每个这个阈值才会设置。<br>阈值太小，回写频繁，性能低；阈值太大占用发包描述符时间长，可能会造成丢包。</p><h5 id="发包描述符释放阈值（tx-free-thresh）"><a href="#发包描述符释放阈值（tx-free-thresh）" class="headerlink" title="发包描述符释放阈值（tx_free_thresh）"></a>发包描述符释放阈值（tx_free_thresh）</h5><p>当网卡硬件读取完发包描述符，并且DMA完成整个包的内容的传送后，硬件会根据发送结果回写标记来通知软件发包完成，可以释放。只有放可以用来重新配置的发包描述符数量少于阈值的时候才会启动描述符和Mbuf的释放动作。DPDK驱动程序中默认是32.</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E7%BD%91%E5%8D%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">网卡性能优化</category>
      
      
      <comments>http://singlewang.top/2022/05/17/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch6PCIe与包处理</title>
      <link>http://singlewang.top/2022/05/16/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch6/</link>
      <guid>http://singlewang.top/2022/05/16/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch6/</guid>
      <pubDate>Mon, 16 May 2022 12:49:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;PCIe与包处理I-x2F-O&quot;&gt;&lt;a href=&quot;#PCIe与包处理I-x2F-O&quot; class=&quot;headerlink&quot; title=&quot;PCIe与包处理I&amp;#x2F;O&quot;&gt;&lt;/a&gt;PCIe与包处理I&amp;#x2F;O&lt;/h2&gt;&lt;h3 id=&quot;从PCIe事务的角度看</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="PCIe与包处理I-x2F-O"><a href="#PCIe与包处理I-x2F-O" class="headerlink" title="PCIe与包处理I&#x2F;O"></a>PCIe与包处理I&#x2F;O</h2><h3 id="从PCIe事务的角度看包处理"><a href="#从PCIe事务的角度看包处理" class="headerlink" title="从PCIe事务的角度看包处理"></a>从PCIe事务的角度看包处理</h3><h4 id="PCIe概览"><a href="#PCIe概览" class="headerlink" title="PCIe概览"></a>PCIe概览</h4><p>PCI Express（Peripheral Component Interconnect Express） 又称PCIe，是一种高速串行通信互联标准。<br>其规范遵循开放系统互联参考模型（OSI），自上而下分为事务传输层，数据链路层，物理层。把物理层朝PCIe根组件（Root Complex）方向的流量叫做上游流量（<code>upstream/inbound</code>）,反之叫做下游流量（<code>downstrean/outbound</code>）。</p><h4 id="PCIe事务传输"><a href="#PCIe事务传输" class="headerlink" title="PCIe事务传输"></a>PCIe事务传输</h4><p>在PCIe的线路上抓取一个TLP（Transaction Layer Packet，事务传输层数据包），它是一种分组形式，层层嵌套，最内层是事务传输层，有头部、数据和校验部分，头部定义了一组事务类型。从CPU网卡收发包来说，用到的PCIe的事务类型主要以<code>Memory Read/Write（MRd/MWr）</code>，<code>Completioin with Data</code>和次外层是数据链路层,最外层是物理层。</p><blockquote><p>对于一个完整的TLP包来说，除去有效载荷，额外还有24B的开销（TLP头部以16B计算）。</p></blockquote><p>应用层数据作为有效载荷被承载在事务传输层上，网卡从线路上接收的以太网包整个作为有效载荷在PCIe的事务传输层上进行内部传输。</p><h3 id="网卡DMA描述符环形队列"><a href="#网卡DMA描述符环形队列" class="headerlink" title="网卡DMA描述符环形队列"></a>网卡DMA描述符环形队列</h3><p>DMA(Direct Memory Access，直接存储器访问)是一种高速的数据传输方式，允许在外部设备和存储器之间直接读写数据。数据及不通过CPU，也不需要CPU干预。整个数据传输操作在DMA控制器的控制下进行。</p><p>网卡DMA控制器通过环形队列与CPU进行交互。环形队列由一组控制寄存器和一块物理上连续的缓存构成。主要的控制寄存器有Base、Size、Head、Tail。</p><ul><li>Base寄存器，可以将分配的一段物理连续的内存地址作为环形队列的起始地址，通告给DMA控制器。</li><li>Size寄存器，通告内存块的大小。</li><li>Head寄存器表示硬件当前访问的描述符单元</li><li>Tail寄存器则由软件来填写更新。</li></ul><p>无论网卡工作在中断方式还是轮询方式下，判断包是否接收成功，或者包是否发送成功，都需要检查描述符中的完成状态位(Descripteor Done,DD)。</p><p>无论进行收包还是发包，网卡驱动需要完成的基本操作包括：</p><ol><li>填充缓冲区地址到描述符</li><li>移动尾指针</li><li>判断描述符中的完成状态位</li></ol><blockquote><p>对于收方向，还有申请重填所需的缓冲区的操作。<br>对于发方向，还有释放已发送数据缓冲区的操作。</p></blockquote><h3 id="数据包收发"><a href="#数据包收发" class="headerlink" title="数据包收发"></a>数据包收发</h3><h4 id="全景分析"><a href="#全景分析" class="headerlink" title="全景分析"></a>全景分析</h4><p><strong>接收方向</strong></p><ol><li>CPU 填充缓冲地址到接受侧描述符</li><li>网卡读取接收侧描述符获取缓冲区地址（outbound）</li><li>网卡将包的内容写到缓冲区地址处（inbound）</li><li>网卡回写接受侧描述符更新状态（inbound）</li><li>CPU读取接收侧描述符以确定包接收完毕</li><li>CPU读取包内容做转发判断</li><li>CPU填充更改包内容，做发送判断</li></ol><p><strong>发送方向</strong></p><ol><li>CPU读发送侧描述符，检查是否有发送完成的标志</li><li>CPU将准备发送的缓冲区地址填充到发送侧描述符</li><li>网卡读取发送侧描述符中的地址（outbound）</li><li>网卡根据描述符中地址，读取缓冲区中的数据内容（outbound）</li><li>网卡写发送侧描述符，更新发送已完成标记（inbound）</li></ol><blockquote><p>由于读请求和完成确认是成对出现的，因此对于inbound方向的读操作其实仍旧有outbound方向上的完成确认消息。这也是inbound方向上的带宽压力更大的原因。</p></blockquote><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>从带宽调优的角度可以用到的方法：</p><ol><li>减少MMIO访问的频度</li><li>提高PCIe传输的效率</li><li>尽量避免Cache Line的部分写</li></ol><h3 id="Mbuf和Mempool"><a href="#Mbuf和Mempool" class="headerlink" title="Mbuf和Mempool"></a>Mbuf和Mempool</h3><h4 id="Mbuf"><a href="#Mbuf" class="headerlink" title="Mbuf"></a>Mbuf</h4><p>为了高效访问数据，DPDK将内存封装在Mbuf结构体内。Mbuf主要用来封装网络帧缓存，也可以用来封装通用控制信息缓存。<br>现在Mbuf头部已经调整成两个Cache Line，将基础性，频繁访问的数据放在第一个Cache Line字节，而将功能性扩展的数据放在第二个Cache Line字节。Mbuf报头包含包处理所需的所有数据，对于单个Mbuf存放不下的巨型帧，Mbuf还有指向下一个Mbuf结构的指针来形成帧链表结构。</p><p>对于网络帧的封装及处理有两种方式：</p><ol><li>将网络帧元数据和帧本身存放在固定大小的同一段缓存中。</li></ol><p><strong>优点</strong>：高效，对缓存的申请及释放只需要一个指令。<br><strong>缺点</strong>：缓存长度固定而网络帧大小不一，大部分帧只能使用填0填满整个换粗，较为耗费空间<br>2. 将元数据和网络帧分开存放在两段缓存里。<br><strong>优点</strong>：相对自由<br><strong>缺点</strong>：低效，因为无法保证数据存在于一个Cache Line中，可能造成未命中。</p><p>为了保持包处理的效率，DPDK采用了前者。<br>网络帧元数据的一部分内容由DPDK的网卡驱动写入。<br>对于巨型帧，网络帧元数据仅出现在第一个帧的Mbuf结构中，其他的帧该信息为空。</p><table><thead><tr><th align="center">rte_mbuf</th><th align="center">head room</th><th align="center">网络数据帧内容</th><th align="center">tail room</th></tr></thead></table><p>数据帧的实际长度可以通过调用<code>rte_pktmbuf_pktlen(Mbuf)</code>或<code>rte_pktmbuf_datalen(Mbuf)</code>获得，但是仅限于单帧Mbuf。<br>对于巨型帧<code>rte_pktmbuf_pktlen(Mbuf)</code>等于所有<br><code>rte_pktmbuf_datalen(Mbuf)</code>的和。</p><p>创建一个新的Mbuf缓存需从所属内存池申请，创建的函数为<code>rte_ptmbuf_alloc()</code>(创建网络帧Mbuf)或<code>rte_ctrlmbuf_alloc()</code>(创建控制帧Mbuf),初始化该Mbuf使用<code>rte_pktmbuf_init()</code>或<code>rte_ctrlmbuf_init()</code>,初始化函数被作为<code>rte_mempool_creat()</code>的回调函数。</p><p>释放一段Mbuf实际等于将其放回所属的内存池，其缓存内容在被 重新创建前不会被初始化。</p><p>对Mbuf可执行的操作还包括：</p><ul><li>获得数据帧长度–rte_pktmbuf_datalen()</li><li>获得指向数据的指针–rte_pktmbuf_mtod()</li><li>在帧数据前插入一段内容–rte_pktmbuf_prepend()</li><li>在帧数据后增加一段内容–rte_pktmbuf_append()</li><li>在帧数据前删除一段内容–rte_pktmbuf_adj()</li><li>将帧数据后截掉一段内容–rte_pktmbuf_trim()</li><li>连接两段缓存–rte_pktmbuf_attach(),仅将此函数用于网络帧的复制或分段</li><li>分开两段缓存–rte_pktmbuf_datach()</li><li>克隆Mbuf–rte_pktmbuf_clone()</li></ul><h4 id="Mempool"><a href="#Mempool" class="headerlink" title="Mempool"></a>Mempool</h4><p>当一个网络帧被网卡接收时，DPDK的网卡驱动将其存储在一个高效的环形缓存区中，同时在Mbuf的环形缓存区中创建一个Mbuf对象。<br>Mbuf对象创建好后，网卡驱动根据分析出的帧信息将其初始化，并将其和实际帧对象逻辑相连。对网络帧的分析处理都集中在Mbuf中</p><p>多核CPU访问同一个内存池或者同一个环形缓存区时，因为每次读写时都要进行Compare-and-Set操作来保证期间数据未被其他核心修改，所以存取效率较低。DPDK的解决方法是使用单核本地缓存一部分数据，实时对环形缓存区进行块读写操作，以减少访问环形缓存区的次数。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91/">报文转发</category>
      
      
      <comments>http://singlewang.top/2022/05/16/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch5报文转发</title>
      <link>http://singlewang.top/2022/05/15/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch5/</link>
      <guid>http://singlewang.top/2022/05/15/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch5/</guid>
      <pubDate>Sun, 15 May 2022 11:40:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;报文转发&quot;&gt;&lt;a href=&quot;#报文转发&quot; class=&quot;headerlink&quot; title=&quot;报文转发&quot;&gt;&lt;/a&gt;报文转发&lt;/h2&gt;&lt;h3 id=&quot;网络处理模块划分&quot;&gt;&lt;a href=&quot;#网络处理模块划分&quot; class=&quot;headerlink&quot; title=&quot;网</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="报文转发"><a href="#报文转发" class="headerlink" title="报文转发"></a>报文转发</h2><h3 id="网络处理模块划分"><a href="#网络处理模块划分" class="headerlink" title="网络处理模块划分"></a>网络处理模块划分</h3><p>网络报文的处理和转发主要分为硬件处理部分和软件处理部分：</p><ol><li>报文输入</li><li>对保温进行比较粗粒度的处理</li><li>对保温进行比较细粒度的分流</li><li>提供基于描述符的队列FIFO</li><li>根据队列优先级和CPU状态进行调度</li><li>提供加解密和压缩&#x2F;解压缩等硬件功能</li><li>在出口上根据QOS等级进行调度</li><li>后期报文处理释放缓存</li><li>从硬件上发送出去</li></ol><h3 id="转发框架介绍"><a href="#转发框架介绍" class="headerlink" title="转发框架介绍"></a>转发框架介绍</h3><p>传统的专用网络处理器转发的模型可以分为<code>run to completion</code>模型和<code>pipeline</code>模型</p><ol><li>pipeline模型<br>将一个功能分解成多个独立的阶段，不同阶段间通过队列传递。</li><li>run to completion模型<br><code>run to completion</code>（运行至终结）模型时主要针对DPDK一般程度的运行方法，一个程序中一般会分为几个不同的逻辑功能，但是这几个逻辑功能会在一个CPU的核上运行，我们可以进行水平扩展使得在SMP的系统中多个核上执行一个逻辑的程序，从而提高单位时间内事务处理的量。<h4 id="DPDK-run-to-completion模型"><a href="#DPDK-run-to-completion模型" class="headerlink" title="DPDK run to completion模型"></a>DPDK run to completion模型</h4>DPDK的轮询模式能够通过一些参数设置哪些核可以被DPDK使用，最后再把处理对应收发队列的线程绑定到对应的核上。每个报文的生命周期只可能再一个线程中出现。但是针对单个报文的处理始终集中在一个逻辑单元上，无法利用其他运算单元，并且逻辑的耦合性太强，而流水线模型正好解决了以上的问题。<h4 id="DPDK-pipeline模型"><a href="#DPDK-pipeline模型" class="headerlink" title="DPDK pipeline模型"></a>DPDK pipeline模型</h4>pipeline的主要思想就是不同的工作交给不同的模块，每个模块单独处理特定的事务，每个模块都有输入和输出，通过输入输出将这些模块联系起来，完成复杂的网络功能。<br>DPDK的pipeline是由三大部分组成，逻辑端口(port)、查找表（table）和处理逻辑（action）。DPDK的pipeline模型中把网络端口作为每个处理模块的输入，所有的报文输入都通过这个端口进行。查找表是每个处理模块的处理逻辑核心，转发逻辑指明了报文的流向和处理。<br>用户可以根据这三大类构建属于自己的pipeline。<br>现在DPDK支持的pipeline有以下几种：</li></ol><ul><li>Packet I&#x2F;O</li><li>Flow classification</li><li>Firewall</li><li>Routing</li><li>Metering</li><li>Traffic Mgmt</li></ul>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91/">报文转发</category>
      
      
      <comments>http://singlewang.top/2022/05/15/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch4同步互斥机制</title>
      <link>http://singlewang.top/2022/05/14/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch4/</link>
      <guid>http://singlewang.top/2022/05/14/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch4/</guid>
      <pubDate>Sat, 14 May 2022 12:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;DPDK原子操作实现和应用&quot;&gt;&lt;a href=&quot;#DPDK原子操作实现和应用&quot; class=&quot;headerlink&quot; title=&quot;DPDK原子操作实现和应用&quot;&gt;&lt;/a&gt;DPDK原子操作实现和应用&lt;/h3&gt;&lt;p&gt;原子操作在DPD代码中的定义都在&lt;code&gt;rte_</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="DPDK原子操作实现和应用"><a href="#DPDK原子操作实现和应用" class="headerlink" title="DPDK原子操作实现和应用"></a>DPDK原子操作实现和应用</h3><p>原子操作在DPD代码中的定义都在<code>rte_atomic.h</code>中，主要包含两部分：<strong>内存屏蔽和原16、32和64位的原子操作API</strong></p><blockquote><p>Linux内核的原子操作见linux驱动</p></blockquote><h4 id="内存屏障API"><a href="#内存屏障API" class="headerlink" title="内存屏障API"></a>内存屏障API</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rte_mb()  <span class="comment">//内存屏障读写API</span></span><br><span class="line">rte_wmb()  <span class="comment">//内存屏障写API</span></span><br><span class="line">rte_rmb()  <span class="comment">//内存屏障读API</span></span><br></pre></td></tr></table></figure><h3 id="DPDK读写锁实现和应用"><a href="#DPDK读写锁实现和应用" class="headerlink" title="DPDK读写锁实现和应用"></a>DPDK读写锁实现和应用</h3><p>DPDK的读写锁的定义在<code>rte_rwlock.h</code>中，</p><blockquote><p>linux读写锁的API见linux驱动</p></blockquote><p><code>rte_rwlock_init(rte_rwlock_t *rwl)</code>:初始化读写锁到unlocked状态<br><code>rte_rwlock_read_lock(rte_rwlock_t *rwl)</code>:尝试获取读锁直到锁被占用<br><code>rte_rwlock_read_unlock(rte_rwlock_t *rwl)</code>:释放读锁<br><code>rte_rwlock_write_lock(rte_rwlock_t *rwl)</code>:获取写锁<br><code>rte_rwlock_write_unlock(rte_rwlock_t *rwl)</code>:释放写锁</p><p>读写锁在DPDK中主要应用在如下几个地方：</p><ol><li>在查找空闲的<code>memory segment</code>的时候，使用读写锁来保护<code>memseg</code>结构，LPM表的创建、查找和释放</li><li><code>Memory ring</code>的创建、查找、释放</li><li>ACL表的创建、查找、释放</li><li>Memzone的创建、查找、释放</li></ol><h3 id="DPDK自旋锁实现和应用"><a href="#DPDK自旋锁实现和应用" class="headerlink" title="DPDK自旋锁实现和应用"></a>DPDK自旋锁实现和应用</h3><p>DPDK自旋锁API的定义在<code>rte_spinlock.h</code>中，下面三个API被广泛应用在告警、日志、中断机制、内存共享、link bonding中用于临界资源的保护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rte_spinlock_init(<span class="type">rte_spinlock_t</span> *sl)</span><br><span class="line">rte_spinlock_lock(<span class="type">rte_spinlock_t</span> *sl)</span><br><span class="line">rte_spinlock_unlock(<span class="type">rte_spinlock_t</span> *sl)</span><br></pre></td></tr></table></figure><h3 id="DPDK无锁环形缓冲"><a href="#DPDK无锁环形缓冲" class="headerlink" title="DPDK无锁环形缓冲"></a>DPDK无锁环形缓冲</h3><p>DPDK提供了一套无锁环形缓冲区队列管理代码，支持单生产者产品入队，单消费者产品出队；多生产者入队，多消费者出队</p><blockquote><p>见DPDK基础</p></blockquote><p>单生产者单消费者模型不需要加锁<br>（一）多对多（一）模型中正常逻辑操作是要对队列操作进行加锁处理。加锁的性能开销较大，一般采用无锁实现。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/">同步互斥</category>
      
      
      <comments>http://singlewang.top/2022/05/14/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch4/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
