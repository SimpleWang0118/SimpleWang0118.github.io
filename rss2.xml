<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Single Wang&#39;s Blog</title>
    <link>http://singlewang.top/</link>
    
    <atom:link href="http://singlewang.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>智者不入爱河，愚者重蹈覆辙</description>
    <pubDate>Thu, 05 May 2022 13:46:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>cpp之虚函数与多态</title>
      <link>http://singlewang.top/2022/05/05/cpp/cpp%E5%A4%9A%E6%80%81/</link>
      <guid>http://singlewang.top/2022/05/05/cpp/cpp%E5%A4%9A%E6%80%81/</guid>
      <pubDate>Thu, 05 May 2022 13:20:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;何为 &lt;em&gt;&lt;strong&gt;多态&lt;/strong&gt;&lt;/em&gt;,顾名思义是同一个事物在不同场景下的多种形态。&lt;br&gt;多态分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态多态&lt;ul&gt;
&lt;li&gt;函数重载&lt;/li&gt;
&lt;li&gt;泛型编程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态多态&lt;ul</description>
        
      
      
      
      <content:encoded><![CDATA[<p>何为 <em><strong>多态</strong></em>,顾名思义是同一个事物在不同场景下的多种形态。<br>多态分类：</p><ul><li>静态多态<ul><li>函数重载</li><li>泛型编程</li></ul></li><li>动态多态<ul><li>虚函数</li></ul></li></ul><h3 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h3><p>函数重载就是一个简单的静态多态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Add</span><span class="params">(<span class="type">double</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">//Add(10.0, 20.0);  //这是一个问题代码</span></span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">10.0</span>,<span class="number">20</span>);  <span class="comment">//正常代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>静态多态实在编译期间完成的，编译器会根据实参类型来调用合适的函数,如果有合适的函数就调用，如果没有就会发出警告或报错</em></p><h3 id="动态多态"><a href="#动态多态" class="headerlink" title="动态多态"></a>动态多态</h3><p>动态多态，看名字就知道和静态多态是相反的。<em>它是在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的&#x3D;&#x3D;虚函数&#x3D;&#x3D;</em></p><p>提到动态多态那么不得不提一嘴虚函数。虚函数可以说对动态多态具有决定性的作用。有虚函数才能构成多态。使用虚函数的注意事项：</p><ol><li>只需要在虚函数的声明处加上 virtual 关键字，函数定义处可以加也可以不加。</li><li>可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽（覆盖）关系的同名函数都将自动成为虚函数。</li><li>当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。</li><li>只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）。</li><li>构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。</li><li>析构函数可以声明为虚函数，而且有时候必须要声明为虚函数。</li></ol><p>那么虚函数的作用是什么呢？</p><ol><li>定义子类对象，并调用对象中未被子类覆盖的基类函数A。同时在该函数A中，又调用了已被子类覆盖的基类函数B。那此时将会调用基类中的函数B，可我们本应该调用的是子类中的覆盖函数B。虚函数即能解决这个问题。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类 Father</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Father::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在函数中调用了，子类覆盖基类的函数display()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fatherShowDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Son</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重写基类中的display()函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Son::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son son;                    <span class="comment">// 子类对象</span></span><br><span class="line">    son.<span class="built_in">fatherShowDisplay</span>();    <span class="comment">// 通过基类中未被覆盖的函数，想调用子类中覆盖的display函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父类中的<code>display()</code>不是虚函数，则执行结果为<code>Father::display()</code>。反之，执行结果为<code>Son::display()</code>。</p><ol start="2"><li>在使用指向子类对象的基类指针，并调用子类中的覆盖函数时，如果该函数不是虚函数，那么将调用基类中的该函数；如果该函数是虚函数，则会调用子类中的该函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类 Father</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义了虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Father::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Son</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 覆盖基类中的display函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Son::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Father *fp;     <span class="comment">// 定义基类指针</span></span><br><span class="line">    Son son;        <span class="comment">// 子类对象</span></span><br><span class="line">    fp=&amp;son;        <span class="comment">// 使基类指针指向子类对象</span></span><br><span class="line">    fp-&gt;<span class="built_in">display</span>();  <span class="comment">// 通过基类指针想调用子类中覆盖的display函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父类中的<code>display()</code>不是虚函数，则执行结果为<code>Father::display()</code>。反之，执行结果为<code>Son::display()</code>。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/CPP/">CPP</category>
      
      
      <category domain="http://singlewang.top/tags/cpp/">cpp</category>
      
      <category domain="http://singlewang.top/tags/%E5%A4%9A%E6%80%81/">多态</category>
      
      <category domain="http://singlewang.top/tags/%E8%99%9A%E5%87%BD%E6%95%B0/">虚函数</category>
      
      
      <comments>http://singlewang.top/2022/05/05/cpp/cpp%E5%A4%9A%E6%80%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux内核协议栈-cp3</title>
      <link>http://singlewang.top/2022/05/04/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp3/</link>
      <guid>http://singlewang.top/2022/05/04/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp3/</guid>
      <pubDate>Wed, 04 May 2022 12:17:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;3-配置系统&quot;&gt;&lt;a href=&quot;#3-配置系统&quot; class=&quot;headerlink&quot; title=&quot;3.配置系统&quot;&gt;&lt;/a&gt;3.配置系统&lt;/h2&gt;&lt;h3 id=&quot;3-1配置过程分析&quot;&gt;&lt;a href=&quot;#3-1配置过程分析&quot; class=&quot;headerlink</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="3-配置系统"><a href="#3-配置系统" class="headerlink" title="3.配置系统"></a>3.配置系统</h2><h3 id="3-1配置过程分析"><a href="#3-1配置过程分析" class="headerlink" title="3.1配置过程分析"></a>3.1配置过程分析</h3><h4 id="3-1-1配置如何下达到内核"><a href="#3-1-1配置如何下达到内核" class="headerlink" title="3.1.1配置如何下达到内核"></a>3.1.1配置如何下达到内核</h4><p>我们假设在安装我们的 Linux 系统时，没有配置 IP 地址，也没有挂上网线，完完全全是一台“裸机”， 这样方便我们跟踪系统到底做了什么。<br>使用<code>ifconfig -a</code>查看网络配置<br>使用<code>strace ifconfig eth0 192.168.18.2 netmask 255.255.255.0</code>配置号ip和网络掩码<br>在大部分系统上是没有 ifconfig 的源代码的，那么为了查看 ifconfig 内部完成了什么操作时，可以用strace命令查看。<br>把 ifconfig 内部调用的系统接口整理如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="type">int</span> argc, <span class="type">char</span> **argv ) &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span> </span><br><span class="line">    <span class="type">char</span> host[<span class="number">128</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aftype</span> *<span class="title">ap</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hwtype</span> *<span class="title">hw</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span> </span><br><span class="line">    <span class="type">char</span> **spp; </span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">    fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);</span><br><span class="line">    ifr.ifr_name = “eth0”; </span><br><span class="line"> </span><br><span class="line">    ap = inet_aftype = &#123;</span><br><span class="line">    <span class="string">&quot;inet&quot;</span>, <span class="literal">NULL</span>, <span class="comment">/*&quot;DARPA Internet&quot;, */</span> AF_INET, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>), INET_print, INET_sprint, INET_input, INET_reserror, <span class="literal">NULL</span> <span class="comment">/*INET_rprint */</span> , <span class="literal">NULL</span> <span class="comment">/*INET_rinput */</span> , INET_getnetmask,</span><br><span class="line"><span class="number">-1</span>, <span class="comment">/* 这个值会被赋成 fd，即刚才打开的 socket */</span> <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line">    host = “<span class="number">192.168</span><span class="number">.18</span><span class="number">.2</span>”; </span><br><span class="line">    ap-&gt;input(<span class="number">0</span>, host, &amp;sa);<span class="comment">/* 在此 sa-&gt;sa_family=AF_INET，af-&gt;sa_data 已经被设置成 192.168.1.1 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">char</span> *) &amp;ifr.ifr_addr, (<span class="type">char</span> *) &amp;sa, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)); </span><br><span class="line">    ioctl (fd, SIOCSIFADDR, &amp;ifr);</span><br><span class="line">    ioctl (skfd, SIOCGIFFLAGS, &amp;ifr); </span><br><span class="line">    ioctl (skfd, SIOCSIFFLAGS, &amp;ifr);</span><br><span class="line">    host = “<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>”;</span><br><span class="line">    ioctl (skfd, SIOCSIFNETMASK, ifr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可以看出 ifconfig 实际调用了 2 个系统函数：socket 和 ioctl。</p><h4 id="3-1-2socket系统调用"><a href="#3-1-2socket系统调用" class="headerlink" title="3.1.2socket系统调用"></a>3.1.2socket系统调用</h4><p>内核中与socket对应的系统调用时sys_socket,所谓的船舰套接字，就是在sockfs这个文件系统中创建一个节点。该节点是一个文件，不过这个文件具有非普通文件的属性，于是起名socket。<br>从进程角度看，一个套接口就是一个特殊的已打开文件。<br>socket函数本身经过glibc库对其封装，通过int 0x80产生一个软件中断，由内核导向执行sys_socket。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核协议栈</category>
      
      
      <category domain="http://singlewang.top/tags/kernal/">kernal</category>
      
      <category domain="http://singlewang.top/tags/linux/">linux</category>
      
      <category domain="http://singlewang.top/tags/%E5%86%85%E6%A0%B8/">内核</category>
      
      
      <comments>http://singlewang.top/2022/05/04/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>c++遇到的bug-1</title>
      <link>http://singlewang.top/2022/05/03/cpp/cpp-bug/c++bug-1/</link>
      <guid>http://singlewang.top/2022/05/03/cpp/cpp-bug/c++bug-1/</guid>
      <pubDate>Tue, 03 May 2022 12:54:00 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;&lt;code&gt;reference to local variable ‘c’ returned [-Wreturn-local-addr]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;函数的返回值为函数内部定义变量的引用，但函数在调用完毕后，函数内部定义的变量空间被</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li><code>reference to local variable ‘c’ returned [-Wreturn-local-addr]</code></li></ol><p>函数的返回值为函数内部定义变量的引用，但函数在调用完毕后，函数内部定义的变量空间被释放，无法访问，从而造成的错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix&amp; Matrix::<span class="keyword">operator</span>+(<span class="type">const</span> Matrix&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix result;</span><br><span class="line"><span class="comment">//其他操作</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>改正方法一</strong></em>：给返回变量定义加上static限定符，保证在函数调用完后不释放空间<br>Matrix&amp; Matrix::operator+(const Matrix&amp; rhs)<br>{<br>    static Matrix result;<br>    &#x2F;&#x2F;其他操作<br>    return result;<br>}</p><p><em><strong>改正方法二</strong></em>：去掉返回值的引用，保证函数外部无法访问返回值的空间，只能得到其内容<br>Matrix Matrix::operator+(const Matrix&amp; rhs)<br>{<br>    static Matrix result;<br>    &#x2F;&#x2F;其他操作<br>    return result;<br>}</p><ol start="2"><li><p>LNK2019<br>即使包含了头文件依然会报无法解析的命令,原因可能是没添加相应的.lib文件</p></li><li><p>不允许指针指向不完整的类类型<br>一般是没有包含相应的头文件</p></li></ol>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/cpp/">C++</category>
      
      <category domain="http://singlewang.top/categories/cpp/cpp-bug/">C++BUG</category>
      
      
      <category domain="http://singlewang.top/tags/cpp/">cpp</category>
      
      <category domain="http://singlewang.top/tags/bug/">bug</category>
      
      
      <comments>http://singlewang.top/2022/05/03/cpp/cpp-bug/c++bug-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>git学习</title>
      <link>http://singlewang.top/2022/05/03/git%E5%AD%A6%E4%B9%A0/</link>
      <guid>http://singlewang.top/2022/05/03/git%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Tue, 03 May 2022 12:51:00 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;初始化一个git目录    &lt;code&gt;git init&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加文件到Git仓库，分两步：&lt;br&gt; 使用命令&lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt;，注意，可反复多次使用，添加多个文件；&lt;br&gt; 使用命令&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>初始化一个git目录    <code>git init</code></li><li>添加文件到Git仓库，分两步：<br> 使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；<br> 使用命令<code>git commit -m &lt;message&gt;</code>提交完成。-m后面输入的是本次提交的说明</li><li>要随时掌握工作区的状态，使用<code>git status</code>命令。<br> 如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li><li>添加远程库<code>git remote add origin git@github.com:SimpleWang0118/C-Game.git</code><br> 添加后，远程库的名字就是<code>origin</code><br> 把本地库的所有内容推送到远程库上（第一次）<code>git push -u origin master</code><br> 只要本地作了提交，就可以通过命令 <code>git push origin master</code>推送至远程库上</li><li>查看远程库信息<code>git remote -v</code></li><li>删除远程库<code>eg git remote rm origin</code></li><li><code>git commit</code>提示<code>Your branch is up-to-date with &#39;origin/master&#39;</code><br> 首先建立一个分支：<code>git branch new branch</code><br> 然后检查分支是否创建成功: <code>git branch</code> *代表的是当前你所在的工作分支<br> 然后切换到你的新分支: <code>git checkout newbranch</code><br> 然后将你的改动提交到新分支上: git add .     git commit -m “18.03.01”<br> 然后切换到主分支:<code>git checkout master</code><br> 然后将新分支提交的改动合并到主分支上:<code>git merge newbranch</code><br> 然后就可以push代码了:<code>git push -u origin master</code><br> 最后还可以删除这个分支:<code>git branch -D newbranch</code></li></ol>]]></content:encoded>
      
      
      
      <category domain="http://singlewang.top/tags/git/">git</category>
      
      <category domain="http://singlewang.top/tags/github/">github</category>
      
      
      <comments>http://singlewang.top/2022/05/03/git%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>刷机教程</title>
      <link>http://singlewang.top/2022/05/03/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</link>
      <guid>http://singlewang.top/2022/05/03/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</guid>
      <pubDate>Tue, 03 May 2022 08:34:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;1、首先解锁手机BL锁，进入开发者选项，然后需要到相应的手机官网下载解锁工具。&lt;br&gt;2、安装对应手机的rec软件，之后进入rec，先双清，即首先清除数据，再格式化&lt;br&gt;3、下载对应的系统压缩包&lt;br&gt;4、在rec软件中安装压缩包即可。&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>1、首先解锁手机BL锁，进入开发者选项，然后需要到相应的手机官网下载解锁工具。<br>2、安装对应手机的rec软件，之后进入rec，先双清，即首先清除数据，再格式化<br>3、下载对应的系统压缩包<br>4、在rec软件中安装压缩包即可。</p>]]></content:encoded>
      
      
      
      <category domain="http://singlewang.top/tags/%E5%88%B7%E6%9C%BA/">刷机</category>
      
      
      <comments>http://singlewang.top/2022/05/03/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux内核协议栈-cp2</title>
      <link>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp2/</link>
      <guid>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp2/</guid>
      <pubDate>Tue, 03 May 2022 08:34:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;2-系统初始化&quot;&gt;&lt;a href=&quot;#2-系统初始化&quot; class=&quot;headerlink&quot; title=&quot;2.系统初始化&quot;&gt;&lt;/a&gt;2.系统初始化&lt;/h2&gt;&lt;h3 id=&quot;2-1-系统初始化流程简介&quot;&gt;&lt;a href=&quot;#2-1-系统初始化流程简介&quot; class</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="2-系统初始化"><a href="#2-系统初始化" class="headerlink" title="2.系统初始化"></a>2.系统初始化</h2><h3 id="2-1-系统初始化流程简介"><a href="#2-1-系统初始化流程简介" class="headerlink" title="2.1 系统初始化流程简介"></a>2.1 系统初始化流程简介</h3><p>在系统启动过程中，我们要关注这几个方面： </p><ol><li>中断系统及调度系统 </li><li>文件系统的初始化 </li><li>设备管理系统的初始化</li><li>网络协议的初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kernel_thread</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> * arg, <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br></pre></td></tr></table></figure><p><code>kernel_thread</code>创建一个线程，定义在arch&#x2F;i386&#x2F;kernel&#x2F;process.c中，Linux 的内核线程是没有虚拟存储空间的进程，它们运行在内核中，直接使用物理地址空间。</p><h3 id="2-2内核文件解读"><a href="#2-2内核文件解读" class="headerlink" title="2.2内核文件解读"></a>2.2内核文件解读</h3><h4 id="2-2-1ELF文件格式"><a href="#2-2-1ELF文件格式" class="headerlink" title="2.2.1ELF文件格式"></a>2.2.1ELF文件格式</h4><p>ELF 是*nix 系统上可执行文件的标准格式，它取代了out格式的可执行文件，原因在于它的可扩展性。<br>ELF文件有三种不同的形式：</p><ol><li>Relocatable：由编译器和汇编器生成，由 linker 处理它。 </li><li>Executable：所有的重定位和符号解析都完成了，也许共享库的符号要在运行时刻解析。</li><li>Shared Object：包含 linker 需要的符号信息和运行时刻所需的代码。</li></ol><p>ELF 文件有双重性质：一方面，编译器、汇编器、连接器都把它看作是逻辑段（sections）的集合， 另一方面 loader 把它看作段（segments）的集合。Section 是给 linker 做进一步处理的，而 segments 是被映射到内存中去的。</p><p>一个 segment 可以由几个 sections 组成。为了定位不同 segment&#x2F;section，可执行文件用一个 table 来记录各个 segment&#x2F;section 的位置和描述。</p><h4 id="2-2-2Link-Scripts知识"><a href="#2-2-2Link-Scripts知识" class="headerlink" title="2.2.2Link Scripts知识"></a>2.2.2Link Scripts知识</h4><p>为什么我们编出来的代码肯定是在用户地址空间运行，而内核编出来的代码 却一定是运行在内核空间？<br>主要是因为链接器的作用。不能简单地认为链接器仅仅完成将各 obj 文件拼在一起的任务，而且它还指定每个段被装入内存的真正地址。</p><p>可以用<code>ld -verbose</code>查看<code>ld script</code></p><h3 id="2-3中断及任务调度管理"><a href="#2-3中断及任务调度管理" class="headerlink" title="2.3中断及任务调度管理"></a>2.3中断及任务调度管理</h3><h4 id="2-3-1中断及软中断模型"><a href="#2-3-1中断及软中断模型" class="headerlink" title="2.3.1中断及软中断模型"></a>2.3.1中断及软中断模型</h4><p>Linux 支持 CPU 的外部硬件中断和内部中断。&#x3D;&#x3D;内部中断包含系统调用陷入和异常&#x3D;&#x3D;，在一般的嵌入式操作系统（比如 VxWorks）中是没有系统调用这个概念的。</p><ul><li>&#x3D;&#x3D;系统调用&#x3D;&#x3D;就是软件有计划地调用 CPU 提供的特殊指令，触发 CPU 内部产生一个中断，于是完成一次核内核外运行空间的切换，具体可以参考许多书籍。</li><li>&#x3D;&#x3D;异常&#x3D;&#x3D;就是软件无意的执行了一个非法指令（比如除 0）从而造成 CPU 内部引发一次中断。</li></ul><p>&#x3D;&#x3D;外部中断&#x3D;&#x3D;特指外部设备发出的中断信号。但这几种中断的 CPU 处理过程基本相同，即：在执行完当 前指令后，或在执行当前指令期间，根据中断源所提供的“中断向量”，在内存中找到相应的 ISR（中断<br>服务例程）然后调用之。</p><h5 id="2-3-1-1中断系统和软中断"><a href="#2-3-1-1中断系统和软中断" class="headerlink" title="2.3.1.1中断系统和软中断"></a>2.3.1.1中断系统和软中断</h5><p>IRQ 是设备相关的号码，一般生产厂商都会使自己的设备分配到一个合适的号码。<br>&#x3D;&#x3D;中断向量&#x3D;&#x3D;就是操作系统中关于如何处理中断的内存组织结构，它们之间存在某种映射关系，这种关系是由CPU体系结构以及操作系统决定的。</p><blockquote><p>中断向量号0x80是系统调用号</p></blockquote><p>软中断是在处理完所有的中断之后才会处理的。目前linux内核中定义了6种软中断。在<code>start_kernel</code>函数中调用的<code>softirp_init</code>只初始化了两个。</p><p>Tasklet机制是一种比较特殊的软中断。指一小段可以执行的代码。通常以函数的形式出现。从某种程度上讲tasklet机制是linux内核对BH机制的一种扩展。它呈现出以下两个特点:</p><ol><li>与一般的软中断不同，某一段 tasklet 代码在某个时刻只能在一个 CPU 上运行，而不像一般的软 中断服务函数（即 softirq_action 结构中的 action 函数指针）那样在同一时刻可以被多个 CPU 并发地执行。</li><li>与BH机制不同，不同的 tasklet 代码在同一时刻可以在多个 CPU上并发地执行，而不像BH机制 那样必须严格地串行化执行（也即在同一时刻系统中只能有一个 CPU 执行BH函数）。</li></ol><h3 id="2-4虚拟文件系统"><a href="#2-4虚拟文件系统" class="headerlink" title="2.4虚拟文件系统"></a>2.4虚拟文件系统</h3><p>VFS（虚拟文件系统）在 Linux 及Unix 家族中是非常重要的概念，可以说它是操作系统的骨架。VFS 只存在与内存中，它在系统启动时被创建，系统关闭时注销。<br>&#x3D;&#x3D;VFS 的作用就是屏蔽各类文件系统的差异， 给用户、应用程序、甚至 Linux 其他管理模块提供统一的接口集合。&#x3D;&#x3D;</p><p>VFS 描述文件系统使用超级块和 inode 的方式，所谓超级块就是对所有文件系统的管理机构，每种 文件系统都要把自己的信息挂到 <code>super_blocks</code> 这么一个全局链表上。内核中是分成 2 个步骤完成：首先 每个文件系统必须通过 <code>register_filesystem</code> 函数将自己的 <code>file_system_type</code> 挂接到 <code>file_systems</code> 这个全局变量上，然后调用 <code>kern_mount</code> 函数把自己的文件相关操作函数集合表挂到 <code>super_blocks</code> 上。</p><h3 id="2-5网络协议栈各部分初始化"><a href="#2-5网络协议栈各部分初始化" class="headerlink" title="2.5网络协议栈各部分初始化"></a>2.5网络协议栈各部分初始化</h3><p>初始化大致的顺序：</p><ol><li>core_initcall:sock_init()</li><li>fs_initcall:inet_init()</li><li>subsys_initcall:net_dev_init()</li><li>device_initcall:设备驱动初始化</li></ol><h4 id="2-5-1网络基础系统初始化"><a href="#2-5-1网络基础系统初始化" class="headerlink" title="2.5.1网络基础系统初始化"></a>2.5.1网络基础系统初始化</h4><p>第一个步骤使用<code>core_initcall</code>初始化宏修饰<code>sock_init</code>函数，此函数知识分配一些内存空间，以及创建一个sock_fs_type的二年间系统。</p><blockquote><p>基本的socket初始化必须在每一个TCP&#x2F;IP成员协议能注册到socket层之前完成。</p></blockquote><p>当执行<code>do_initcalls</code>时才是真正初始化那些特定协议。</p><h4 id="2-5-2网络内存管理"><a href="#2-5-2网络内存管理" class="headerlink" title="2.5.2网络内存管理"></a>2.5.2网络内存管理</h4><h5 id="2-5-2-1-sk-buff结构"><a href="#2-5-2-1-sk-buff结构" class="headerlink" title="2.5.2.1 sk_buff结构"></a>2.5.2.1 sk_buff结构</h5><p>数据包在应用层称为data，在TCP层成为segment，在IP层称为packet，在数据链路层称为frame。Linux内核中<code>sk_buff&#123;&#125;</code>存放网络接收到或需要发送的数据，因此其必须要有足够的扩展性。<br>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 <code>skb-&gt;data</code> 的值，来逐步剥离协议首部；<br>而要发送报文时，各协议创建<code>sk_buff&#123;&#125;</code>，在经过各下层协议时，通过减少 <code>skb-&gt;data</code><br>的值来增加协议首部。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span>&#123;</span></span><br><span class="line">    <span class="comment">/*这两个成员必须放在前面*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    _u32    qlen;<span class="comment">/*该sk_buff_head引导的一个链表的节点的个数*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当接收一个报文时，创建一个<code>sk_buff&#123;&#125;</code>(sk_buff的内容过多，暂不列出),然后更具地址类型指定该skb实际属于哪一种的报文类型，然后上层协议栈采取相应的处理方式处理该skb。</p><p>其中<code>len</code>是指数据包全部数据的长度，包括<code>data</code>指向的数据和end后面的分片的数据的总长，而<code>data_len</code>只包括分片的数据的长度。<code>truesize</code>的最终值时<code>len+sizof(struct sk_buff)</code>。</p><p>两个后备高速缓存的区别：</p><ul><li><code>skbuff_head_cache</code> 在创建时指定的单位内存区域的大小是<code>sizeof(struct sk_buff)</code>，可以容纳任意数目的<code>struct sk_buff</code>。</li><li><code>skbuff_fclone_cache</code>在创建时指定的单位内存区域大小时<code>2*sizeof(struct sk_buff)+sizeof(atomic_t)</code>。</li></ul><p>创建一个套接字缓冲区，最常用的操作是<code>alloc_skb</code>。它是在<code>skbuff_head_cache</code>中创建。</p><blockquote><p>GSO(Generic Segmentation Offload):<br>协议栈的效率提高的一个策略：尽可能晚的推迟分段，最理想的是在网卡驱动里分段，在网卡驱动里把大包拆开，组成SG list，或在一块预先分配好的内存中重组分段，然后交给网卡。</p></blockquote><h5 id="2-5-2-2-内存管理函数"><a href="#2-5-2-2-内存管理函数" class="headerlink" title="2.5.2.2 内存管理函数"></a>2.5.2.2 内存管理函数</h5><p>在<code>sk_buff&#123;&#125;</code>中的 4 个指针 data、head、tail、end 初始化的时候，data、head、tail 都是指向申请到的 数据区的头部，end 指向数据区的尾部。一般都是通过 data 和 tail 来获得在 sk_buff中 可用的数据区的开始和结尾。而 head 和 end 就表示 sk_buff中存在的数据包最大可扩展的空间范围。</p><p> skb_clone 和 skb_copy 的区别：</p><ul><li>前者基本在 <code>skbuff_fclone_cache</code> 中分配内存，除非 一定要对一个不是可以被克隆的对象进行克隆，那么才会在 <code>skbuff_head_cache</code> 中分配内存，而且只是 <code>sk_buff&#123;&#125;</code>结构的复制，没有涉及到真正数据区（data）的复制；</li><li>后者必定在 <code>skbuff_head_cache</code> 中进行，<br>不仅复制 <code>sk_buff&#123;&#125;</code>，而且复制了数据区。</li></ul><h4 id="2-5-3-网络文件系统初始化"><a href="#2-5-3-网络文件系统初始化" class="headerlink" title="2.5.3 网络文件系统初始化"></a>2.5.3 网络文件系统初始化</h4><p>在 <code>linux</code> 系统中，<code>socket</code> 属于文件系统的一部分，网络通信可以被看作对文件的读取。这种特殊的文件系统叫 <code>sockfs</code>。</p><p>初始化文件系统，首先是调用 <code>register_filesystem(&amp;sock_fs_type)</code>;把文件系统类型注册到 <code>file_systems</code> 链表上，然后调用 <code>kern_mount(&amp;sock_fs_type)</code>;把该文件系统注册到 <code>super_blocks</code> 上。</p><p>在系统初始化的时候要通过 <code>kern_mount</code> 安装此文件系统。所谓创建一个套接字就是在 <code>sockfs</code>文件系统中创建一个特殊文件。</p><h4 id="2-5-4-网络协议初始化"><a href="#2-5-4-网络协议初始化" class="headerlink" title="2.5.4 网络协议初始化"></a>2.5.4 网络协议初始化</h4><p>初始化第二个大步骤就是使用 <code>fs_initcall</code> 初始化宏修饰 <code>inet_init</code> 函数，它初始化和协议本身相关的东西。这一步才真正设计到“栈”的概念。在这之前，必须要知道两个概念–地址族和套接字类型。Linux 将不同的地址族抽象统一为 BSD 套接字接口，应用程序关心的只是BSD套接字接口，通过参数来指定所使用的套接字地址族。</p><p>Linux 内核中为了支持多个地址族，定义了这么一个变量：<code>static struct net_proto_family *net_families[NPROTO]</code>，NPROTO 等于 32，也就是说 Linux 内核支持最多 32 种地址族。</p><p>我们常用的就是 PF_UNIX（1）、PF_INET（2）、PF_NETLINK（16），Linux 还有一个自有的 PF_PACKET（17）。</p><blockquote><p>网络协议的初始化是在网络设备的初始化之前完成的，在 Linux 系统中并不是说网络设备不存在就不需要网络协议了，而是在没有网络设备存在的时候，照样可以完成网络的工作，只不过网络系统物理上只存在于本机一台机器中而已。</p></blockquote><p>一进入初始化就调用 <code>proto_register</code>3次，先后为 tcp、udp、raw的 <code>proto&#123;&#125;</code>结构申请空间并将其挂到一 个全局链表 <code>proto_list</code> 上。这三个 proto 全局变量非常重要，是连接传输层和 IP 层的纽带。</p><p><code>sock_register</code>函数，它把 <code>inet_family_ops</code> 塞入 <code>net_families</code> 数组中，这个 <code>inet_family_ops</code>是如下定义的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> =</span> &#123; </span><br><span class="line">    .family = PF_INET, </span><br><span class="line">    .create = inet_create, </span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户创建 socket 时，先指定 INET 地址族，在指定套接字 类型。换句话说这是数据流发送的流向。</p><p>socket层必须区分哪一个用户应该接收这个包，这叫做<em><strong>socket解复用</strong></em>。</p><p>之后就是初始化第二个方面的必要步骤:注册接收函数<br>Linux 区分永久和非永久协议。永久协议包括像UDP和TCP，这是TCP&#x2F;IP 协议实现的基本部分，去掉一个永久协议是不允许的。所以，UDP和TCP是不能unregistered。此机制由2个函数和一个维护注册协议的数据结构组成。一个负责注册协议，另一个负责注销。每一个注册的协议都放在一个表里，叫<br><em><strong>协议切换表</strong></em>。</p><p>对于发送过程，直接调用IP层函数，而对于内核接收过程则分为2层：上层需要一个接收函数解复用传输协议报文，下层需要一个接收函数解复用网络层报文。报文从设备层送到上层之前，必须区分是IP报文还是ARP报文。</p><p>标识一个套接字的三元组:&lt;地址族，类型，具体协议&gt;。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核协议栈</category>
      
      
      <category domain="http://singlewang.top/tags/kernal/">kernal</category>
      
      <category domain="http://singlewang.top/tags/linux/">linux</category>
      
      <category domain="http://singlewang.top/tags/%E5%86%85%E6%A0%B8/">内核</category>
      
      
      <comments>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux内核协议栈-cp1</title>
      <link>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp1/</link>
      <guid>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp1/</guid>
      <pubDate>Tue, 03 May 2022 07:55:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;linux内核协议栈&quot;&gt;&lt;a href=&quot;#linux内核协议栈&quot; class=&quot;headerlink&quot; title=&quot;linux内核协议栈&quot;&gt;&lt;/a&gt;linux内核协议栈&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;1-协议栈概述&quot;&gt;&lt;a href=&quot;#1-协议栈概述&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="linux内核协议栈"><a href="#linux内核协议栈" class="headerlink" title="linux内核协议栈"></a>linux内核协议栈</h1><hr><h2 id="1-协议栈概述"><a href="#1-协议栈概述" class="headerlink" title="1.协议栈概述"></a>1.协议栈概述</h2><hr><h3 id="1-1操作系统及网络协议介绍"><a href="#1-1操作系统及网络协议介绍" class="headerlink" title="1.1操作系统及网络协议介绍"></a>1.1操作系统及网络协议介绍</h3><hr><h4 id="1-1-1linux操作系统架构简介"><a href="#1-1-1linux操作系统架构简介" class="headerlink" title="1.1.1linux操作系统架构简介"></a>1.1.1linux操作系统架构简介</h4><p>linux是一款大内核操作系统。</p><p>操作系统内核可能是微内核，也可能是大内核（后者有时称之为宏内核Macrokernel）。按照类似封装 的形式，这些术语定义如下:</p><ul><li>微内核（Microkernel kernel）――在微内核中，大部分内核都作为独立的进程在特权状态下运行， 它们通过消息传递进行通讯。微内核设计的一个优点是在不影响系统其它部分的情况下，用更高效的实现代替现有文件系统 模块的工作将会更加容易。我们甚至可以在系统运行时将开发出的新系统模块或者需要替换现有模块的 模块直接而且迅速的加入系统。另外一个优点是不需要的模块将不会被加载到内存中，因此微内核就可<br>以更有效的利用内存。</li><li>大内核（Monolithic kernel）――大内核是一个很大的进程。它的内部又可以被分为若干模块（或者是层次或其它）。但是在运行的时候，它是一个独立的二进制大映象。其模块间的通讯是通过直接调用其它模块中的函数实现的，而不是消息传递。</li></ul><blockquote><p>除了嵌入式，没有一款商用的操作系统是以真正学术上的微内核形式存在。</p></blockquote><h4 id="1-1-2网络协议发展介绍"><a href="#1-1-2网络协议发展介绍" class="headerlink" title="1.1.2网络协议发展介绍"></a>1.1.2网络协议发展介绍</h4><p>IP网络的优点，简单，IP协议栈的中心在于，使用IP协议将数据包发送到任何网络，数据包到达的时间可以不同。</p><p>事实上的网络协议栈实现基本采用TCP&#x2F;IP的4层架构，从底往上分别是：链路层，网络层，传输层，应用层。<br>但是在实际开发人员的眼中，却是五层，即在链路层之下还有一个物理层。</p><p>将链路层简称为2层或L2，网络层简称为3层或L3，而传输层即为4层或L4。</p><p>应用程序是可以绕过TCP层而直接与IP层协作，比如我们常用的 ping 命令。</p><h4 id="1-1-3基本的数据结构和计算机术语"><a href="#1-1-3基本的数据结构和计算机术语" class="headerlink" title="1.1.3基本的数据结构和计算机术语"></a>1.1.3基本的数据结构和计算机术语</h4><ul><li><p>链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ist_head 结构包含两个指向list_head结构的指针prev和next，通常它都组织成双循环链表。在 Linux内核链表中，不是在链表结构中包含数据，而是在数据结构中包含链表节点。</p></li><li><p>由链表节点到数据项变量<br>如何通过这个 list_head 成员访问到它的所有者呢？Linux 为此提供了一个 list_entry(ptr, type, member)宏，<br>ptr 是指向该数据中 list_head 成员的指针<br>type 是数据项的类型<br>member 则是数据项</p></li><li><p>hlist<br>hlist 是 hash list的简称，即用拉链法实现的 hash 数据结构。它由 2 部分组成：hash 数组和冲突链。当节点第一次要插入 hash 表的时候，它必定是先插入 hash 数组中，而以后要插入的节点如果发生了冲突，则可以挂在数组后面，形成一条链表。当然也可以插入数组，原先在数组中的节点被挤出来形成一条链表。</p></li></ul><p>也许Linux链表设计者认为双头（next、prev）的双链表对于HASH表来说”过于浪费”，因而另行设计了一套用于HASH表应用的 hlist 数据结构——单指针表头双循环链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span>, **<span class="title">pprev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核协议栈</category>
      
      
      <category domain="http://singlewang.top/tags/kernal/">kernal</category>
      
      <category domain="http://singlewang.top/tags/linux/">linux</category>
      
      <category domain="http://singlewang.top/tags/%E5%86%85%E6%A0%B8/">内核</category>
      
      
      <comments>http://singlewang.top/2022/05/03/linux/linux-kernal/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch2</title>
      <link>http://singlewang.top/2022/05/03/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch2/</link>
      <guid>http://singlewang.top/2022/05/03/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch2/</guid>
      <pubDate>Tue, 03 May 2022 07:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;传统网络设备驱动包处理的流程可以概括如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据包到达网卡设备&lt;/li&gt;
&lt;li&gt;网卡设备依据配置进行DMA操作&lt;/li&gt;
&lt;li&gt;网卡发送中断，唤醒处理器&lt;/li&gt;
&lt;li&gt;驱动软件填充读写缓冲区数据结构&lt;/li&gt;
&lt;li&gt;数据报文到达内核协议栈</description>
        
      
      
      
      <content:encoded><![CDATA[<p>传统网络设备驱动包处理的流程可以概括如下:</p><ul><li>数据包到达网卡设备</li><li>网卡设备依据配置进行DMA操作</li><li>网卡发送中断，唤醒处理器</li><li>驱动软件填充读写缓冲区数据结构</li><li>数据报文到达内核协议栈，进行高层处理</li><li>如果最终应用在用户态，数据从内核搬移到用户态</li><li>如果最终应用在内核态，在内核继续进行</li></ul><h2 id="2-cache和内存"><a href="#2-cache和内存" class="headerlink" title="2.cache和内存"></a>2.cache和内存</h2><h3 id="2-1存储系统简介"><a href="#2-1存储系统简介" class="headerlink" title="2.1存储系统简介"></a>2.1存储系统简介</h3><h4 id="2-1-1系统架构的演进"><a href="#2-1-1系统架构的演进" class="headerlink" title="2.1.1系统架构的演进"></a>2.1.1系统架构的演进</h4><p>在经典计算机系统中一般有两个标准化的部分:<em><strong>北桥</strong></em>和<em><strong>南桥</strong></em></p><ul><li>北桥也称为主桥，主要用来处理高速信号，通常负责与处理器的联系，并控制内存AGP、PCI数据在北桥内部传输。</li><li>南桥也称为I&#x2F;O桥，负责I&#x2F;O总线之间的通信，比如:PCI总线，SATA,USB等。</li></ul><p>在这种系统中，所有的数据交换都需要通过北桥:</p><ol><li>处理器访问内存需要通过北桥</li><li>处理器方位所有的外设</li><li>处理器之间的数据交换</li><li>挂在南桥的设备访问内存</li></ol><p>因此可以看出，这种系统的瓶颈就在北桥中。为了解决这个瓶颈，于是产生了NUMA(Non-Uniform Memory Architecture 非一致性内存架构)。在这种架构下，在一个拥有四核的机器中，不需要一个复杂的北桥就能将内存宽带增加到以前的四倍</p><h3 id="2-2-cache系统简介"><a href="#2-2-cache系统简介" class="headerlink" title="2.2 cache系统简介"></a>2.2 cache系统简介</h3><blockquote><p>为什么要提出cache的概念？<br>虽然随着DDR4，DDR5技术的不断推出，内存的吞吐率得到了很大提升，但是相对于处理器来说任然很慢，一般来讲，处理器要从内存中直接读取数据要花大概几百个时钟周期，在这期间，处理器除了等待什么也不能做。为了匹配处理器和内存之间存在巨大的速度差距，才提出了cache的概念。</p></blockquote><h4 id="2-2-1cache的种类"><a href="#2-2-1cache的种类" class="headerlink" title="2.2.1cache的种类"></a>2.2.1cache的种类</h4><p>一般来说，cache由三级组成，一级最快，但是容量最小，三级最慢，但是容量最大。cache是一种SRAM</p><ul><li>一级cache，一般分为数据cache和指令cache，数据cache用来存放数据，指令cache用来存放指令。一般只有几十KB。</li><li>二级cache，数据cache和指令cache无差别存放在一起。一般有几百KB到几MB。</li><li>三级cache，一般有几MB到几十个MB。</li></ul><p>对于各级cache的访问时间，在英特尔处理器上一般是一级cache访问是4个指令周期。二级cache是<br>12个指令周期，三级cache是26~31个指令周期。</p><h3 id="2-3Cache地址映射和变换"><a href="#2-3Cache地址映射和变换" class="headerlink" title="2.3Cache地址映射和变换"></a>2.3Cache地址映射和变换</h3><p>由于内存大，cache容量小，如何把内存中的内容存放到cache中?需要一个映射算法和一个分块机制。</p><p>分块机制就是cache和内存以块为单位进行数据交换，块的大小通常以在内粗的一个存储周期中能够访问到的数据长度为限。主流块的大小都是64字节，因此一个cache line就是64个字节大小的数据块。</p><p>映射算法是指把内存地址空间映射到cache地址空间。<br>根据cache和内存之间的映射关系的不同，cache可以分为三类;全关联型cache，直接关联型cache，组关联型cache</p><h4 id="2-3-1全关联型cache"><a href="#2-3-1全关联型cache" class="headerlink" title="2.3.1全关联型cache"></a>2.3.1全关联型cache</h4><p>全关联型cache是指主存中的任何一块内存都可以映射到cache中的任意一块位置上。在cache中，需要建立一个目录表，目录表的每个表项都有三部分组成：内存地址、cache块号和一个有效位。<br>使用全关联型cache，块冲突最小，cache的利用率也高，但是需要一个访问速度很快的相联存储器。一般只有容量很小的cache才会设计成全关联型的。</p><h4 id="2-3-2直接关联型cache"><a href="#2-3-2直接关联型cache" class="headerlink" title="2.3.2直接关联型cache"></a>2.3.2直接关联型cache</h4><p>直接关联型cache是指主存中的一块内存只能映射到cache的一个特定的块中。假设一个cache中总共存在N个cache line，那么内存被分成N等分，其中每一等分对应一个cache line。直接关联型cache的目录表只有两部分组成，区号和有效位。<br>直接关联型cache命中率最低，但是实现方式最简单，匹配速度也最快。</p><h4 id="2-3-3组关联型cache"><a href="#2-3-3组关联型cache" class="headerlink" title="2.3.3组关联型cache"></a>2.3.3组关联型cache</h4><p>组关联型Cache是目前Cache中用的比较广泛的一种方式，是前两种Cache的折中形式。在这种方式下，内存被分为很多组，一个组的大小为多个Cache line的大小，一个组映射到对应的多个连续的Cache line，也就是一个Cache组，并且该组内的任意一块可以映射到对应 Cache组的任意一个。可以看出，在组外，其采用直接关联型Cache的映射方式，而在组内，则采用全关联型Cache的映射方式。</p><h3 id="2-4cache的写策略"><a href="#2-4cache的写策略" class="headerlink" title="2.4cache的写策略"></a>2.4cache的写策略</h3><p>内存的数据被加载到cache后，在某个时刻要被写回内存，有如下策略：</p><ul><li><em><strong>直写</strong></em>，就是在处理器对cache写入的同时，将数据写入到内存中，这种策略保证了在任何时刻，内存的数据和cache中的数据都是同步的。但是由于处理器每次对cache更新时都要对内存进行写操作，因此总线繁忙，占用了大量内存带宽。运行速度会受影响。</li><li><em><strong>回写</strong></em>，回写系统通过将cache line的标志位添加上一个Dirty标志位，当处理器在改写了某个cache line后，并不是马上把其协会内存，而是将cache line的Dirty标志位置为1.当处理器查表发现该标志位为1时，先将cache line内容写回到内存中，再将新数据写到cache中。</li></ul><blockquote><p>回写系统在多核系统中会引起cache一致性的问题。</p></blockquote><h3 id="2-5cache预取"><a href="#2-5cache预取" class="headerlink" title="2.5cache预取"></a>2.5cache预取</h3><h4 id="2-5-1cache预取原理"><a href="#2-5-1cache预取原理" class="headerlink" title="2.5.1cache预取原理"></a>2.5.1cache预取原理</h4><p>cache之所以能够提高系统性能，主要是程序执行存在局部性现象，即时间局部性和空间局部性。</p><ol><li>时间局部性：是指程序即将用到的指令&#x2F;数据可能就是目前正在使用的指令&#x2F;数据。比如一个循环语句的指令，在循环终止的条件满足之前，处理器需要反复执行循环语句中的指令</li><li>空间局部性：是指程序即将用到的指令&#x2F;数据可能与目前正在使用的指令&#x2F;数据在空间上相邻或相近。比如一个需要顺序处理的数组。</li></ol><p>所谓的cache预取就是预测数据并取入到cache中，是根据空间局部性和时间局部性等在数据&#x2F;指令被使用前取入cache。</p><h4 id="2-5-2DPDK中的预取"><a href="#2-5-2DPDK中的预取" class="headerlink" title="2.5.2DPDK中的预取"></a>2.5.2DPDK中的预取</h4><p>报文处理的基本过程：</p><ol><li>写接收描述符到内存，填充数据缓冲区指针，网卡收到报文后 就会根据这个地址把报文内容填充进去。</li><li>从内存中读取接收描述符（当收到报文时，网卡会更新该结构）（内存读），从而确认是否收到报文。</li><li>从接收描述符确认收到报文时，从内存中读取控制结构体的指针（内存读），再从内存中读取控制结构体（内存读），把从接收描述符读取的信息填充到该控制结构体。</li><li>更新接收队列寄存器，表示软件接收到了新的报文。 </li><li>内存中读取报文头部（内存读），决定转发端口。</li><li>从控制结构体把报文信息填入到发送队列发送描述符，更新发送队列寄存器。 </li><li>从内存中读取发送描述符（内存读），检查是否有包被硬件传送出去。 </li><li>如果有的话，从内存中读取相应控制结构体（内存读），释放数据缓冲区。</li></ol><p>DPDK必须保证所有需要读取的数据都在cache中，否则一旦出现cache不命中，性能将会严重下降。<br>以下是报文接收部分代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (nb_rx &lt; nb_pkts) &#123; </span><br><span class="line">    rxdp = &amp;rx_ring[rx_id]; </span><br><span class="line">    <span class="comment">//读取接收描述符 </span></span><br><span class="line">    staterr = rxdp-&gt;wb.upper.status_error; </span><br><span class="line">    <span class="comment">//检查是否有报文收到</span></span><br><span class="line">    <span class="keyword">if</span> (!(staterr &amp; rte_cpu_to_le_32(IXGBE_RXDADV_STAT_DD))) <span class="keyword">break</span>;</span><br><span class="line">    rxd = *rxdp; </span><br><span class="line">    <span class="comment">//分配数据缓冲区</span></span><br><span class="line">    nmb = rte_rxmbuf_alloc(rxq-&gt;mb_pool); </span><br><span class="line">    nb_hold++; </span><br><span class="line">    <span class="comment">//读取控制结构体</span></span><br><span class="line">    rxe = &amp;sw_ring[rx_id]; ……</span><br><span class="line">    rx_id++;</span><br><span class="line">    <span class="keyword">if</span> (rx_id == rxq-&gt;nb_rx_desc) rx_id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//预取下一个控制结构体mbuf</span></span><br><span class="line">    rte_ixgbe_prefetch(sw_ring[rx_id].mbuf); </span><br><span class="line">    <span class="comment">//预取接收描述符和控制结构体指针 </span></span><br><span class="line">    <span class="keyword">if</span> ((rx_id &amp; <span class="number">0x3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        rte_ixgbe_prefetch(&amp;rx_ring[rx_id]); </span><br><span class="line">        rte_ixgbe_prefetch(&amp;sw_ring[rx_id]);</span><br><span class="line">&#125;</span><br><span class="line">…… </span><br><span class="line">    <span class="comment">//预取报文</span></span><br><span class="line">    rte_packet_prefetch((<span class="type">char</span> *)rxm-&gt;buf_addr + rxm-&gt;data_off); </span><br><span class="line">    <span class="comment">//把接收描述符读取的信息存储在控制结构体mbuf中 </span></span><br><span class="line">    rxm-&gt;nb_segs = <span class="number">1</span>; </span><br><span class="line">    rxm-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">    rxm-&gt;pkt_len = pkt_len; </span><br><span class="line">    rxm-&gt;data_len = pkt_len; </span><br><span class="line">    rxm-&gt;port = rxq-&gt;port_id; ……</span><br><span class="line">    rx_pkts[nb_rx++] = rxm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6cache一致性"><a href="#2-6cache一致性" class="headerlink" title="2.6cache一致性"></a>2.6cache一致性</h3><h4 id="2-6-1cache一致性问题的由来及解决办法"><a href="#2-6-1cache一致性问题的由来及解决办法" class="headerlink" title="2.6.1cache一致性问题的由来及解决办法"></a>2.6.1cache一致性问题的由来及解决办法</h4><p>当多个处理器对某个内存块同时读写时，同时对内存进行写回操作时，便会引起冲突，这便是cache一致性问题。<br>cache一致性问题出现的原因时在一个多处理器系统中，每个处理器核心都有独占的cache系统，因此当他们独立执行计算机指令时，有可能同时对某个内存块进行读写操作。<br>cache一致性问题的根源是因为存在多个处理器独占的cache而不是多个处理器。<br>解决办法：两种机制</p><ol><li>基于目录的协议<br>需要缓存在cache的内存块被统一存储在一个目录表中，目录表统一管理所有的数据。<br>特点：延迟性较大，有更好的扩展性</li><li>总线窥探协议<br>提出了一个窥探的动作，即对于被处理器独占的cache中的缓存的内容，该处理器负责监听总线，如果该内容被本处理器修改，则需要总线广播，繁殖如果本处理器的cache从总线收到了通知，则需要改变本地备份的状态。<br>适用于具有广播能力的总线结构。<h4 id="2-6-3DPDK如何保证cache一致性"><a href="#2-6-3DPDK如何保证cache一致性" class="headerlink" title="2.6.3DPDK如何保证cache一致性"></a>2.6.3DPDK如何保证cache一致性</h4>dpdk的解决方案很简单，首先就是避免多个核访问同一个内存地址或者数据结构。这样每个核都避免与其他核共享数据，从而减少因为错误的数据共享导致的cache一致性的开销。</li></ol>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/cache/">cache</category>
      
      <category domain="http://singlewang.top/tags/%E5%86%85%E5%AD%98/">内存</category>
      
      
      <comments>http://singlewang.top/2022/05/03/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux命令</title>
      <link>http://singlewang.top/2022/05/03/linux/linux-command/linux%E5%91%BD%E4%BB%A4/</link>
      <guid>http://singlewang.top/2022/05/03/linux/linux-command/linux%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Tue, 03 May 2022 03:24:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;.    #当前文件夹&lt;br&gt;..   #上一级文件夹&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;tar&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;tar -zxvf             解压缩&lt;br&gt;tar -zcv</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>.    #当前文件夹<br>..   #上一级文件夹</p></blockquote><hr><p><em><strong>tar</strong></em><br>tar -zxvf             解压缩<br>tar -zcvf             压缩</p><blockquote><p>解压tar.xz文件时<br>xz -d xxx.tar.xz 之后会得到xxx.tar文件<br>再执行tar -xvf xxx.tar即可</p></blockquote><p><em>~&#x2F;.bash_history 记录了所有的历史命令</em><br>执行history中的某一句，只需用！加行号<br><code>!1322</code></p><hr><p><em><strong>find</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find ./home/wang -name test.txt  在/home/wang路径下寻找test.txt文件</span><br><span class="line"></span><br><span class="line">find ./home/wang -name <span class="string">&quot;*.c&quot;</span> 在/home/wang路径下寻找所有后缀为.c的文件</span><br></pre></td></tr></table></figure><hr><p><em><strong>grep</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep -i -n &quot;hello&quot; ./*.cpp 在当前文件夹下所有的.cpp文件中查找hello字符串，-n 并且打印行号，-i 不区分大小写</span><br><span class="line">grep -r &quot;include&quot; ./*.cpp 在当前文件夹下所有的.cpp文件中查找include字符串，-r 并且打印文件路径</span><br><span class="line">ls | grep -n &#x27;.c$&#x27;  列出所有的.c文件</span><br><span class="line">grep shell ed.md 在文件ed.md中查找所有的单词shell</span><br></pre></td></tr></table></figure><hr><p><em><strong>环境变量</strong></em><br>查看全局变量 <code>env</code> 或者 <code>printenv</code><br><code>export PATH=$PATH:/home/wang</code>        将某个路径添加到环境变量中，只能生效一次，待重启之后依然需要重新添加<br><code>echo</code> 显示变量的值<br><code>echo $PATH</code> 取出变量PATH的内容</p><hr><p><em><strong>vim</strong></em><br>vim常用命令：<br><code>yy</code> 复制光标所指的当前行<br><code>nyy</code> 复制光标所指的一行往下n行<br><code>p</code> 粘贴在光标以下<br><code>P</code> 粘贴在光标以上<br><code>dd</code> 删除光标所指的一行<br><code>ndd</code> 删除光标所指的往下n行<br><code>set nu</code> 显示行号</p><hr><blockquote><p>反单引号&#96;&#96;&#96;这个符号代表的意义为何？<br>在一串指令中，在”&#96;”之内的指令会被先执行，而其执行出来的结果将作为外部的输入信息</p></blockquote><hr><p><code>uname -a</code> 查看当前内核版本</p><p><code>?</code>代表一个字符<br><code>*</code> 代表零个或多个字符</p><hr><p><em><strong>进程</strong></em><br><code>ps</code>                查看进程<br><code>top</code>               显示实时进程<br><code>kill 3445</code>(端口号)  结束进程 </p><p><code>ctrl+c</code>             中断进程<br><code>ctrl+z</code>              暂停进程 </p><hr><p><code>rmdir</code> 删除目录<br><code>rm -rf</code> 强制删除目录，即使目录下面有文件<br>要想同时创建多个目录和子目录，需要加入-p参数<br><code>mkdir -p new_dir/sub_dir/under_dir</code><br><code>tree</code> 目录以树的形式列出目录中的所有文件<br><code>file</code>  查看文件类型<br><code>cat file1</code> 显示文件内容<br><code>cat -n file1</code> 给显示的文件内容加上行号<br><code>cat -b file</code>   只给文件中有内容的加上行号</p><p><code>du</code>显示当前目录下所有的文件、目录、子目录的磁盘使用情况:</p><ul><li>-c  显示所有已列出文件的大小</li><li>-h 以易读形式显示</li><li>-s 显示每个输出参数的总计</li></ul><hr><p><em><strong>挂载</strong></em><br>要手动在虚拟目录中挂载设备，需要以root用户身份登录，或是以root用户身份运行sudo命<br>令。下面是手动挂载媒体设备的基本命令：<br><code>mount -t type device directory</code></p><blockquote><p>&#x3D;&#x3D;文件类型&#x3D;&#x3D;：<br><em>vfat</em>：Windows长文件系统。<br><em>ntfs</em>：Windows NT、XP、Vista以及Windows 7中广泛使用的高级文件系统。<br><em>iso9660</em>：标准CD-ROM文件系统。</p></blockquote><p>手动将U盘&#x2F;dev&#x2F;sdb1挂载到&#x2F;media&#x2F;disk，可用下面的命令：<br><code>mount -t vfat /dev/sdb1 /media/disk</code></p><ul><li>从Linux系统上移除一个可移动设备时，不能直接从系统上移除，而应该先卸载。</li><li>Linux上不能直接弹出已挂载的CD。如果你在从光驱中移除CD时遇到麻烦，通常是因为该CD还挂载在虚拟目录里。先卸载它，然后再去尝试弹出。</li></ul><p><code>df -h</code> 查看所有已挂载磁盘的使用情况，-h把磁盘空间以易读的形式显示</p><hr><p><em><strong>sort</strong></em><br><code>sort</code> 按指定的默认语言的排序规则对文件中的数据进行排序</p><ul><li>-d 仅考虑空白和字母</li><li>-n 按字符串数值排序</li><li>-u 消除输出中重复的行</li><li>-r 逆序排列</li><li>-o 指定输出文件</li></ul><hr>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-command/">Linux命令</category>
      
      
      <category domain="http://singlewang.top/tags/Linux/">Linux</category>
      
      <category domain="http://singlewang.top/tags/Linux%E5%91%BD%E4%BB%A4/">Linux命令</category>
      
      
      <comments>http://singlewang.top/2022/05/03/linux/linux-command/linux%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DPDK基础</title>
      <link>http://singlewang.top/2022/04/29/dpdk/dpdk-base/dpdk/</link>
      <guid>http://singlewang.top/2022/04/29/dpdk/dpdk-base/dpdk/</guid>
      <pubDate>Fri, 29 Apr 2022 03:12:00 GMT</pubDate>
      
        
        
      <description>&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#-dpdk%E5%AD%A6%</description>
        
      
      
      
      <content:encoded><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#-dpdk%E5%AD%A6%E4%B9%A0"># DPDK学习</a></li><li><a href="#-1dpdk%E7%AE%80%E4%BB%8B">## 1.DPDK简介</a></li><li><a href="#-11dpdk%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84">### 1.1DPDK软件架构</a><ul><li><a href="#111%E5%BA%95%E9%83%A8%E5%86%85%E6%A0%B8%E6%80%81">1.1.1底部内核态</a></li><li><a href="#2%E4%B8%8A%E5%B1%82%E7%94%A8%E6%88%B7%E6%80%81">2上层用户态</a></li><li><a href="#12%E5%B7%A8%E9%A1%B5%E6%8A%80%E6%9C%AF">1.2巨页技术</a></li><li><a href="#13%E8%BD%AE%E8%AF%A2%E6%8A%80%E6%9C%AF">1.3轮询技术</a></li><li><a href="#14cpu%E4%BA%B2%E5%92%8C%E6%8A%80%E6%9C%AF">1.4CPU亲和技术</a></li><li><a href="#15dpdk%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0">1.5DPDK性能影响因素</a></li><li><a href="#16%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">1.6内存管理</a><ul><li><a href="#161%E5%86%85%E5%AD%98%E5%A4%9A%E9%80%9A%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8">1.6.1内存多通道的使用</a></li><li><a href="#162%E5%86%85%E5%AD%98%E5%A4%8D%E5%88%B6">1.6.2内存复制</a></li><li><a href="#163%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">1.6.3内存分配</a></li><li><a href="#164numa%E6%9E%B6%E6%9E%84">1.6.4NUMA架构</a></li><li><a href="#165cpu%E6%A0%B8%E9%97%B4%E6%97%A0%E9%94%81%E9%80%9A%E4%BF%A1">1.6.5CPU核间无锁通信</a></li></ul></li></ul></li><li><a href="#-2dpdk%E5%BA%93%E5%87%BD%E6%95%B0">## 2.DPDK库函数</a></li><li><a href="#-%E4%BB%8E%E4%BB%A3%E7%A0%81%E8%A7%92%E5%BA%A6rte%E6%98%AF%E6%8C%87runtime-environmenteal%E6%98%AF%E6%8C%87environment-abstraction-layerdpdk%E7%9A%84%E4%B8%BB%E8%A6%81%E5%AF%B9%E5%A4%96%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%E9%83%BD%E6%98%AF%E4%BB%A5rte_%E4%BD%9C%E4%B8%BA%E5%89%8D%E7%BC%80%E6%8A%BD%E8%B1%A1%E5%8C%96%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%85%B8%E5%9E%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF">&gt; 从代码角度，rte是指<code>runtime environment</code>,eal是指<code>environment abstraction layer</code>。dpdk的主要对外函数接口都是以rte_作为前缀，抽象化函数接口是典型的软件设计思路。</a><ul><li><a href="#21eal%E5%BA%93">2.1EAL库</a><ul><li><a href="#211%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8">2.1.1内核初始化与启动</a></li><li><a href="#212%E5%86%85%E5%AD%98">2.1.2内存</a></li><li><a href="#213%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BA%B2%E5%92%8C%E6%80%A7">2.1.3多线程与亲和性</a></li></ul></li><li><a href="#2ring%E5%BA%93">2.Ring库</a><ul><li><a href="#221%E5%8D%95%E6%B6%88%E8%B4%B9%E8%80%85%E5%85%A5%E9%98%9F">2.2.1单消费者入队</a></li><li><a href="#222%E5%8D%95%E6%B6%88%E8%B4%B9%E8%80%85%E5%87%BA%E9%98%9F">2.2.2单消费者出队</a></li></ul></li><li><a href="#23mempool%E5%BA%93">2.3Mempool库</a></li><li><a href="#24mbuf%E5%BA%93">2.4mbuf库</a><ul><li><a href="#241%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8">2.4.1数据存储</a></li><li><a href="#242%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE">2.4.2缓冲区分配与释放</a></li><li><a href="#243%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C">2.4.3相关操作</a></li></ul></li><li><a href="#25pmd%E9%A9%B1%E5%8A%A8">2.5PMD驱动</a></li><li><a href="#26ivshmem%E5%BA%93">2.6IVSHMEM库</a></li><li><a href="#27timer%E5%BA%93">2.7Timer库</a></li><li><a href="#28-lpm%E5%BA%93">2.8 LPM库</a></li><li><a href="#29hash%E5%BA%93">2.9Hash库</a></li><li><a href="#210%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%94%AF%E6%8C%81">2.10多进程支持</a></li></ul></li><li><a href="#3dpdk%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2">3DPDK安装与部署</a><ul><li><a href="#31%E8%BF%90%E8%A1%8Cdpdk%E5%BA%94%E7%94%A8%E8%A6%81%E6%B1%82">3.1运行DPDK应用要求</a></li><li><a href="#32%E4%BD%BF%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91dpdk">3.2使用源代码编译DPDK</a><ul><li><a href="#321%E5%AE%89%E8%A3%85dpdk%E5%AE%89%E8%A3%85%E5%8C%85">3.2.1安装DPDK安装包</a></li><li><a href="#322%E5%AE%89%E8%A3%85dpdk%E7%9B%AE%E6%A0%87%E7%8E%AF%E5%A2%83">3.2.2安装DPDK目标环境</a></li><li><a href="#323%E6%9F%A5%E7%9C%8B%E5%B7%B2%E7%BB%8F%E5%AE%89%E8%A3%85%E7%9A%84dpdk%E7%8E%AF%E5%A2%83">3.2.3查看已经安装的DPDK环境</a></li><li><a href="#324%E5%90%AF%E7%94%A8dpdk%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4io%E6%A8%A1%E5%9D%97">3.2.4启用DPDK用户空间I&#x2F;O模块</a></li><li><a href="#325%E5%8A%A0%E8%BD%BDvfio%E6%A8%A1%E5%9D%97">3.2.5加载VFIO模块</a></li><li><a href="#326%E5%9C%A8%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BB%91%E5%AE%9A%E8%A7%A3%E9%99%A4%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3">3.2.6在内核模块绑定&#x2F;解除网络端口</a></li></ul></li><li><a href="#33%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B%E7%A8%8B%E5%BA%8F">3.3编译和运行实例程序</a><ul><li><a href="#331%E7%BC%96%E8%AF%91%E7%A4%BA%E4%BE%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">3.3.1编译示例应用程序</a></li><li><a href="#332%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">3.3.2运行实例应用程序</a></li><li><a href="#333%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%80%BB%E8%BE%91%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8">3.3.3应用程序的逻辑核的使用</a></li></ul></li></ul></li><li><a href="#-34%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E9%85%8D%E7%BD%AE">### 3.4使用脚本配置</a></li><li><a href="#-4dpdk%E8%87%AA%E5%B8%A6%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95">## 4DPDK自带应用软件调试</a><ul><li><a href="#41%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8%E4%BE%8B">4.1命令行应用例</a></li><li><a href="#42helloworld%E5%BA%94%E7%94%A8%E4%BE%8B">4.2HelloWorld应用例</a><ul><li><a href="#421%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E">4.2.1代码说明</a></li></ul></li><li><a href="#43l2%E8%BD%AC%E5%8F%91%E5%BA%94%E7%94%A8%E4%BE%8B">4.3L2转发应用例</a><ul><li><a href="#431%E6%A6%82%E8%BF%B0">4.3.1概述</a></li></ul></li></ul></li><li><a href="#-44l3%E8%BD%AC%E5%8F%91%E5%BA%94%E7%94%A8%E4%BE%8B">### 4.4L3转发应用例</a><ul><li><a href="#441%E6%A6%82%E8%BF%B0">4.4.1概述</a></li><li><a href="#442%E8%BF%90%E8%A1%8C%E8%BD%AC%E5%8F%91%E5%BA%94%E7%94%A8%E4%BE%8B">4.4.2运行转发应用例</a></li><li><a href="#443%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E">4.4.3代码说明</a></li><li><a href="#45qos%E8%B0%83%E5%BA%A6%E5%BA%94%E7%94%A8%E4%BE%8B">4.5QoS调度应用例</a><ul><li><a href="#451%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E">4.5.1代码说明</a></li></ul></li><li><a href="#46%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BA%94%E7%94%A8%E4%BE%8B">4.6定时器应用例</a><ul><li><a href="#461%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E">4.6.1代码说明</a></li></ul></li><li><a href="#47%E5%9F%BA%E6%9C%AC%E8%BD%AC%E5%8F%91%E5%BA%94%E7%94%A8%E4%BE%8Bskeleton">4.7基本转发应用例(skeleton)</a><ul><li><a href="#471%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E">4.7.1代码说明</a></li></ul></li></ul></li><li><a href="#5dpdk%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91">5DPDK应用开发</a><ul><li><a href="#51%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87">5.1网卡设备</a><ul><li><a href="#511%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8">5.1.1设备驱动</a></li><li><a href="#512%E5%BA%94%E7%94%A8%E6%8E%A5%E5%8F%A3">5.1.2应用接口</a></li><li><a href="#513%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3">5.1.3设备接口</a></li></ul></li><li><a href="#52%E8%BF%9B%E7%A8%8B">5.2进程</a><ul><li><a href="#521-%E7%BA%BF%E7%A8%8B">5.2.1 线程</a></li><li><a href="#522%E5%8D%95%E8%BF%9B%E7%A8%8B">5.2.2单进程</a></li><li><a href="#523%E5%A4%9A%E8%BF%9B%E7%A8%8B">5.2.3多进程</a></li></ul></li></ul></li></ul><!-- /code_chunk_output --><h1 id="DPDK学习"><a href="#DPDK学习" class="headerlink" title="DPDK学习"></a>DPDK学习</h1><hr><h2 id="1-DPDK简介"><a href="#1-DPDK简介" class="headerlink" title="1.DPDK简介"></a>1.DPDK简介</h2><hr><h3 id="1-1DPDK软件架构"><a href="#1-1DPDK软件架构" class="headerlink" title="1.1DPDK软件架构"></a>1.1DPDK软件架构</h3><hr><h4 id="1-1-1底部内核态"><a href="#1-1-1底部内核态" class="headerlink" title="1.1.1底部内核态"></a>1.1.1底部内核态</h4><p>最底部的内核态有两个模块组成：<code>KNI</code>和<code>IGB_UIO</code>模块，KNI提供给用户一个使用linux内核态的协议栈以及传统的linux网络工具，IGB_UIO借助UIO技术，在初始化过程中件将硬件寄存器映射到用户态。</p><p><em>UIO技术</em></p><hr><h4 id="2上层用户态"><a href="#2上层用户态" class="headerlink" title="2上层用户态"></a>2上层用户态</h4><p>上层用户态主要包括核心部件库，平台相关模块，轮询驱动模式驱动模块。</p><hr><h3 id="1-2巨页技术"><a href="#1-2巨页技术" class="headerlink" title="1.2巨页技术"></a>1.2巨页技术</h3><p>处理器的内存怒管理包含两个概念：物理内存和虚拟内存，linux操作系统中，物理内存按照帧管理，虚拟内存按照页管理。Intel处理使用一块缓存保存地址转换查找的结果，缓存称为<code>TLB(Translation Lookaside Buffer)</code>，如果查找不到相应的映射，就会发生<code>TLB miss</code>，而linux的一般页的大小为4KB，为了减少TLB miss的发生则采用2M或者1GB的大页表。DPDK则利用巨页技术，所有的内存都从巨页里分配，实现对内存池的管理，并预先分配好同样大小的<code>mbuf</code>,給数据分组使用</p><hr><h3 id="1-3轮询技术"><a href="#1-3轮询技术" class="headerlink" title="1.3轮询技术"></a>1.3轮询技术</h3><p>传统网卡的报文接收&#x2F;发送过程中，网卡硬件接收到网络报文，需要发送中断到CPU,通知应用软件有网络报文需要处理。对于高性能的网络处理应用，频繁的中断处理开销极大程度的降低了网络应用程序的性能。</p><p>DPDK使用轮询技术处理网络报文。网卡接收到报文之后，直接将报文保存在处理器缓存中，应用软件周期性的轮询是否有新报文处理。整个过程没有中断。</p><hr><h3 id="1-4CPU亲和技术"><a href="#1-4CPU亲和技术" class="headerlink" title="1.4CPU亲和技术"></a>1.4CPU亲和技术</h3><p>CPU亲和技术就是将某个进程或者线程绑定到特定的一个或者多个核上执行，而不被迁移到其他核上，保证了专用程序的性能。</p><hr><h3 id="1-5DPDK性能影响因素"><a href="#1-5DPDK性能影响因素" class="headerlink" title="1.5DPDK性能影响因素"></a>1.5DPDK性能影响因素</h3><p>&#x3D;&#x3D;CPU频率越高，DPDK性能越高&#x3D;&#x3D;<br>&#x3D;&#x3D;缓存越大，DPDK性能越高&#x3D;&#x3D;<br>&#x3D;&#x3D;PCIe数据通路的数目&#x3D;&#x3D;<br>&#x3D;&#x3D;NUMA&#x3D;&#x3D; </p><p><em>NUMA</em></p><hr><h3 id="1-6内存管理"><a href="#1-6内存管理" class="headerlink" title="1.6内存管理"></a>1.6内存管理</h3><p>降低访存开销。无论是CPU指令还是DMA，对于内存子系统都会访问频繁。利用已知的方法来减少访存的开销能够有效地提升性能。</p><hr><h4 id="1-6-1内存多通道的使用"><a href="#1-6-1内存多通道的使用" class="headerlink" title="1.6.1内存多通道的使用"></a>1.6.1内存多通道的使用</h4><p>现代的内存控制器都支持内存多通道，每个通道都有一个带宽上限，如果内存访问都在一个通道上，就会造成性能瓶颈。<br>DPDK的<code>Mempool</code>库把所有的对象分配在不同的内存通道上，保证尽可能的将内存访问均匀平滑的进行。</p><hr><h4 id="1-6-2内存复制"><a href="#1-6-2内存复制" class="headerlink" title="1.6.2内存复制"></a>1.6.2内存复制</h4><p>不要使用<code>memcpy()</code>或<code>strcpy()</code>,DPDK提供了<code>rte_memcpy()</code>.</p><hr><h4 id="1-6-3内存分配"><a href="#1-6-3内存分配" class="headerlink" title="1.6.3内存分配"></a>1.6.3内存分配</h4><p>不建议使用<code>malloc()</code>，DPDK提供了<code>rte_malloc()</code>。</p><hr><h4 id="1-6-4NUMA架构"><a href="#1-6-4NUMA架构" class="headerlink" title="1.6.4NUMA架构"></a>1.6.4NUMA架构</h4><p><code>NUMA（非统一访问内存）</code>架构<code>SMP(对称多处理)</code>架构是两种典型的内存访问架构</p><hr><h4 id="1-6-5CPU核间无锁通信"><a href="#1-6-5CPU核间无锁通信" class="headerlink" title="1.6.5CPU核间无锁通信"></a>1.6.5CPU核间无锁通信</h4><p>如果想建立一个基于消息传递的核间通信机制，可以使用DPDK ring API，该API是一个无锁的实现。支持批量和突发访问。</p><hr><h2 id="2-DPDK库函数"><a href="#2-DPDK库函数" class="headerlink" title="2.DPDK库函数"></a>2.DPDK库函数</h2><hr><p><code>rte_eal(DPDK环境抽象)</code>以及<code>libc(Linux下的c函数库)</code>是核心组件</p><blockquote><p>从代码角度，rte是指<code>runtime environment</code>,eal是指<code>environment abstraction layer</code>。dpdk的主要对外函数接口都是以rte_作为前缀，抽象化函数接口是典型的软件设计思路。</p></blockquote><hr><h3 id="2-1EAL库"><a href="#2-1EAL库" class="headerlink" title="2.1EAL库"></a>2.1EAL库</h3><p>EAL(环境抽象层)用于获取底层资源。主要提供DPDK装载与启动，内核亲和性与分配，系统内存预留等服务。<br>在内存层面，EAL通过<code>mmap()</code>函数在巨页表内进行物理内存分配。以此来提高性能。</p><hr><h4 id="2-1-1内核初始化与启动"><a href="#2-1-1内核初始化与启动" class="headerlink" title="2.1.1内核初始化与启动"></a>2.1.1内核初始化与启动</h4><p>内核初始化由<a href="http://www.dpdk.org/doc/api/"><code>rte_eal_init()</code></a>完成。主要包括内存，日志，PCI等方面的初始化工作。同时启动逻辑核线程。<br>EAL主要由<code>pthread</code>的库的调用组成，主要函数有<code>pthread_self()</code>,<code>pthread_creat()</code>,<code>pthread_setaffinity_np()</code>。</p><hr><h4 id="2-1-2内存"><a href="#2-1-2内存" class="headerlink" title="2.1.2内存"></a>2.1.2内存</h4><p>物理内存映射EAL的特点，物理内存可以是不连续的，EAL通过描述符来描述内存，每一个描述符表示一个连续的内存分配。</p><hr><h4 id="2-1-3多线程与亲和性"><a href="#2-1-3多线程与亲和性" class="headerlink" title="2.1.3多线程与亲和性"></a>2.1.3多线程与亲和性</h4><p>DPDK通常采用一个核匹配一个线程避免过度切换，但是缺乏灵活性。<br>为了提升灵活性，目前方法是设置线程与CPU以及CPU集合的亲和性。有两个公共线程API供使用。<code>rte_thread_set_affinity</code>,<code>rte_pthread_get_affinity</code>。</p><hr><h3 id="2-Ring库"><a href="#2-Ring库" class="headerlink" title="2.Ring库"></a>2.<span class="exturl" data-url="aHR0cDovL3d3dy5kcGRrLm9yZy9kb2MvZ3VpZGVzL3Byb2dfZ3VpZGUvcmluZ19saWIuaHRtbA==">Ring库</span></h3><p>DPDK中的Ring库用于管理队列，主要属性如下：</p><ul><li>FIFO;</li><li>可以设置空间最大值，指针存储在表中；</li><li>多消费者或者单消费者出队，&#x3D;&#x3D;消费者是指数据对象出队机制&#x3D;&#x3D;；</li><li>无锁；</li><li>多生产者或单生产者入队，&#x3D;&#x3D;其中生产者是指数据对象入队机制&#x3D;&#x3D;。</li></ul><p>&#x3D;&#x3D;优点&#x3D;&#x3D;</p><ol><li>数据交换速度相对较快。</li><li>比全无锁队列简单；</li><li>适用于巨型数据的入队和出队操作；</li></ol><p>&#x3D;&#x3D;缺点&#x3D;&#x3D;</p><ol><li>空间大小固定</li><li>Ring很多时，内存消耗很大，一个空的Ring至少包含N个指针。</li></ol><p>&#x3D;&#x3D;特性&#x3D;&#x3D;</p><ol><li>一个Ring用全局唯一的名字标识。</li></ol><hr><h4 id="2-2-1单消费者入队"><a href="#2-2-1单消费者入队" class="headerlink" title="2.2.1单消费者入队"></a>2.2.1单消费者入队</h4><ol><li>对象入队前<br>Ring结构体变量指针<code>ring-&gt;prod_head</code>,<code>ring-&gt;cons_tail</code>被复制到本地变量中，<code>prod_next</code>指向下一个元素。</li><li>入队<br>修改<code>ring-&gt;prod_head</code>的指针位置，和<code>prod_next</code>相同。指向新增对象的指针被复制。</li><li>入队后指针位置调整。<br>当对象入队后，<code>ring-&gt;prod_tail</code>指针位置修改到<code>ring-&gt;prod_head</code>。</li></ol><hr><h4 id="2-2-2单消费者出队"><a href="#2-2-2单消费者出队" class="headerlink" title="2.2.2单消费者出队"></a>2.2.2单消费者出队</h4><p>单消费者从Ring出队，限制条件只有消费者的head和tai可以修改。</p><ol><li>对象出队前<br>将<code>ring-&gt;cons_head</code>,<code>ring-&gt;prod_tail</code>复制到本地变量中，<code>cons_next</code>指向下一个元素。</li><li>对象出队中<br>将<code>ring-&gt;cons_head</code>指向<code>cons_next</code>的位置，指向出队对象的指针由用户给出。</li><li>对象出队后<br>将<code>ring-&gt;cons_tail</code>指向<code>cons_next</code>的位置。</li></ol><hr><h3 id="2-3Mempool库"><a href="#2-3Mempool库" class="headerlink" title="2.3Mempool库"></a>2.3<span class="exturl" data-url="aHR0cDovL3d3dy5kcGRrLm9yZy9kb2MvZ3VpZGVzL3Byb2dfZ3VpZGUvTWVtcG9vbF9saWIuaHRtbA==">Mempool库</span></h3><p>DPDK的Mempool(内存池)库主要供mbuf(内存缓冲区)和EAL使用。<br>DPDK中，Mempool使用字符串名字进行标识，通过Ring方式存储对象。<br>在多核情况中，多个核访问同一个内存池的频率很高，为了避免过多的访问请求，内存池分配器通过几乎无锁的缓存技术保证每一个核的缓存以及大块数据的访问。</p><hr><h3 id="2-4mbuf库"><a href="#2-4mbuf库" class="headerlink" title="2.4mbuf库"></a>2.4mbuf库</h3><p>mbuf库用来分配和释放缓冲区，该缓冲区存储在内存池中，使用Mempool库，Mempool中的数据结构<code>rte_mbuf</code>是承载网络数据分组的缓冲区或一般的控制区。</p><hr><h4 id="2-4-1数据存储"><a href="#2-4-1数据存储" class="headerlink" title="2.4.1数据存储"></a>2.4.1数据存储</h4><p>存储数据分组数据有两种方法：</p><ol><li>使用一个大小固定的单一内存缓冲区存储数据分组；</li><li>使用分散的内存缓冲区来存储数据。</li></ol><p>&#x3D;&#x3D;第一种方法的优点&#x3D;&#x3D;<br>对整个内存的操作只有一对分配和释放操作。<br>&#x3D;&#x3D;第二种方法的优点&#x3D;&#x3D;<br>灵活性好，可以将元数据与数据分组数据完全分离</p><p>&#x3D;&#x3D;DPDP采用第一中方法存储数据&#x3D;&#x3D;</p><hr><h4 id="2-4-2缓冲区分配与释放"><a href="#2-4-2缓冲区分配与释放" class="headerlink" title="2.4.2缓冲区分配与释放"></a>2.4.2缓冲区分配与释放</h4><p>mbuf库使用Mempool库来分配缓冲区<br>内存释放<code>rte_ctrlmbuf_free(m)</code>,<code>rte_pktmbuf_free(m)</code>;</p><h4 id="2-4-3相关操作"><a href="#2-4-3相关操作" class="headerlink" title="2.4.3相关操作"></a>2.4.3相关操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rte_pktmbuf_data_len(m) <span class="comment">//获取数据长度定义宏操作</span></span><br><span class="line">rte_ctrlmbuf_data(m)    <span class="comment">//获取数据起始地址指针宏操作</span></span><br><span class="line">rte_pktmbuf_prepend(<span class="keyword">struct</span> rte_mbuf *m,<span class="type">uint16_t</span> len)           <span class="comment">//在数据前新增数据</span></span><br><span class="line">rte_pktmbuf_append(<span class="keyword">struct</span> rte_mbuf *m,<span class="type">uint16_t</span> len)                    <span class="comment">//在数据后添加数据</span></span><br><span class="line">rte_pktmbuf_adj(<span class="keyword">struct</span> rte_mbuf *m,<span class="type">uint16_t</span> len)                    <span class="comment">//在缓冲区起始位置移除数据</span></span><br><span class="line">rte_pktmbuf_trim(<span class="keyword">struct</span> rte_mbuf *m,<span class="type">uint16_t</span> len)                    <span class="comment">//在缓冲区尾部位置移除数据</span></span><br></pre></td></tr></table></figure><p>所有的网络应用都可以用<code>mbufs</code>传输网络数据分组</p><hr><h3 id="2-5PMD驱动"><a href="#2-5PMD驱动" class="headerlink" title="2.5PMD驱动"></a>2.5PMD驱动</h3><p>DPDK提供1Gbit&#x2F;s,10Gbit&#x2F;s,40Gbit&#x2F;s以及虚拟网卡的<code>PMD(Poll Mode Driver轮询模式驱动)</code>。<br>一个PMD可以无中断的直接访问RX和TX，进而快速的接收、处理和转发数据分组。<br>DPDK环境下的数据分组处理有两种模式：<code>run-to-completion</code>和<code>pipe-line</code></p><ol><li><strong>&#x3D;&#x3D;run-to-completion模式&#x3D;&#x3D;</strong><br>指定端口的RXring被选中接收数据分组，然后数据分组在相同的核上进行处理并放置在该端口的TX ring上通过API发送。<br>&#x3D;&#x3D;这种模式属于同步模式&#x3D;&#x3D;</li><li><strong>&#x3D;&#x3D;pipe-line模式&#x3D;&#x3D;</strong><br>一个核选中一个或者多个端口RX ring，数据分组接收后，通过一个ring传递给另一个核进行处理，处理完成后将数据分组放在该端口的TX ring上，通过API进行转发。<br>&#x3D;&#x3D;这种模式属于异步模式&#x3D;&#x3D;，一些核用来接收数据分组，一些核处理先前接收的分组。</li></ol><p><strong>&#x3D;&#x3D;配置&#x3D;&#x3D;</strong><br>PMD为发送和接收队列提供一些配置：</p><ol><li>发送ring包含的描述符数量</li><li>socket标识符（描述对于DMA内存区的标识），DMA内存区用于在NUMA结构中分配给发送ring</li><li>发送队列相关阈值</li></ol><blockquote><p>当配置DCB操作时，在端口初始化时，发送队列和接收队列的个数必须设置为128.</p></blockquote><h3 id="2-6IVSHMEM库"><a href="#2-6IVSHMEM库" class="headerlink" title="2.6IVSHMEM库"></a>2.6IVSHMEM库</h3><p>DPDK IVSHMEM库主要作用是在虚拟机内快速共享零复制数据。</p><p>此库可以将几个巨页映射为一个单一的IVSHMEM设备，同时，将一个元数据文件映射出一个IVSHMEM段用来区分DPDK和非DPDK的IVSHMEM设备。</p><p><em>元数据文件？</em></p><p>&#x3D;&#x3D;相关API&#x3D;&#x3D;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rte_ivhshmem_metadata_create()   <span class="comment">//创建元数据文件</span></span><br><span class="line">rte_ivhshmem_metadata_add_memzone() <span class="comment">//添加一个内存区（rte_memzone）到元数据文件</span></span><br><span class="line">rte_ivhshmem_metadata_add_ring() <span class="comment">//添加ring到元数据文件</span></span><br><span class="line">rte_ivhshmem_metadata_add_mempool(rte_Mempool) <span class="comment">//添加内存池到元数据文件</span></span><br><span class="line">rte_ivhshmem_matadata_cmdline_generate() <span class="comment">//为QEMU生成命令行</span></span><br></pre></td></tr></table></figure><p><em>数据结构必须完整属于DPDK巨页内存才能正确工作，一个VM可以支持多个元数据文件</em></p><hr><h3 id="2-7Timer库"><a href="#2-7Timer库" class="headerlink" title="2.7Timer库"></a>2.7Timer库</h3><p>Timer（定时器）库为DPDK提供了计时器服务，用于保证执行单元能够执行异步回调功能。特征如下：</p><ol><li>定时器的使用频率可以是周期性或者一次性的</li><li>定时器可以从一个核装载，在另一个核执行</li><li>定时器可以提供较高的精准度</li><li>如果没有应用程序需要，定时器为关闭状态</li></ol><p>定时器的结构主要包含一个状态机，状态机的状态如下：</p><ol><li>STOPPED:没有所属者，不在列表中。</li><li>CONFIG:属于一个核，不能被另外的核修改</li><li>PENDING:属于一个核，存在一个列表中</li><li>RUNNING:属于一个核，不能被另外的核修改，存在与一个列表中。</li></ol><p><em>每一个核的定时器列表维护着那些没有过期的且还在跳表中的定时器。在64bit平台上，定时器的值不需要加锁来检验</em></p><hr><h3 id="2-8-LPM库"><a href="#2-8-LPM库" class="headerlink" title="2.8 LPM库"></a>2.8 LPM库</h3><p>LPM(Longest Prefix Match 最长前缀匹配)，其典型应用场景在IP转发过程中。</p><hr><h3 id="2-9Hash库"><a href="#2-9Hash库" class="headerlink" title="2.9Hash库"></a>2.9Hash库</h3><p>Hash(散列)库，可以通过该库创建散列表，用于快速路由，散列表是一个用于查找数据的优化数据结构，每一个条目由唯一关键字进行标识.<br>DPDK Hash要求在散列创建时，所有关键字具有想通过字节数，。</p><p>主要操作如下：</p><ol><li>增加记录</li><li>删除记录</li><li>查找记录</li></ol><hr><h3 id="2-10多进程支持"><a href="#2-10多进程支持" class="headerlink" title="2.10多进程支持"></a>2.10<span class="exturl" data-url="aHR0cDovL3d3dy5kcGRrLm9yZy9kb2MvZ3VpZGVzL3NhbXBsZV9hcHBfdWcvbXVsdGlfcHJvY2Vzcy5odG1s">多进程支持</span></h3><p>DPDK多线程机制允许一组DPDK进程一起执行数据分组处理或者其他任务<br>EAL允许生成两个DPDK进程，每个进程具有不同的巨页内存权限。</p><ul><li>主进程：可以初始化共享内存，拥有所有共享内存的管理权限。</li><li>辅进程：不能初始化共享内存，但是可以连接预初始化的共享内存并且在该内存中创建对象。<br>命令行参数：</li></ul><ul><li>proc-type：进程类型，primary或secondary</li><li>file-prefix：进程不同步非共同内存区域</li></ul><p>多进程的局限性：</p><ol><li>多进程的特点是要求具有&#x3D;&#x3D;完全相同&#x3D;&#x3D;的巨页内存映射</li><li>所有DPDK进程在使用共享内存时必须遵守严格的核分配</li><li>不能使用辅进程发送中断信息</li><li>DPDK不支持基于不同编译环境的多进程指针</li></ol><hr><h2 id="3DPDK安装与部署"><a href="#3DPDK安装与部署" class="headerlink" title="3DPDK安装与部署"></a>3DPDK安装与部署</h2><hr><h3 id="3-1运行DPDK应用要求"><a href="#3-1运行DPDK应用要求" class="headerlink" title="3.1运行DPDK应用要求"></a>3.1运行DPDK应用要求</h3><ol><li><p>内核版本高于2.6.33</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r //查看内核版本</span><br></pre></td></tr></table></figure></li><li><p>glibc版本高于2.7</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd -version</span><br></pre></td></tr></table></figure></li><li><p>kernel配置<br>大多数linux操作系统中，DPDK提供的内核配置能正常运行。<br>如果是其他操作系统，需打开以下选项：</p></li></ol><ul><li>UIO支持</li><li>HUGETLBFS</li><li>PROC_PAGE_MONITOR</li></ul><ol start="4"><li>巨页的使用</li></ol><ul><li>&#x3D;&#x3D;预留巨页给DPDK使用&#x3D;&#x3D;</li></ul><p>巨页的分配应在开机时或者系统启动后立即进行，防止内存在物理内存中被碎片化。<br>要预留2MB的1024页使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugepages = 1024</span><br></pre></td></tr></table></figure><p>对于其他巨页，如1GB页面，页面尺寸必须特别指定或者将该尺寸设置为系统默认的巨页大小。<br>预留4个1GB页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_hugepagesz=1 Ghugepagesz=1G hugepages=4</span><br></pre></td></tr></table></figure><blockquote><p>一个CPU支持的巨页大小由英特尔架构的CPU标志来决定。</p></blockquote><p>对于2MB的页面，也可以在系统启动后设置。对于单节点系统，使用命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1024 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</span><br></pre></td></tr></table></figure><p>在NUMA架构的系统下，需要对每一个NUMA节点分配巨页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 1024 &gt; /sys/devices/system/node/node0/hugepages/hugepages-2048kB/nr_hugepages</span><br><span class="line">echo 1024 &gt; /sys/devices/system/node/node1/hugepages/hugepages-2048kB/nr_hugepages</span><br></pre></td></tr></table></figure><blockquote><p>对于1GB页面，不能在系统启动后在预留巨页大小</p></blockquote><ul><li>&#x3D;&#x3D;DPDK中使用巨页&#x3D;&#x3D;</li></ul><p>一旦巨页被预留成功就可以在DPDK中使用巨页内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/huge</span><br><span class="line">mount -t hugetlbfs nodev /mnt/huge</span><br></pre></td></tr></table></figure><p>如果需要永久使用一个挂载点，可以将这个挂载点的信息写入&#x2F;etc&#x2F;fstab文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodev /mnt/huge hugetlbfs default 0 0</span><br></pre></td></tr></table></figure><p>对于1GB页面，页面大小必须指定为一个安装选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodev /mnt/huge_1GB hugetlbfs pagesize=1GB 0 0</span><br></pre></td></tr></table></figure><hr><h3 id="3-2使用源代码编译DPDK"><a href="#3-2使用源代码编译DPDK" class="headerlink" title="3.2使用源代码编译DPDK"></a>3.2使用源代码编译DPDK</h3><h4 id="3-2-1安装DPDK安装包"><a href="#3-2-1安装DPDK安装包" class="headerlink" title="3.2.1安装DPDK安装包"></a>3.2.1安装DPDK安装包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unzip DPDK-&lt;version&gt;.zip</span><br><span class="line">cd DPDK-&lt;version&gt;</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>DPDK由以下目录组成：</p><ul><li>lib目录：DPDK库的源代码</li><li>drivers目录：DPDK PMD的源代码</li><li>app目录：DPDK应用程序的源代码</li><li>examples目录：DPDP应用程序示例的源代码</li><li>config，tools，scripts，mkmul：框架相关的生成文件，脚本核配置文件。</li></ul><hr><h4 id="3-2-2安装DPDK目标环境"><a href="#3-2-2安装DPDK目标环境" class="headerlink" title="3.2.2安装DPDK目标环境"></a>3.2.2安装DPDK目标环境</h4><p>使用英特尔C++编译器时（ICC）时，编译编译命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /opt/intel/bin/iccvars.sh intel64</span><br><span class="line">source /opt/intel/bin/iccvars.sh ia32</span><br></pre></td></tr></table></figure><p>要安装核编译目标文件，使用<code>make install T=&lt;target&gt;</code>, T&#x3D; &lt;DPDK根目录&gt;，如使用ICC编译64位DPDK目标文件时，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install T=x86_64-native-linuxapp-icc</span><br></pre></td></tr></table></figure><p>使用gcc编译64位版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install T=x86_64-native-linuxapp-gcc</span><br></pre></td></tr></table></figure><hr><h4 id="3-2-3查看已经安装的DPDK环境"><a href="#3-2-3查看已经安装的DPDK环境" class="headerlink" title="3.2.3查看已经安装的DPDK环境"></a>3.2.3查看已经安装的DPDK环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls x86_64-native-linuxapp-gcc</span><br></pre></td></tr></table></figure><hr><h4 id="3-2-4启用DPDK用户空间I-x2F-O模块"><a href="#3-2-4启用DPDK用户空间I-x2F-O模块" class="headerlink" title="3.2.4启用DPDK用户空间I&#x2F;O模块"></a>3.2.4启用DPDK用户空间I&#x2F;O模块</h4><p>大部分情况下，linux标准内核模块<code>uio_pci_generic</code>可以提供UIO能力，可用如下命令加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe uio_pci_generic</span><br></pre></td></tr></table></figure><p>作为该模块的替代模块komd子目录<code>igb_uio</code>模块，可用如下命令加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe uio</span><br><span class="line">sudo insmod /kmod/igb_uio.ko</span><br></pre></td></tr></table></figure><blockquote><p>对于一些缺少对传统中断支持的设备，如虚拟功能(VF)器件，可能需要用<code>igb_uio</code>模块替代<code>uio_pci_generic</code>模块</p></blockquote><h4 id="3-2-5加载VFIO模块"><a href="#3-2-5加载VFIO模块" class="headerlink" title="3.2.5加载VFIO模块"></a>3.2.5加载VFIO模块</h4><p>对于支持VFIO功能的平台，UIO是可选的，利用VFIO运行DPDK应用程序时，必须加载<code>vfio-PCI</code>模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe vfio-pci</span><br></pre></td></tr></table></figure><blockquote><p>内核必须支持VFIO使用，linux3.6.0内核及以上版本已经包含了VFIO模块，通常默认时加载的。<br>使用VFIO时，服务器系统内核核BIOS必须支持I&#x2F;O虚拟化。 </p></blockquote><h4 id="3-2-6在内核模块绑定-x2F-解除网络端口"><a href="#3-2-6在内核模块绑定-x2F-解除网络端口" class="headerlink" title="3.2.6在内核模块绑定&#x2F;解除网络端口"></a>3.2.6在内核模块绑定&#x2F;解除网络端口</h4><p>使用tools目录下的<code>dpdk_nic_bind.py</code>查看当前网口的驱动状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tools/dpdk_nic_bind.py --status</span><br></pre></td></tr></table></figure><blockquote><p>绑定核接触绑定的操作需要root权限，但是查看网卡信息任何用户都可以</p></blockquote><p>绑定设备的eth1，04:00.1到<code>uio_pci_generic</code>驱动，使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./tools/dpdk_nic_bind.py --bind=ui_pci_generic 04:00.1</span><br><span class="line">或者</span><br><span class="line">./tools/dpdk_nic_bind.py --bind=ui_pci_generic eth1</span><br></pre></td></tr></table></figure><p>恢复设备08:00.1到原来的绑定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./root/dpdk_nic_bind.py --bind=ixgbe 08:00.1</span><br></pre></td></tr></table></figure><hr><h3 id="3-3编译和运行实例程序"><a href="#3-3编译和运行实例程序" class="headerlink" title="3.3编译和运行实例程序"></a>3.3编译和运行实例程序</h3><p> 当应用程序在linux上DPDK环境编译时，必须输出下列变量：<br> &#x3D;&#x3D;RTE_SDK&#x3D;&#x3D;:指向DPDK的安装目录<br> &#x3D;&#x3D;RTE_TARGET&#x3D;&#x3D;:指向DPDK目标环境的目录<br>ex:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export RTE_SDK=$HOME/DPDK</span><br><span class="line">export RTE_TARGET=$HOME</span><br></pre></td></tr></table></figure><hr><h4 id="3-3-1编译示例应用程序"><a href="#3-3-1编译示例应用程序" class="headerlink" title="3.3.1编译示例应用程序"></a>3.3.1编译示例应用程序</h4><p>在应用程序的文件夹中执行<code>make</code>命令即可</p><hr><h4 id="3-3-2运行实例应用程序"><a href="#3-3-2运行实例应用程序" class="headerlink" title="3.3.2运行实例应用程序"></a>3.3.2运行实例应用程序</h4><p>&#x3D;&#x3D;UIO驱动和巨页必须在应用程序运行之前进行设置。应用程序使用的端口必须在应用程序运行之前绑定到相应的内核模块&#x3D;&#x3D;</p><p>每个DPDK应用程序都要设定对应的DPDK目标环境的抽象层（EAL）库，EAL库提供给一些选项给DPDK应用程序使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./rte_app -c COREMASK [-n NUM] [-d &lt;domain:bus:devid.func&gt;]\</span><br><span class="line">[--Socket-mem=MB,...] [-m MB] [-r NUM] [-v] [--file-prefix]\</span><br><span class="line">[--proc-type &lt;primary|secondary|auto&gt;] [-- xen-dom0]</span><br></pre></td></tr></table></figure><p>EAL选项说明：</p><ol><li>-c COREMASK：16位进制掩码，用于指定使用的CPU核的编号</li><li>-n NUM：每个处理器插槽内存通道数</li><li>–use-device：指定使用的以太网设备</li><li>–socket-mem：从巨页中给特定的socket分配的内存</li><li>-m MB:巨页分配的大小，建议用–socket-mem代替</li><li>-v 启动时显示的版本信息</li></ol><p>&#x3D;&#x3D;-c和-n选项必选&#x3D;&#x3D;</p><p>在DPDK应用程序的目录中，假设硬件平台的每个Socket上由4个内存通道，而且0-3号核被应用程序使用，则运行命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./helloworld -c f -n 4</span><br></pre></td></tr></table></figure><hr><h4 id="3-3-3应用程序的逻辑核的使用"><a href="#3-3-3应用程序的逻辑核的使用" class="headerlink" title="3.3.3应用程序的逻辑核的使用"></a>3.3.3应用程序的逻辑核的使用</h4><p>coremask参数一般是DPDK应用程序的必要参数，建议在每个平台上使用coremask时，考虑CPU核的布局分布</p><hr><h3 id="3-4使用脚本配置"><a href="#3-4使用脚本配置" class="headerlink" title="3.4使用脚本配置"></a>3.4使用脚本配置</h3><hr><ol><li>构建DPDK库</li><li>设置环境</li><li>运行应用程序（可选）</li><li>检查系统</li><li>系统清理</li></ol><blockquote><p>setup.sh脚本需要在root权限下运行</p></blockquote><hr><h2 id="4DPDK自带应用软件调试"><a href="#4DPDK自带应用软件调试" class="headerlink" title="4DPDK自带应用软件调试"></a>4DPDK自带应用软件调试</h2><hr><h3 id="4-1命令行应用例"><a href="#4-1命令行应用例" class="headerlink" title="4.1命令行应用例"></a>4.1命令行应用例</h3><p>命令行应用例可以用于在Linux环境中调试各种DPDK应用</p><ul><li>add obj_name IP:用于增加一个带有IP&#x2F;IPv6地址的新对象</li><li>del obj_name:删除特有对象</li><li>show obj_name:显示IP地址所关联的特定对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/cmdline -c f -n 4   //运行实例</span><br></pre></td></tr></table></figure><hr><h3 id="4-2HelloWorld应用例"><a href="#4-2HelloWorld应用例" class="headerlink" title="4.2HelloWorld应用例"></a>4.2HelloWorld应用例</h3><p>在每个CPU的逻辑核上运行“helloworld”语句打印</p><ol><li><p>进入该应用例目录，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export RTE_SDK=/path/to/rte_sdk</span><br><span class="line">cd $(RTE_SDK)/example/helloworld</span><br></pre></td></tr></table></figure></li><li><p>设定RTE目标，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export RTE_TARGET=x86_64-native-linuxapp-gcc</span><br></pre></td></tr></table></figure></li><li><p>编译该应用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/helloworld -c f -n 4</span><br></pre></td></tr></table></figure><h4 id="4-2-1代码说明"><a href="#4-2-1代码说明" class="headerlink" title="4.2.1代码说明"></a>4.2.1代码说明</h4></li><li><p>主线程运行入口是main函数,调用了<code>rte_eal_init</code>入口函数，启动基础运行环境。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = rte_eal_init(argc, argv);<span class="comment">//初始化EAL层，返回值时解析的参数格式。</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">rte_panic(<span class="string">&quot;Cannot init EAL\n&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>RTE_LCORE_FOREACH_SLAVE(lcore_id)</code>，遍历所有的EAL指定可以使用的lcore，然后通过<code>rte_eal_remote_launch</code>在每个lcore上启动被指定的线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RTE_LCORE_FOREACH_SLAVE(lcore_id) &#123;</span><br><span class="line">rte_eal_remote_launch(lcore_hello, <span class="literal">NULL</span>, lcore_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行lcore_hello从线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">lcore_hello</span><span class="params">(__attribute__((unused)) <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> lcore_id;</span><br><span class="line">lcore_id = rte_lcore_id();<span class="comment">//返回线程ID</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello from core %u\n&quot;</span>, lcore_id);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_remote_launch</span><span class="params">(<span class="type">int</span> (*f)(<span class="type">void</span>*),<span class="type">void</span> *arg,unsingned slave_id)</span>;</span><br></pre></td></tr></table></figure><ul><li>第一个参数是从线程，被征兆的线程</li><li>第二个参数是传给从线程的参数</li><li>第三个参数是指定的逻辑核，从线程会执行在这个core上。</li></ul><hr><h3 id="4-3L2转发应用例"><a href="#4-3L2转发应用例" class="headerlink" title="4.3L2转发应用例"></a>4.3L2转发应用例</h3><p>L2转发应用例是一个利用DPDK及其SR-IOV进行报文转发处理的简单实例</p><hr><h4 id="4-3-1概述"><a href="#4-3-1概述" class="headerlink" title="4.3.1概述"></a>4.3.1概述</h4><p>L2转发应用实例可以在物理或者虚拟化环境中对每一个从RX_PORT端口收到的报文执行二层转发，目的端口时所允许的端口掩码中的邻接端口，也就是所允许的前四个端口端口1和2转发，端口3和4转发。</p><ul><li>源MAC地址被TX_PORT端口的MAC地址取代</li><li>目的MAC地址被TX_PORT_ID取代</li></ul><blockquote><p>该应用可用于基准性能测试</p></blockquote><p>该应用例无需穿越物理机上的网络设备，可以直接在具有虚拟机的虚拟化环境中使用VF功能。可使用如下命令开启VF功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe ixgbe max_vfs=2,2</span><br></pre></td></tr></table></figure><p>编译该应用同helloworld类似</p><ol><li>该应用实例首先是初始化EAL层使用<code>rte_eal_init</code>初始化，解析EAL参数，然后通过<code>l2fwd_parse_args()</code>函数解析该应用例的特殊参数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ret = rte_eal_init(argc, argv);<span class="comment">//初始化EAL层</span></span><br><span class="line">······</span><br><span class="line">signal(SIGINT, signal_handler);  <span class="comment">//SIGINT,中断信号</span></span><br><span class="line">signal(SIGTERM, signal_handler);  <span class="comment">//SIGTERM，发送给本程序的中止请求信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* parse application arguments (after the EAL ones) */</span></span><br><span class="line">ret = l2fwd_parse_args(argc, argv);  <span class="comment">//解析该应用例的特殊参数</span></span><br></pre></td></tr></table></figure></li><li>参数解析完毕，便使用<code>rte_pktmbuf_pool_create()</code>函数创建mbuf pool，mbuf pool中包含了一系列的mbuf对象，用来驱动和应用程序来存放报文。在<code>rte_pktmbuf_pool_creat()</code>函数中，有两个回调函数指针，一个是位于<code>rte_pktmbuf_pool_init()</code>函数中的mp指针，用于初始化驱动程序的私有数据的内存。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l2fwd_pktmbuf_pool = rte_pktmbuf_pool_create(<span class="string">&quot;mbuf_pool&quot;</span>, nb_mbufs,</span><br><span class="line">MEMPOOL_CACHE_SIZE, <span class="number">0</span>, RTE_MBUF_DEFAULT_BUF_SIZE,</span><br><span class="line">rte_socket_id());</span><br></pre></td></tr></table></figure></li><li>接下来是驱动程序初始化，通过<code>ret_eth_dev_configure()</code>函数配置每个端口上的队列个数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = rte_eth_dev_configure(portid, <span class="number">1</span>, <span class="number">1</span>, &amp;local_port_conf);</span><br></pre></td></tr></table></figure></li><li>然后是RX接收队列初始化，通过<code>rte_eth_rx_queue_setup</code>设置接收队列。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ret = rte_eth_rx_queue_setup(portid, <span class="number">0</span>, nb_rxd,</span><br><span class="line">     rte_eth_dev_socket_id(portid),</span><br><span class="line">     &amp;rxq_conf,</span><br><span class="line">     l2fwd_pktmbuf_pool);</span><br></pre></td></tr></table></figure></li><li>初始化TX发送队列，发送队列中，每个逻辑核可以在任何端口中发送。通过<code>rte_eth_tx_queue_setup</code>初始化。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = rte_eth_tx_queue_setup(portid, <span class="number">0</span>, nb_txd,</span><br><span class="line">rte_eth_dev_socket_id(portid),</span><br><span class="line">&amp;txq_conf);</span><br></pre></td></tr></table></figure></li><li>报文的收发与报文处理。通过<code>l2fwd_main_loop</code>函数读取从RX队列接收到的报文。报文被读取到<code>MAX_PKT_BURST</code>大小的内存块中，然后通过<code>rte_eth_rx_burst</code>函数将mbuf指针写入一个本地表，并返回该表中的mbuf个数。然后每个mbuf被<code>l2fwd_simple_forward</code>函数处理。处理过程：从RX端口处理完成后，转送到TX端口发送，替换源MAC和目的MAC。</li><li>报文使用<code>rte_eth_tx_buffer</code>函数发送。</li></ol><hr><h3 id="4-4L3转发应用例"><a href="#4-4L3转发应用例" class="headerlink" title="4.4L3转发应用例"></a>4.4L3转发应用例</h3><hr><h4 id="4-4-1概述"><a href="#4-4-1概述" class="headerlink" title="4.4.1概述"></a>4.4.1概述</h4><p>该应用例展示了DPDK如何利用散列和LPM库进行查表转发处理。L3的转发初始化和确定实时转发路径的过程和L2转发应用例类似。2者的主要区别是L3是基于从输入的报文信息进行转发决策的。</p><blockquote><p>散列查找的键值为报文中的无五元组–源IP,目的IP，源端口,目的端口,协议类型。</p></blockquote><p>每个输入报文的输出接口ID从流表中读取。</p><blockquote><p>注：散列查表可同时转发支持IPv4和IPv6，而LPM查表仅支持IPv4</p></blockquote><p>编译同之前</p><hr><h4 id="4-4-2运行转发应用例"><a href="#4-4-2运行转发应用例" class="headerlink" title="4.4.2运行转发应用例"></a>4.4.2运行转发应用例</h4><p>端口队列逻辑核之间的映射关系</p><table><thead><tr><th align="center">端口</th><th align="center">队列</th><th align="center">逻辑核</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">从端口0映射队列0到逻辑核0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">从端口0映射队列1到逻辑核2</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">从端口1映射队列0到逻辑核1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">3</td><td align="center">从端口1映射队列1到逻辑核3</td></tr></tbody></table><hr><h4 id="4-4-3代码说明"><a href="#4-4-3代码说明" class="headerlink" title="4.4.3代码说明"></a>4.4.3代码说明</h4><p>L3转发大致与L2相似，仅说明L3独有的特性，</p><ol><li>散列初始化<br>散列对象被创建并存放在预先定义的一个全局矩阵中，然后将用户期望的五元组生成为键值，以保持与实际流量一致。通过<code>setup_l3fwd_lookup_tables()</code>函数设置查找的方式，散列的初始化通过<code>setup_hash</code>函数实现，既可以添加ipv4也可以添加ipv6。</li><li>LPM初始化<br>LPM初始化通过<code>setup_lpm</code>函数实现，但是只能添加ipv4。<blockquote><p>LPM和散列表只能选择一种方式，默认情况下选择LPM。</p></blockquote></li><li>基于散列查表的报文转发<br>对于每个输入的报文，通过<code>l3fwd_em_simple_forward()</code>转发，<code>l3fwd_em_simple_forward()</code>支持任何突发方式接收报文，基于散列查表方式分报文转发决策由<code>em_get_ipv4_dst_port</code>和<code>em_get_ipv6_dst_port</code>完成。</li><li>基于LPM的报文转发<br>报文转发操作由<code>l3fwd_lpm_simple_forward()</code>完成，基于LPM查表的报文转发决策由<code>lpm_get_ipv4_dst_port()</code>完成。</li></ol><hr><h3 id="4-5QoS调度应用例"><a href="#4-5QoS调度应用例" class="headerlink" title="4.5QoS调度应用例"></a>4.5QoS调度应用例</h3><p>接收线程从接收端口读取报文，并基于内层和外层VLAN标记，或者IP目的地址的低2byte进行报文分类，最后将这些报文放入环形队列。工作线程将报文从环形队列中取出。如果一个用户使用一个独立的发送核，则报文后续会被送至发送环形队列，发送线程从发送环形队列中读取报文并写入网卡的发送端口。</p><h4 id="4-5-1代码说明"><a href="#4-5-1代码说明" class="headerlink" title="4.5.1代码说明"></a>4.5.1代码说明</h4><p>qos_sched在该应用例中</p><ol><li>一个子接口表示一组预先定义的用户</li><li>一个管道表示一个具体用户</li><li>一个流量类表示具有不同丢包率，时延等需求的流量类型，例如语音，视频和数据传输。</li><li>一个队列承载了属于某类相同用户的一个或多个连接。</li></ol><p>代码流程：</p><ol><li>首先通过<code>app_parse_args</code>函数解析参数。</li><li>然后通过<code>app_init</code>对应用例初始化，初始化每一条流量。通过<code>rte_pktmbuf_pool_create</code>函数创建mbuf pools。通过<code>app_init_sched_port</code>创建调度的端口。</li><li>在<code>app_main_loop</code>函数中循环执行，根据不同的模式执行不同的线程。分别由接收，发送，工作，混合线程。</li></ol><h3 id="4-6定时器应用例"><a href="#4-6定时器应用例" class="headerlink" title="4.6定时器应用例"></a>4.6定时器应用例</h3><p>定时器应用例可以通过定时器设置，有节律的在不同逻辑核上打印出特定信息</p><h4 id="4-6-1代码说明"><a href="#4-6-1代码说明" class="headerlink" title="4.6.1代码说明"></a>4.6.1代码说明</h4><ol><li>首先初始化EAL,通过<code>rte_timer_subsystem_init</code>函数初始化定时器子系统。</li><li>定时器创建后，main注循环体在每个主从逻辑核上使用<code>rte_eal_remote_launch</code>,执行<code>lcore_mainloop</code>循环函数，主循环体内容简单，DPDK推荐使用TCS寄存器，检查是否需要调用<code>rte_timer_manager</code>，此时的定时器的分辨率为10ms。</li><li>在做任何定时器的操作前，首先都需要对定时器初始化，使用<code>rte_timer_init()</code>函数初始化。</li><li>之后对定时器进行配置，使用<code>rte_timer_reset()</code>进行配置</li></ol><ul><li>第一个定时器被放置在主逻辑核，并设置超时门限为1s（hz）,由于提供了，PERIODICAL标志，定时可以由定时器子系统自动重新加载，回调函数为<code>timer0_cb</code></li><li>第二个定时器每隔333ms就在下一个可用的逻辑核中触发，SINGLE标志表示定时器仅当必须被重新手动加载时才会超时。</li></ul><ol start="5"><li>当全局计数器达到20s后，第一个定时器的回调函数显示一段信息，使用<code>rte_timer_stop</code>停止</li><li>第二个定时器的回调函数显示一段信息，并在下一个逻辑核上调用<code>rte_timer_reset</code>重新加载定时器</li></ol><h3 id="4-7基本转发应用例-skeleton"><a href="#4-7基本转发应用例-skeleton" class="headerlink" title="4.7基本转发应用例(skeleton)"></a>4.7基本转发应用例(skeleton)</h3><p>可以用于平台的单核报文出入性能测试。</p><h4 id="4-7-1代码说明"><a href="#4-7-1代码说明" class="headerlink" title="4.7.1代码说明"></a>4.7.1代码说明</h4><ol><li>收先是EAL层的初始化</li><li>然后通过<code>rte_eth_dev_count_avail</code>函数检查可用的端口是否是偶数</li><li>通过<code>rte_pktmbuf_pool_create</code>函数分配一个内存池，保存应用程序使用的<code>mbufs</code>.入口参数是指定<code>rte_socket_id()</code>.</li><li>使用用户自己的函数<code>port_init</code>初始化端口</li><li>通过<code>lcore_main</code>执行应用程序。</li><li>在<code>port_init</code>中，使用<code>rte_eth_dev_configure</code>函数对网络设备进行配置。主要对指定的端口设置接收，发送方向的队列数目，一句配置信息来指定端口功能。通过<code>rte_eth_tx_queue_setup</code>和<code>rte_eth_rx_queue_setup</code>分别创建一个发送和接收队列。通过<code>rte_eth_dev_start</code>启动以太网端口。<br>数据包都是通过<code>rte_eth_rx_burst</code>和<code>rte_eth_tx_burst</code>以突发方式进行收发。最后通过<code>rte_pktmbuf_free</code>释放掉没有发送的数据包。</li></ol><hr><h2 id="5DPDK应用开发"><a href="#5DPDK应用开发" class="headerlink" title="5DPDK应用开发"></a>5DPDK应用开发</h2><hr><h3 id="5-1网卡设备"><a href="#5-1网卡设备" class="headerlink" title="5.1网卡设备"></a>5.1网卡设备</h3><h4 id="5-1-1设备驱动"><a href="#5-1-1设备驱动" class="headerlink" title="5.1.1设备驱动"></a>5.1.1设备驱动</h4><p>DPDK采用层次化设计网络设备驱动，由下到上依次是物理层，驱动功能层，设备接口层，应用接口层。</p><blockquote><p>与linuxu不同的是，DPDK采用UIO机制使得网络设备驱动程序运行在用户态。</p></blockquote><hr><h4 id="5-1-2应用接口"><a href="#5-1-2应用接口" class="headerlink" title="5.1.2应用接口"></a>5.1.2应用接口</h4><p>主要为应用程序提供数据分组的收发函数<br><code>rte_eth_rx_burst</code>，<code>rte_eth_tx_burst</code>最终通过Ethernet设备的<code>rx_pkt_burst</code>,<code>tx_pkt_burst</code>,完成报文的收发。<br>报文以<code>rte_mbuf</code>的形式在应用程序中处理。结构如下图</p><table><thead><tr><th align="center">mbuf header</th><th align="center">headroom(保留)</th><th align="center">pkt data</th></tr></thead></table><p>headroom主要预留给报文封装技术，如VLAN，GRE，封装时，在报文数据前填充封装报文头即可，此外同样可用作报文私有区，保存业务的私有数据，从而保持mbuf header的独立。</p><p>rte_mbuf主要分为两类，direct mbuf和indirect mbuf，其中indirect mbuf一般没有pkt data段，主要用作多播处理。</p><hr><h4 id="5-1-3设备接口"><a href="#5-1-3设备接口" class="headerlink" title="5.1.3设备接口"></a>5.1.3设备接口</h4><p>设备接口层，所有的网口抽象封装成Ethernet设备，从而使应用程序能够以相同的方式使用接口。</p><ol><li>rx_pkt_burst,tx_pkt_burst<br>网口的收发处理函数。初始化时，被赋值为与之对应的网卡驱动收发函数。</li><li>data<br>设备相关信息，如网卡名称，队列，链路状态等。</li><li>dev_ops<br>设备的操作函数组，包括MAC地址，链路状态的查询与设定等操作。<br>Ethernet设备的设置，即网口属性的配置，由<code>rte_eth_dev_configure()</code>完成。</li></ol><blockquote><p>队列的注意事项如下：</p><ol><li>队列测个数有限，具体个数根据网卡的类型确定</li><li>同一个队列不支持多线程同时操作</li></ol></blockquote><p>RX队列，通过<code>rte_eth_rx_queue_setup</code>创建<br>TX队列，通过<code>rte_eth_tx_queue_setup</code>创建</p><hr><h3 id="5-2进程"><a href="#5-2进程" class="headerlink" title="5.2进程"></a>5.2进程</h3><h4 id="5-2-1-线程"><a href="#5-2-1-线程" class="headerlink" title="5.2.1 线程"></a>5.2.1 线程</h4><p>默认情况下，DPDK为每个绑定的逻辑核创建一个对应的affinity thread,以降低线程调度切换造成的开销。</p><p>线程创建的初始化流程如下：</p><ol><li>单线程初始化时，运行在master lcore（主核），在初始化函数<code>rte_eal_init()</code>中，通过<code>RTE_LCORE_FOREACH_SLAVE()</code>遍历所有的slave lcore（从核）。</li><li>通过<code>pthread_creat()</code>为从核创建一个线程。，线程的入口函数为<code>eal_thread_loop()</code></li><li>从核执行<code>eal_thread_loop()</code>,获取相应配置及设置相关参数。</li><li>主核通过<code>rte_eal_mp_remote_launch</code>将指定的入口函数通过管道的方式装载到相关的逻辑核中，完成线程初始化。</li></ol><hr><h4 id="5-2-2单进程"><a href="#5-2-2单进程" class="headerlink" title="5.2.2单进程"></a>5.2.2单进程</h4><p>DPDK提供两种单进程方案：</p><ol><li>run-to-completion 报文的收发，处理，接收都在一个逻辑核完成，如l3fwd</li><li>pipeline，报文的额接收，处理，发送在不同的线程完成，线程之间通过ring传递报文核消息。</li></ol><blockquote><p>&#x3D;&#x3D;ring的主要作用就是实现报文的无锁传递。&#x3D;&#x3D;</p></blockquote><p>ring的应用</p><ul><li>属性<br>通过<code>rte_ring_init()</code>创建ring，参数中指定了ring属性：单入，单出，多入，多出</li><li>出入队函数<br>按队列属性，可将出入队函数分为两类：</li></ul><table><thead><tr><th align="center">方式</th><th align="center">主要函数</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">单入单出</td><td align="center">rte_ring_sp_enqueue</td><td align="center">队列属性为单入单出</td></tr><tr><td align="center">多入多出</td><td align="center">rte_ring_sc_dequeue</td><td align="center">队列属性为多入多出</td></tr></tbody></table><p>按照操作方式，可将出队，入队函数分为两类：</p><table><thead><tr><th align="center">方式</th><th align="center">主要函数</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">随机出入</td><td align="center">rte_ring_enqueue_burst()  rte_ring_dequeue_burst()</td><td align="center">返回实际入队、出队报文的个数</td></tr><tr><td align="center">批量出入</td><td align="center">rte_ring_enqueue_bulk() rte_ring_enqueue_bulk()</td><td align="center">一次性完成N个报文的出入队，如失败，则没有报文出入队。</td></tr></tbody></table><h4 id="5-2-3多进程"><a href="#5-2-3多进程" class="headerlink" title="5.2.3多进程"></a>5.2.3多进程</h4><p>在多进程方案中，primary进程用于初始化系统资源，创建巨页共享内容等，secondary进程依赖于primary进程，可通过名称查找找到共享资源。</p><blockquote><p>内存共享的实现：primary进程初始化系统资源时创建了全局配置文件.rte_config,secondary进程查找与之对应的ring和memory的物理地址，从而实现内存共享。</p></blockquote><p>由primary进程共享的资源主要包括如下：</p><ol><li>网口<br>网口共享了Ethermet设备的部分信息<code>struct rte_eth_dev_data</code>,可以实现报文发送，MAC地址的查询，但是无法进行设置和链路状态的查询。</li><li>mbuf_pool<br>实现报恩在进程间零复制，secondary进程通过函数<code>rte_mempool_lookup</code>查找共享的mbuf_pool。</li><li>ring<br>实现进程间无锁传递报文流，secondary进程通过<code>rte_ring_lookup</code>查找共享的ring</li></ol>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-base/">DPDK基础</category>
      
      
      <category domain="http://singlewang.top/tags/DPDK/">DPDK</category>
      
      
      <comments>http://singlewang.top/2022/04/29/dpdk/dpdk-base/dpdk/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
