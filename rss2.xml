<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Single Wang&#39;s Blog</title>
    <link>http://singlewang.top/</link>
    
    <atom:link href="http://singlewang.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>智者不入爱河，愚者重蹈覆辙</description>
    <pubDate>Fri, 20 May 2022 03:40:46 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>我真的有机会被爱吗</title>
      <link>http://singlewang.top/2022/05/20/informal-essay/life/520%E9%9A%8F%E6%83%B3/</link>
      <guid>http://singlewang.top/2022/05/20/informal-essay/life/520%E9%9A%8F%E6%83%B3/</guid>
      <pubDate>Fri, 20 May 2022 03:06:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;红豆生南国，&lt;br&gt;春来发几枝。&lt;br&gt;愿君多采撷，&lt;br&gt;此物最相思。&lt;br&gt;        –《相思》唐·王维&lt;br&gt;讲真，这个标题属实有点矫情了，但是仔细一想，其实也没那么肉麻，更多的是基于我目前现状的一种感叹吧。&lt;br&gt;今天恰好是5月20日，也就是不知道从什么时候演</description>
        
      
      
      
      <content:encoded><![CDATA[<p>红豆生南国，<br>春来发几枝。<br>愿君多采撷，<br>此物最相思。<br>        –《相思》唐·王维<br>讲真，这个标题属实有点矫情了，但是仔细一想，其实也没那么肉麻，更多的是基于我目前现状的一种感叹吧。<br>今天恰好是5月20日，也就是不知道从什么时候演变成一个节日的日期，在这一天，朋友圈，微博无处不在秀着各自的恩爱，在从前我还会有些许的羡慕，羡慕情侣之间的浪漫，也曾幻想着自己也能和自己心爱的姑娘在这一天过着属于自己二人世界，可如今我的羡慕之情却已暗淡，因为不知道什么时候起，爱情对我来说就像是不存在一般，仿佛神话故事中那些未曾见过的神兽般虚无缥缈。我不知道自己是否还需要它，因为就目前我的现状来看自己好像也并不是没它不行，一个人的生活也很潇洒，但是看着路边的情侣卿卿我我，也不免会从心底有一丝孤单。<br>我是一个沉默寡言的人，性格随和却又内向，想起昨天玩游戏的时候，碰见一对情侣很有意思，一边聊天一边玩，说找对象要靠口才，乍一听好像有些片面了，但是仔细想想，许多时候人们的邂逅不就是第一次打招呼开始吗，现实中那些滔滔不绝，口若悬河的人也往往更能获得女生的关注，而我则可能呆在角落里看他们嬉戏打闹，我并不是不想参与，只是性格的原因导致我放不开，看见一个心动的女生也不敢上前打招呼，唯一一个令自己心动了那么多年的女生还在前不久和我断联，只能说是我咎由自取吧。但是老实话少就该被嫌弃吗，又或者说得不到关注，说到这儿又想起实验室即将毕业的学长，和他女朋友谈了几年了，工作也找好了，华为的一年40多w，能力强，却在前不久分手了，女方给出的原因是他太没有情趣了，随后就和另一个男生无缝衔接（我也只是听实验室的同学所说），女生的脑回路真的想不明白，当然每个人都有自己的选择，孰是孰非作为一个旁观者不好做评论，只是为这个学长感到不值罢了。<br>我曾经给我爸妈说过，我反正是不会走相亲这条路的。如果找不到互相喜欢的，那就这样一个人挺好的，努力赚钱，做自己想做的事，虽然知道对不起爸妈，但是我实在不想在感情这件事上妥协，我实在做不到和一个自己不喜欢的人去共度余生，那真的会是一场灾难。<br>昨晚莫名其妙又梦见她了，也不知道她现在过的怎样，我努力克制自己不去想她，让自己变得忙碌起来，大概两个月的时间没有像她，可是昨晚又做了一个很清晰的梦，让我不愿醒来。看来还得继续努力忘了她。<br>今天就随便写写，感情这事遇见了说明是缘分，遇不见也可能是缘分未到，只能不断的提升自己，静待花开。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/informal-essay/">随笔</category>
      
      <category domain="http://singlewang.top/categories/informal-essay/life/">生活感悟</category>
      
      
      <category domain="http://singlewang.top/tags/%E5%BF%83%E5%BE%97/">心得</category>
      
      <category domain="http://singlewang.top/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/">生活感悟</category>
      
      
      <comments>http://singlewang.top/2022/05/20/informal-essay/life/520%E9%9A%8F%E6%83%B3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch6PCIe与包处理</title>
      <link>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch6/</link>
      <guid>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch6/</guid>
      <pubDate>Thu, 19 May 2022 12:49:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;PCIe与包处理I-x2F-O&quot;&gt;&lt;a href=&quot;#PCIe与包处理I-x2F-O&quot; class=&quot;headerlink&quot; title=&quot;PCIe与包处理I&amp;#x2F;O&quot;&gt;&lt;/a&gt;PCIe与包处理I&amp;#x2F;O&lt;/h2&gt;&lt;h3 id=&quot;从PCIe事务的角度看</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="PCIe与包处理I-x2F-O"><a href="#PCIe与包处理I-x2F-O" class="headerlink" title="PCIe与包处理I&#x2F;O"></a>PCIe与包处理I&#x2F;O</h2><h3 id="从PCIe事务的角度看包处理"><a href="#从PCIe事务的角度看包处理" class="headerlink" title="从PCIe事务的角度看包处理"></a>从PCIe事务的角度看包处理</h3><h4 id="PCIe概览"><a href="#PCIe概览" class="headerlink" title="PCIe概览"></a>PCIe概览</h4><p>PCI Express（Peripheral Component Interconnect Express） 又称PCIe，是一种高速串行通信互联标准。<br>其规范遵循开放系统互联参考模型（OSI），自上而下分为事务传输层，数据链路层，物理层。把物理层朝PCIe根组件（Root Complex）方向的流量叫做上游流量（<code>upstream/inbound</code>）,反之叫做下游流量（<code>downstrean/outbound</code>）。</p><h4 id="PCIe事务传输"><a href="#PCIe事务传输" class="headerlink" title="PCIe事务传输"></a>PCIe事务传输</h4><p>在PCIe的线路上抓取一个TLP（Transaction Layer Packet，事务传输层数据包），它是一种分组形式，层层嵌套，最内层是事务传输层，有头部、数据和校验部分，头部定义了一组事务类型。从CPU网卡收发包来说，用到的PCIe的事务类型主要以<code>Memory Read/Write（MRd/MWr）</code>，<code>Completioin with Data</code>和次外层是数据链路层,最外层是物理层。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91/">报文转发</category>
      
      
      <comments>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch3并行计算</title>
      <link>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch3/</link>
      <guid>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch3/</guid>
      <pubDate>Thu, 19 May 2022 12:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;并行计算&quot;&gt;&lt;a href=&quot;#并行计算&quot; class=&quot;headerlink&quot; title=&quot;并行计算&quot;&gt;&lt;/a&gt;并行计算&lt;/h2&gt;&lt;p&gt;处理器性能提升主要有两个途径：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提高IPC(每个时钟周期内可执行的指令条数)&lt;/li&gt;
&lt;li&gt;提</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h2><p>处理器性能提升主要有两个途径：</p><ol><li>提高IPC(每个时钟周期内可执行的指令条数)</li><li>提高处理器主频(一味提高会触及频率墙，处理器的功耗正比与主频的三次方)</li></ol><p>可以通过提高指令执行的并行度提高IPC，有两种方法：</p><ol><li>提高微架构的指令并行度</li><li>多核并发</li></ol><h3 id="多核性能和可扩展性"><a href="#多核性能和可扩展性" class="headerlink" title="多核性能和可扩展性"></a>多核性能和可扩展性</h3><h4 id="追求性能水平扩展"><a href="#追求性能水平扩展" class="headerlink" title="追求性能水平扩展"></a>追求性能水平扩展</h4><blockquote><p>Amdahl定律告诉我们，假设一个工作的任务量不变，多核并行计算理论时延加速上限取决于那些不能并行处理部分的比例。</p></blockquote><blockquote><p>Gustafson定律指出，多核并行计算额吞吐率随核数增加而线性扩展，可并行处理部分占整个任务的比例越高，增长的斜率越大。</p></blockquote><h4 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h4><p>CPU物理核中的基本组件可以简化为：CPU寄存器集合、中断逻辑、执行单元和Cache。<br>多核处理器就是指多颗单独封装的CPU通过外部总线连接构成统一的计算平台。</p><blockquote><p>一个物理封装的CPU(通过physical id区分)可以有多个核(通过core id区分)。每个核可以有多个逻辑CPU(通过processor区分判断)。</p></blockquote><h4 id="亲和性"><a href="#亲和性" class="headerlink" title="亲和性"></a>亲和性</h4><p>CPU亲和性指一个特定的任务要在某个给定的CPU上尽量长时间的运行而不被迁移到其他处理器上的倾向性。</p><p>线程迁移的频率小就意味着产生的负载小。</p><h5 id="Linux内核对亲和性的支持"><a href="#Linux内核对亲和性的支持" class="headerlink" title="Linux内核对亲和性的支持"></a>Linux内核对亲和性的支持</h5><p>在Linux内核中，所有的线程都有一个相关的数据结构，称为<code>mask_struct</code>。与亲和性相关度最高的是<code>cpus_allowed</code>位掩码。这个位掩码由n位组成，与系统中的n个逻辑核一一对应。如果针对某个线程设置了相关的位，那么这个线程就可以在相关的CPU上运行。</p><p>Linux相关API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sched_set_affinity() <span class="comment">//用来修改位掩码</span></span><br><span class="line">sched_get_affinity() <span class="comment">//用来查看当前的位掩码</span></span><br></pre></td></tr></table></figure><blockquote><p><code>cpu_affinity</code>会被传递给子线程，因此应该适当的调用<code>sched_set_affinity</code>。</p></blockquote><h5 id="为什么使用亲和性"><a href="#为什么使用亲和性" class="headerlink" title="为什么使用亲和性"></a>为什么使用亲和性</h5><p>将线程与CPU绑定，最直观的好处就是提高了Cache的命中率，减少内存方位损耗，提高程序的速度。<br>减少了线程来回迁移的性能消耗，线程之间干扰也会减少。</p><p>使用亲和性的三个原因：</p><ol><li>有大量计算要做</li><li>测试复杂的应用程序</li><li>运行时间敏感的、决定性的线程</li></ol><h5 id="线程独占"><a href="#线程独占" class="headerlink" title="线程独占"></a>线程独占</h5><p>DPDK通过把线程绑定到逻辑核的方法避免跨核任务中的切换开销，但对于绑定运行的当前逻辑核，仍然可能会有线程切换的发生。因此可以进一步采取把逻辑核从内核调度系统剥离的方法。</p><p>linux内核提供了启动参数<code>isolcpus</code>。对于有4个CPU的服务器，在启动的时候加入启动参数isolcpus&#x3D;2，3.那么系统启动后将不使用CPU3和CPU4;但是还是可以通过<code>taskset</code>指定哪些程序在这些核心中运行。</p><p>步骤如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /boot/grub2.cfg <span class="comment">//在Linux kernel启动参数里面加入isolcpus参数，isolcpu=2， 3</span></span><br><span class="line"></span><br><span class="line">cat /proc/cmdline  <span class="comment">//等待系统重新启动之后查看启动参数BOOT_IMAGE=/boot/vmlinuz3.17.8-200.fc20.x86_64root=UUID=3ae47813-79ea-4805-a732-</span></span><br><span class="line"><span class="number">21b</span>edcbdb0b5ro LANG=en_US.UTF<span class="number">-8</span>isolcpus=<span class="number">2</span>，<span class="number">3</span>。</span><br></pre></td></tr></table></figure><h5 id="DPDK的多线程"><a href="#DPDK的多线程" class="headerlink" title="DPDK的多线程"></a>DPDK的多线程</h5><p>DPDK的线程基于<code>pthread</code>接口创建，属于抢占式线程模型，受内核调度支配。</p><ol><li>EAL中的lcore</li></ol><p>DPDK的lcore指的是EAL线程，本质是基于<code>pthread</code>(Linux&#x2F;FreeBSD)封装实现。<code>lcore</code>由<code>remote_launch</code>指定的任务创建并管理。在每个EAL pthread中， 有一个TLS（Thread Local Storage）称为_lcore_id。当使用DPDK的 EAL‘-c’参数指定coremask时，EAL pthread生成相应个数lcore并默 认是1：1亲和到coremask对应的CPU逻辑核，_lcore_id和CPU ID是一致的。</p><p><em><strong>DPDK中lcore的初始化及执行任务的注册</strong></em></p><ul><li>初始化<ul><li><code>rte_eal_cpu_init()</code>函数中，通过读取<code>/sys/devices/system/cpu/cpuX/</code>,确定当前系统有哪些CPU核，以及每个核属于哪个CPU Socket。</li><li><code>eal_parse_args()</code>函数，解析-c参数。</li><li>为每一个SLAVE核创建线程，并调用<code>eal_thread_set_affinity()</code>绑定CPU。线程的执行体是<code>eal_thread_loop()</code></li></ul></li><li>注册<br>不同的模块需要调用<code>rte_eal_mp_remote_launch()</code>,将自己的回调处理函数注册到lcore_config[]中。</li></ul>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/">并行计算</category>
      
      
      <comments>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch4同步互斥机制</title>
      <link>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch4/</link>
      <guid>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch4/</guid>
      <pubDate>Thu, 19 May 2022 12:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;DPDK原子操作实现和应用&quot;&gt;&lt;a href=&quot;#DPDK原子操作实现和应用&quot; class=&quot;headerlink&quot; title=&quot;DPDK原子操作实现和应用&quot;&gt;&lt;/a&gt;DPDK原子操作实现和应用&lt;/h3&gt;&lt;p&gt;原子操作在DPD代码中的定义都在&lt;code&gt;rte_</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="DPDK原子操作实现和应用"><a href="#DPDK原子操作实现和应用" class="headerlink" title="DPDK原子操作实现和应用"></a>DPDK原子操作实现和应用</h3><p>原子操作在DPD代码中的定义都在<code>rte_atomic.h</code>中，主要包含两部分：<strong>内存屏蔽和原16、32和64位的原子操作API</strong></p><blockquote><p>Linux内核的原子操作见linux驱动</p></blockquote><h4 id="内存屏障API"><a href="#内存屏障API" class="headerlink" title="内存屏障API"></a>内存屏障API</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rte_mb()  <span class="comment">//内存屏障读写API</span></span><br><span class="line">rte_wmb()  <span class="comment">//内存屏障写API</span></span><br><span class="line">rte_rmb()  <span class="comment">//内存屏障读API</span></span><br></pre></td></tr></table></figure><h3 id="DPDK读写锁实现和应用"><a href="#DPDK读写锁实现和应用" class="headerlink" title="DPDK读写锁实现和应用"></a>DPDK读写锁实现和应用</h3><p>DPDK的读写锁的定义在<code>rte_rwlock.h</code>中，</p><blockquote><p>linux读写锁的API见linux驱动</p></blockquote><p><code>rte_rwlock_init(rte_rwlock_t *rwl)</code>:初始化读写锁到unlocked状态<br><code>rte_rwlock_read_lock(rte_rwlock_t *rwl)</code>:尝试获取读锁直到锁被占用<br><code>rte_rwlock_read_unlock(rte_rwlock_t *rwl)</code>:释放读锁<br><code>rte_rwlock_write_lock(rte_rwlock_t *rwl)</code>:获取写锁<br><code>rte_rwlock_write_unlock(rte_rwlock_t *rwl)</code>:释放写锁</p><p>读写锁在DPDK中主要应用在如下几个地方：</p><ol><li>在查找空闲的<code>memory segment</code>的时候，使用读写锁来保护<code>memseg</code>结构，LPM表的创建、查找和释放</li><li><code>Memory ring</code>的创建、查找、释放</li><li>ACL表的创建、查找、释放</li><li>Memzone的创建、查找、释放</li></ol><h3 id="DPDK自旋锁实现和应用"><a href="#DPDK自旋锁实现和应用" class="headerlink" title="DPDK自旋锁实现和应用"></a>DPDK自旋锁实现和应用</h3><p>DPDK自旋锁API的定义在<code>rte_spinlock.h</code>中，下面三个API被广泛应用在告警、日志、中断机制、内存共享、link bonding中用于临界资源的保护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rte_spinlock_init(<span class="type">rte_spinlock_t</span> *sl)</span><br><span class="line">rte_spinlock_lock(<span class="type">rte_spinlock_t</span> *sl)</span><br><span class="line">rte_spinlock_unlock(<span class="type">rte_spinlock_t</span> *sl)</span><br></pre></td></tr></table></figure><h3 id="DPDK无锁环形缓冲"><a href="#DPDK无锁环形缓冲" class="headerlink" title="DPDK无锁环形缓冲"></a>DPDK无锁环形缓冲</h3><p>DPDK提供了一套无锁环形缓冲区队列管理代码，支持单生产者产品入队，单消费者产品出队；多生产者入队，多消费者出队</p><blockquote><p>见DPDK基础</p></blockquote><p>单生产者单消费者模型不需要加锁<br>（一）多对多（一）模型中正常逻辑操作是要对队列操作进行加锁处理。加锁的性能开销较大，一般采用无锁实现。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/">同步互斥</category>
      
      
      <comments>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入浅出dpdk-ch5报文转发</title>
      <link>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch5/</link>
      <guid>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch5/</guid>
      <pubDate>Thu, 19 May 2022 11:40:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;报文转发&quot;&gt;&lt;a href=&quot;#报文转发&quot; class=&quot;headerlink&quot; title=&quot;报文转发&quot;&gt;&lt;/a&gt;报文转发&lt;/h2&gt;&lt;h3 id=&quot;网络处理模块划分&quot;&gt;&lt;a href=&quot;#网络处理模块划分&quot; class=&quot;headerlink&quot; title=&quot;网</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="报文转发"><a href="#报文转发" class="headerlink" title="报文转发"></a>报文转发</h2><h3 id="网络处理模块划分"><a href="#网络处理模块划分" class="headerlink" title="网络处理模块划分"></a>网络处理模块划分</h3><p>网络报文的处理和转发主要分为硬件处理部分和软件处理部分：</p><ol><li>报文输入</li><li>对保温进行比较粗粒度的处理</li><li>对保温进行比较细粒度的分流</li><li>提供基于描述符的队列FIFO</li><li>根据队列优先级和CPU状态进行调度</li><li>提供加解密和压缩&#x2F;解压缩等硬件功能</li><li>在出口上根据QOS等级进行调度</li><li>后期报文处理释放缓存</li><li>从硬件上发送出去</li></ol><h3 id="转发框架介绍"><a href="#转发框架介绍" class="headerlink" title="转发框架介绍"></a>转发框架介绍</h3><p>传统的专用网络处理器转发的模型可以分为<code>run to completion</code>模型和<code>pipeline</code>模型</p><ol><li>pipeline模型<br>将一个功能分解成多个独立的阶段，不同阶段间通过队列传递。</li><li>run to completion模型<br><code>run to completion</code>（运行至终结）模型时主要针对DPDK一般程度的运行方法，一个程序中一般会分为几个不同的逻辑功能，但是这几个逻辑功能会在一个CPU的核上运行，我们可以进行水平扩展使得在SMP的系统中多个核上执行一个逻辑的程序，从而提高单位时间内事务处理的量。<h4 id="DPDK-run-to-completion模型"><a href="#DPDK-run-to-completion模型" class="headerlink" title="DPDK run to completion模型"></a>DPDK run to completion模型</h4>DPDK的轮询模式能够通过一些参数设置哪些核可以被DPDK使用，最后再把处理对应收发队列的线程绑定到对应的核上。每个报文的生命周期只可能再一个线程中出现。但是针对单个报文的处理始终集中在一个逻辑单元上，无法利用其他运算单元，并且逻辑的耦合性太强，而流水线模型正好解决了以上的问题。<h4 id="DPDK-pipeline模型"><a href="#DPDK-pipeline模型" class="headerlink" title="DPDK pipeline模型"></a>DPDK pipeline模型</h4>pipeline的主要思想就是不同的工作交给不同的模块，每个模块单独处理特定的事务，每个模块都有输入和输出，通过输入输出将这些模块联系起来，完成复杂的网络功能。<br>DPDK的pipeline是由三大部分组成，逻辑端口(port)、查找表（table）和处理逻辑（action）。DPDK的pipeline模型中把网络端口作为每个处理模块的输入，所有的报文输入都通过这个端口进行。查找表是每个处理模块的处理逻辑核心，转发逻辑指明了报文的流向和处理。<br>用户可以根据这三大类构建属于自己的pipeline。<br>现在DPDK支持的pipeline有以下几种：</li></ol><ul><li>Packet I&#x2F;O</li><li>Flow classification</li><li>Firewall</li><li>Routing</li><li>Metering</li><li>Traffic Mgmt</li></ul>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/dpdk/">DPDK</category>
      
      <category domain="http://singlewang.top/categories/dpdk/dpdk-advanced/">DPDK进阶</category>
      
      
      <category domain="http://singlewang.top/tags/dpdk/">dpdk</category>
      
      <category domain="http://singlewang.top/tags/%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91/">报文转发</category>
      
      
      <comments>http://singlewang.top/2022/05/19/dpdk/dpdk-advanced/dpdk%E8%BF%9B%E9%98%B6-ch5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux网络设备驱动</title>
      <link>http://singlewang.top/2022/05/11/linux/linux-kernal/linux-kernal-driver/linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</link>
      <guid>http://singlewang.top/2022/05/11/linux/linux-kernal/linux-kernal-driver/linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</guid>
      <pubDate>Wed, 11 May 2022 11:57:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;linux网络设备驱动&quot;&gt;&lt;a href=&quot;#linux网络设备驱动&quot; class=&quot;headerlink&quot; title=&quot;linux网络设备驱动&quot;&gt;&lt;/a&gt;linux网络设备驱动&lt;/h2&gt;&lt;h3 id=&quot;linux网络设备驱动的体系结构&quot;&gt;&lt;a href=&quot;#l</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="linux网络设备驱动"><a href="#linux网络设备驱动" class="headerlink" title="linux网络设备驱动"></a>linux网络设备驱动</h2><h3 id="linux网络设备驱动的体系结构"><a href="#linux网络设备驱动的体系结构" class="headerlink" title="linux网络设备驱动的体系结构"></a>linux网络设备驱动的体系结构</h3><p>linux网络设备体系结构从上往下分为4层，依次为网络协议接口层、网络设备接口层、提供实际功能的设备驱动功能层以及网路设备与媒介层。四层作用如下：</p><ol><li><strong>网络协议接口层</strong>向网络层协议提供统一的数据包发送接口，通过<code>dev_queue_xmit()</code>发送数据，通过<code>netif_rx()</code>接收数据。</li><li><strong>网络设备接口层</strong>向协议接口层提供统一的用于描述网络设备属性和操作的结构体<code>net_device</code>。</li><li><strong>设备驱动功能层</strong>个函数是网络接口层<code>net_device</code>数据结构的成员，通过<code>hard_start_xmit()</code>函数启动发送操作，并通过网络设备上的中断触发接收操作。</li><li><strong>网络设备与媒介层</strong>是完成数据包发送和接收的物理实体。对于Linux系统而言，网络设备和媒介都可以是虚拟的。</li></ol><h4 id="网络协议接口层"><a href="#网络协议接口层" class="headerlink" title="网络协议接口层"></a>网络协议接口层</h4><p>网络协议接口层最主要的功能是给上层协议提供了透明的数据包发送和接收接口。<br><code>dev_queue_xmit()</code>的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev_queue_xmit(<span class="keyword">struct</span> sk_buff *skb);</span><br></pre></td></tr></table></figure><p><code>netif_rx()</code>的函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">netif_rx</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><code>sk_buff</code>结构提非常重要，含义为<strong>套接字缓冲区</strong>，用于在Linux网路子系统中的各层之间传送数据。</p></blockquote><ol><li>套接字缓冲区成员<br>（1）各层协议头<code>h</code>、<code>nh</code>、<code>mac</code><br>传输层协议头<code>h</code>，网络层协议头<code>nh</code>，链路层协议头<code>mac</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udphdr</span> *<span class="title">uh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmphdr</span> *<span class="title">icmph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">igmphdr</span> *<span class="title">igmph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span>   * <span class="title">iph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipv6hdr</span> *<span class="title">ipv6h</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *raw; <span class="comment">//数据链路层头部 </span></span><br><span class="line">&#125;h;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipv6hdr</span> *<span class="title">ipv6h</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arphdr</span> *<span class="title">arph</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *raw;<span class="comment">//数据链路层头部</span></span><br><span class="line">&#125;nh;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *raw;</span><br><span class="line">&#125;mac;</span><br></pre></td></tr></table></figure></li></ol><p>(2)数据缓冲区指针<code>head、data、tail、end</code></p><ul><li><code>head</code>指针指向内存中已分配的用于承载网络数据缓冲区的起始地址。</li><li><code>data</code>指针指向对应当前协议层有效数据的起始地址</li><li><code>tail</code>指针指向对应当前协议层有效数据负载的结尾地址。</li><li><code>end</code>指针指向内存中分配的主机缓冲区的结尾</li></ul><p>(3)长度信息<code>len、data_len、truesize</code></p><ul><li><code>len</code>指数据包有效长度，包括协议头和负载(payload)</li><li><code>data_len</code>记录分片的数据长度</li><li><code>truesize</code>表示缓存区的整体长度。</li></ul><ol start="2"><li>套接字缓冲区操作</li></ol><p>(1)分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">alloc_skb</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> len,<span class="type">int</span> priority)</span>;<span class="comment">//priority为内存分配的优先级</span></span><br><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">dev_alloc_skb</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure><p>分配成功后，<code>sk_buff</code>的<code>data</code>，<code>tail</code>指针都指向存储空间的起始地址<code>head</code>。<code>len</code>的大小为0。</p><p>(2)释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_kfree_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_kfree_skb_irq</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_kfree_skb_any</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br></pre></td></tr></table></figure><p>上述函数用于释放分配的套接字缓冲区和数据缓冲区。linux内核使用<code>kfree_skb()</code>,网络设备驱动程序中必须使用其他三个。<code>dev_kfree_skb()</code>用于非中断上下文，<code>dev_kfree_skb_irq()</code>用于中断上下文，any均可采用。<br>(3)指针移动</p><ul><li>put操作<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_put</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len)</span>; <span class="comment">//会对数据进行检查</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *__skb_put(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len); <span class="comment">//不会对数据进行检查</span></span><br></pre></td></tr></table></figure></li></ul><p>上述函数将<code>tail</code>指针下移，增加<code>sk_buff</code>的<code>len</code>，并返回<code>skb-&gt;tail</code>的当前值。主要用于在缓冲区尾部添加数据。</p><ul><li><p>push操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_push</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *__skb_push(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len);</span><br></pre></td></tr></table></figure><p>主要用于在数据包发送给是添加头部。</p></li><li><p>pull操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_pull</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure><p>此函数将<code>data</code>指针下移，减小<code>len</code>的值，一般用于下层协议向上层协议移交数据包，使<code>data</code>指针指向上层协议的协议头</p></li><li><p>reserve操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skb_reserve</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure><p>主要用于在存储空间的头部预留<code>len</code>长度的空隙。</p></li></ul><h4 id="网络设备接口层"><a href="#网络设备接口层" class="headerlink" title="网络设备接口层"></a>网络设备接口层</h4><p><code>net_device</code>结构体在内核中指代一个网络设备，只需通过填充<code>net_device</code>的具体成员并注册即可实现硬件操作函数与内核的挂接</p><ol><li><p>全局信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[IFNAMESIZE];</span><br><span class="line"><span class="type">int</span> (*init)(<span class="keyword">struct</span> net_device *dev);</span><br></pre></td></tr></table></figure><p><code>name</code>是网络设备的名称。<code>init</code>为设备初始化函数指针，如果这个指针被设置了，则网络设备被注册时将调用该函数完成对<code>net_device</code>结构体的初始化。</p></li><li><p>硬件信息</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mem_end;<span class="comment">//共享内存的结束地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mem_start;<span class="comment">//共享内存的起始地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> base_addr;<span class="comment">//网络设备I/O基地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> irq;<span class="comment">//中断号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> if_port;<span class="comment">//使用的端口</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dma;<span class="comment">//分配给设备的DMA通道</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>接口信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> hard_header_len;<span class="comment">//网络设备的硬件头长度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> type<span class="comment">//接口的硬件类型</span></span><br><span class="line"><span class="type">unsigned</span> mtu; <span class="comment">//最大传输单元</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dev_addr[MAX_ADDR_LEN];<span class="comment">//存放硬件地址，需由驱动程序从硬件上读出并填充到dev_addr[]中。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> broadcast[MAX_ADDR_LEN];<span class="comment">//存放广播地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> flags;<span class="comment">//网络接口标志</span></span><br></pre></td></tr></table></figure></li><li><p>设备操作函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*open)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//打开网络接口设备</span></span><br><span class="line"><span class="type">int</span> (*stop)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//停止网络接口设备</span></span><br><span class="line"><span class="type">int</span> (*hard_start_xmit)(<span class="keyword">struct</span> sk_buff *skb,<span class="keyword">struct</span> net_device *dev);<span class="comment">//启动数据包的发送</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_dev_stats</span>* (*<span class="title">get_stats</span>)(<span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>);</span><span class="comment">//用于获得网络设备的状态信息，net_dev_stats保存了网络设备的详细的流量信息，如发送和接收到的数据包数、字节数等</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="设备驱动功能层。"><a href="#设备驱动功能层。" class="headerlink" title="设备驱动功能层。"></a>设备驱动功能层。</h4><p><code>net_device</code>结构体的成员需要被设备驱动功能层的具体数值和函数赋予，驱动开发主要就是在这一层进行。</p><h4 id="网络设备与媒介层"><a href="#网络设备与媒介层" class="headerlink" title="网络设备与媒介层"></a>网络设备与媒介层</h4><p>网络设备与媒介层直接对应于与实际的硬件设备。</p><h3 id="网络设备驱动的注册与注销"><a href="#网络设备驱动的注册与注销" class="headerlink" title="网络设备驱动的注册与注销"></a>网络设备驱动的注册与注销</h3><p>网络设备驱动的注册于注销分别使用<code>register_netdev()</code>和<code>unregister_netdev()</code>完成，这两个函数的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_netdev</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_netdev</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure><p><code>net_device</code>的成员可以里用下面的函数帮助我们填充</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> net_device *<span class="title function_">alloc_netdev</span><span class="params">(<span class="type">int</span> sizeof_priv,<span class="type">const</span> <span class="type">char</span> *name,<span class="type">void</span>(*setup)(<span class="keyword">struct</span> net_device*))</span>;</span><br><span class="line"><span class="keyword">struct</span> net_device *<span class="title function_">alloc_etherdev</span><span class="params">(<span class="type">int</span> sizeof_priv)</span>;</span><br></pre></td></tr></table></figure><p>释放net_device结构体的函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free_netdev(<span class="keyword">struct</span> net_device *dev);</span><br></pre></td></tr></table></figure><p><code>net_device</code>结构体的分配和网络设备驱动注册需在网络设备驱动程序的模块加载函数中进行，而<code>net_device</code>结构体的释放和网络设备驱动的注销需要在模块卸载函数中完成。</p><h3 id="网络设备的初始化"><a href="#网络设备的初始化" class="headerlink" title="网络设备的初始化"></a>网络设备的初始化</h3><p>网络设备的初始化主要需要完成如下几个方面的工作：</p><ul><li>进行硬件上的准备工作，检查网络设备是否存在。</li><li>进行软件接口上的准备工作，分配net_device结构体并对其数据和函数指针成员赋值</li><li>获得设备的私有信息指针并初始化其成员的值。如果私有信息中包括自旋锁或信号量等并发或同步机制，则需对其进行初始化。</li></ul><h3 id="网络设备的打开与释放"><a href="#网络设备的打开与释放" class="headerlink" title="网络设备的打开与释放"></a>网络设备的打开与释放</h3><p>网络设备的打开函数需要完成如下工作：</p><ul><li>使能设备使用的硬件资源，申请I&#x2F;O区域、中断和DMA通道等。</li><li>调用Linux内核提供的<code>netif_start_queue()</code>函数，激活设备发送队列。</li></ul><p>网络设备的关闭函数需要完成如下工作：</p><ul><li>调用Linux内核提供的<code>netif_stop_queue()</code>函数，停止设备传输包</li><li>释放设备所使用的I&#x2F;O区域、中断和DMA资源。</li></ul><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_start_queue</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">netif_stop_queue</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure><h3 id="数据发送流程"><a href="#数据发送流程" class="headerlink" title="数据发送流程"></a>数据发送流程</h3><p>网络设备驱动完成数据包发送的流程如下：</p><ol><li>网络设备驱动程序从上层协议传递过来的<code>sk_buff</code>参数获得数据包的有效数据和长度，将有效数据放入临时缓冲区。</li><li>对于以太网，如果有效数据的长度小于以太网冲突检测锁要求数据帧的最小长度<code>ETH_ZLEN</code>,则给临时缓冲区的末尾填充0。</li><li>设置硬件的寄存器，驱使网络设备进行数据发送操作。</li></ol><p>数据包发送函数模板：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">xxx_tx</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,<span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> *data,shortpkt[ETH_ZLEN];</span><br><span class="line"></span><br><span class="line">    data = skb-&gt;data;</span><br><span class="line">    len = skb-&gt;len;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;ETH_ZLEN)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(shortpkt,<span class="number">0</span>,ETH_ZLEN);</span><br><span class="line">        <span class="built_in">memcpy</span>(shortpkt,skb-&gt;data,skb-&gt;len);</span><br><span class="line">        len=ETH_ZLEN;</span><br><span class="line">        data = shortpkt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev-&gt;trans_start = jiffies;<span class="comment">//记录发送时间戳</span></span><br><span class="line"></span><br><span class="line">    xxx_hw_tx(data,len,dev);<span class="comment">//设置硬件寄存器让硬件把数据包发送出去。</span></span><br><span class="line">    ···;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数据传输超时时，数据包发送超时处理函数<code>xxx_tx_timeout()</code>将被调用。这个函数需要Linux内核提供的<code>netif_wake_queue</code>函数重新启动设备发送队列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">xxx_tx_timeout</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ···</span><br><span class="line">    netif_wake_queue(dev);<span class="comment">//重新启动设备发送队列。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据接收流程"><a href="#数据接收流程" class="headerlink" title="数据接收流程"></a>数据接收流程</h3><p>网络设备接收数据的主要方法是由中断引发设备的中断处理函数，中断处理函数判断中断类型，如果为接收中断，则读取接收到的数据，分配<code>sk_buffer</code>数据结构和数据缓冲区，将接收到的数据复制到数据缓冲区，并调用<code>netif_rx()</code>函数将sk_buffer传递给上层协议。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">xxx_interrupt</span><span class="params">(<span class="type">int</span> irq,<span class="type">void</span> *dev_id)</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/linux-kernal-driver/">Linux内核驱动</category>
      
      
      <category domain="http://singlewang.top/tags/Linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/">Linux网络设备</category>
      
      <category domain="http://singlewang.top/tags/Linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/">Linux内核驱动</category>
      
      
      <comments>http://singlewang.top/2022/05/11/linux/linux-kernal/linux-kernal-driver/linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Markdown公式编辑</title>
      <link>http://singlewang.top/2022/05/11/markdown/markdown-base/markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/</link>
      <guid>http://singlewang.top/2022/05/11/markdown/markdown-base/markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/</guid>
      <pubDate>Wed, 11 May 2022 09:43:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;公式编辑&quot;&gt;&lt;a href=&quot;#公式编辑&quot; class=&quot;headerlink&quot; title=&quot;公式编辑&quot;&gt;&lt;/a&gt;公式编辑&lt;/h3&gt;&lt;p&gt;一般公式分为两种形式，&lt;strong&gt;行内公式&lt;/strong&gt;和&lt;strong&gt;行间公式&lt;/strong&gt;&lt;/p&gt;
&lt;ul</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="公式编辑"><a href="#公式编辑" class="headerlink" title="公式编辑"></a>公式编辑</h3><p>一般公式分为两种形式，<strong>行内公式</strong>和<strong>行间公式</strong></p><ul><li>行内公式：$\Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt,. $</li><li>行间公式：$$\Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt,.$$</li></ul><p>行内公式实在公式代码块的基础上前面加上$,后面加上$组成的eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,. $</span><br></pre></td></tr></table></figure><p>行间公式在前后加上$$。eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,.$$</span><br></pre></td></tr></table></figure><h4 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h4><table><thead><tr><th align="center">名称</th><th align="center">大写</th><th align="center">code</th><th align="center">小写</th><th align="center">code</th></tr></thead><tbody><tr><td align="center">alpha</td><td align="center">A</td><td align="center">A</td><td align="center">α</td><td align="center">\alpha</td></tr><tr><td align="center">beta</td><td align="center">B</td><td align="center">B</td><td align="center">β</td><td align="center">\beta</td></tr><tr><td align="center">gamma</td><td align="center">Γ</td><td align="center">\Gamma</td><td align="center">γ</td><td align="center">\gamma</td></tr><tr><td align="center">delta</td><td align="center">Δ</td><td align="center">\Delta</td><td align="center">δ</td><td align="center">\delta</td></tr><tr><td align="center">theta</td><td align="center">Θ</td><td align="center">\Theta</td><td align="center">θ</td><td align="center">\theta</td></tr><tr><td align="center">lambda</td><td align="center">Λ</td><td align="center">\Lambda</td><td align="center">λ</td><td align="center">\lambda</td></tr><tr><td align="center">sigma</td><td align="center">Σ</td><td align="center">\Sigma</td><td align="center">σ</td><td align="center">\sigma</td></tr><tr><td align="center">omega</td><td align="center">Ω</td><td align="center">\Omega</td><td align="center">ω</td><td align="center">\omega</td></tr></tbody></table><h4 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h4><p>上标<code>^</code>,下标<code>_</code>,例如<code>$x_i^2$</code>表示的是：$x_i^2$。<br>默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用<code>&#123;..&#125;</code>包裹起来的内容。</p><h4 id="小括号与方括号"><a href="#小括号与方括号" class="headerlink" title="小括号与方括号"></a>小括号与方括号</h4><p>使用原始的( ) ，[ ] 即可，如<code>$(2+3)[4+4]$ </code>:$(2+3)[4+4]$<br>使用\left(或\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如<code>$\left(\frac&#123;x&#125;&#123;y&#125;\right)$ </code>：$\left(\frac{x}{y}\right)$</p><h4 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h4><p>由于大括号{} 被用于分组，因此需要使用<code>\&#123;</code>和<code>\&#125;</code>表示大括号，也可以使用<code>\lbrace </code>和<code>\rbrace</code>来表示。如<code>$\&#123;a\*b\&#125;:a\∗b$ </code>或<code>$\lbrace a\*b\rbrace :a\*b$</code></p><h4 id="尖括号"><a href="#尖括号" class="headerlink" title="尖括号"></a>尖括号</h4><p>区分于小于号和大于号，使用<code>\langle</code> 和<code>\rangle</code> 表示左尖括号和右尖括号。如<code>$\langle x \rangle$</code> 表示：$\langle x \rangle$。</p><h4 id="上取整"><a href="#上取整" class="headerlink" title="上取整"></a>上取整</h4><p>使用<code>\lceil</code> 和 <code>\rceil</code> 表示。 如，<code>$\lceil x \rceil$</code>：$\lceil x \rceil$</p><h4 id="下取整"><a href="#下取整" class="headerlink" title="下取整"></a>下取整</h4><p>使用<code>\lfloor</code> 和 <code>\rfloor</code> 表示。如，<code>$\lfloor x \rfloor$</code>：$\lfloor x \rfloor$</p><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><p><code>\sum</code> 用来表示求和符号，其下标表示求和下限，上标表示上限。如:<br><code>$\sum_&#123;r=1&#125;^n$</code>表示：$\sum_{r&#x3D;1}^n$。</p><h4 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h4><p><code>\int</code> 用来表示积分符号，同样地，其上下标表示积分的上下限。如，<code>$\int_&#123;r=1&#125;^\infty$</code>：$\int_{r&#x3D;1}^\infty$。<br>多重积分同样使用 int ，通过 i 的数量表示积分导数：<br><code>$\iint$</code> ：$\iint$<br><code>$\iiint$</code> ：$\iiint$</p><h4 id="连乘"><a href="#连乘" class="headerlink" title="连乘"></a>连乘</h4><p><code>$\prod &#123;a+b&#125;$</code>，输出：$\prod {a+b}$。<br><code>$\prod_&#123;i=1&#125;^&#123;K&#125;$</code>，输出：$\prod_{i&#x3D;1}^{K}$。<br><code>$$\prod_&#123;i=1&#125;^&#123;K&#125;$$</code>，输出：$$\prod_{i&#x3D;1}^{K}$$</p><h4 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h4><ul><li>第一种，使用<code>\frac ab</code>，<code>\frac</code>作用于其后的两个组<code>a </code>，<code>b</code> ，结果为$\frac ab$。如果你的分子或分母不是单个字符，请使用{..}来分组，比如<code>$\frac &#123;a+c+1&#125;&#123;b+c+2&#125;$</code>表示$\frac {a+c+1}{b+c+2}$。</li><li>第二种，使用<code>\over</code>来分隔一个组的前后两部分，如<code>$&#123;a+1\over b+1&#125;$</code>：${a+1\over b+1}$。</li></ul><h4 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h4><p>根式使用<code>\sqrt</code> 来表示。<br>如开4次方：<code>$\sqrt[4]&#123;\frac xy&#125;$</code> ：$\sqrt[4]{\frac xy}$。<br>开平方：<code>$\sqrt &#123;a+b&#125;$</code>：$\sqrt {a+b}$。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/markdown/">Markdown</category>
      
      <category domain="http://singlewang.top/categories/markdown/markdown-base/">Markdown基础</category>
      
      
      <category domain="http://singlewang.top/tags/%E6%95%99%E7%A8%8B/">教程</category>
      
      <category domain="http://singlewang.top/tags/Markdown%E5%85%AC%E5%BC%8F/">Markdown公式</category>
      
      
      <comments>http://singlewang.top/2022/05/11/markdown/markdown-base/markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TCP窗口与拥塞控制</title>
      <link>http://singlewang.top/2022/05/10/mobile-communication/TCP%E7%AA%97%E5%8F%A3/</link>
      <guid>http://singlewang.top/2022/05/10/mobile-communication/TCP%E7%AA%97%E5%8F%A3/</guid>
      <pubDate>Tue, 10 May 2022 11:47:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;TCP的特点及其目的&quot;&gt;&lt;a href=&quot;#TCP的特点及其目的&quot; class=&quot;headerlink&quot; title=&quot;TCP的特点及其目的&quot;&gt;&lt;/a&gt;TCP的特点及其目的&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;TCP&lt;/strong&gt;和&lt;strong&gt;UDP&lt;/stro</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="TCP的特点及其目的"><a href="#TCP的特点及其目的" class="headerlink" title="TCP的特点及其目的"></a>TCP的特点及其目的</h3><p><strong>TCP</strong>和<strong>UDP</strong>协议都位于传输层中，TCP主要提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p><p><em>TCP是面向连接的可靠的流协议，流就是指不简短的数据结构。采用TCP发送消息时，虽然可以保证发送的顺序，但是还是犹如没有任何间隔的数据流发送给接收端</em></p><blockquote><p><strong>连接</strong>是指各种设备，线路，或网络中进行通信的两个应用程序为了相互传递消息而转悠的、虚拟的通信线路，也叫虚拟电路。</p></blockquote><p>TCP为提供可靠性传输，实行“顺序控制”或“重传控制”机制。此外还有“流控制”，“拥塞控制”等众多功能。</p><h3 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h3><p>在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知，这个消息叫做<strong>确认应答（ACK）</strong>,如果有确认应答，说明数据已经成功到达对端，反之，则数据丢失的可能性很大，倘若在一段时间内没有ACK,则发送端进行数据的重发。</p><p>未收到ACK,有如下几种情况：</p><ol><li>发出去的数据包丢失</li><li>接收端发回来的ACK在途中丢失。</li></ol><p>虽然在发送端可以按照机制重传，但是对于接收端会重复收到相同的数据，为了对上层应用提供可靠的传输，必须放弃重复的数据包。需要引入一种机制识别是否已经接收数据，判断是否需要接收。</p><p>使用<strong>序列号</strong>解决上述问题。</p><p>序列号时按顺序发送给数据的每一个字节都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序号作为ACK返回，这样就可以是心啊可靠传输。</p><h3 id="重发超时如何确定"><a href="#重发超时如何确定" class="headerlink" title="重发超时如何确定"></a>重发超时如何确定</h3><p><strong>重发超时</strong>指在重发数据之前，等待ACK的那个特定时间间隔，如果超过了这个时间还未收到ACK，发送端就进行数据重发。</p><p>最理想的时间是，找一个最小时间，能保证 <em><strong>确认应答一定能在这个时间内返回</strong></em>。但是TCP要求在任何网络环境下都要提供高性能通信，无论网络拥塞情况如何，都要保持这一特性。因此每次发包时都会计算<strong>往返时间（RTT）</strong>及其偏差，将这个RTT和偏差相加，重发超时的时间就是比这个总和稍微大一点的值。</p><p>在linux系统中，一般以0.5秒为单位进行控制。最初的数据包的重发超时一般设置为6s。<br>数据被重发之后还是收不到ACK，则进行再次重发，但是等待的时间以2倍，4倍指数函数进行增长。达到一定次数后，如果仍然欸有收到ACK，则通知应用通信异常，强行关闭。</p><h3 id="TCP以段为单位发送数据"><a href="#TCP以段为单位发送数据" class="headerlink" title="TCP以段为单位发送数据"></a>TCP以段为单位发送数据</h3><p>建立TCP连接的同时，可以确定发送数据包的单位，称其为<strong>最大消息长度</strong>(MSS)。最理想的情况时最大消息长度正好是IP中不会被分片处理的最大数据长度。</p><p>MSS实在三次握手的时候，在两端主机之间被计算得出。两端主机在建立连接的时候，在TCP首部写入MSS选项，告诉对方自己的接口能适应的MSS的大小，然后选一个较小的值使用。</p><h3 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h3><p>TCP以段为单位，每发一个段进行一次ACK的处理。但是这样一来，包的往返时间越长通信性能就越低。</p><p>于是乎，TCP引入<strong>窗口</strong>这个概念，即发送端主机，发送了一个段后不必一直等待ACK,而是继续发送。<br><strong>窗口大小</strong>就是指无需等待确认应答就可以继续阿松数据的最大值。这个机制实现使用了大量的<strong>缓冲区</strong>。<br>在窗口内的数据即便没有收到确认应答也可以发送出去。而在滑动窗口以外的部分包括尚未发送的数据以及已经确认对端已收到的数据。当数据发出后若收到确认则不必重发，此时数据就可以从缓冲区清除。<br>这种机制也被称为 <strong>滑动窗口控制</strong>。</p><h3 id="窗口控制与重发控制"><a href="#窗口控制与重发控制" class="headerlink" title="窗口控制与重发控制"></a>窗口控制与重发控制</h3><p>窗口控制时，若出现段丢失该怎么办？</p><ol><li><p><strong>确认应答未能返回的情况</strong><br>这种情况下，数据已经到达对端，不需要进行重发，窗口在一定程度上较大时，即使有少部分的确认应答丢失也不会进行数据重发。可以通过下一个确认应答进行确认。</p></li><li><p><strong>报文段丢失的情况</strong><br>当某一报文段丢失后，发送段会一直收到某个序号的ACK，同一个序号的ACK会被重复不断地返回。而发送端主机如果连续三次收到同一个ACK，就会将其对应的数据进行重发。这种机制被称为 <strong>高速重发控制</strong></p></li></ol><h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><p><strong>流控制</strong>是一种可以让发送端根据接收端的实际接收能力控制发送的数据量的机制。具体操作是接收端主机向发送店主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。该大小限度被称为<strong>窗口大小</strong>。</p><p>TCP首部中，专门有一个字段来通知窗口大小，<em><strong>这个字段的值越大，说明网络的吞吐量越高</strong></em>。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>一般来说，计算机网络都处在一个共享的环境，如果当其他主机之间的通信使得网络拥堵，此时如果突然发送大量的数据，极有可能导致网络瘫痪。</p><p>TCP为了防止此类问题的出现，通信一开始通过一个<strong>慢启动</strong>的算法，对发送数据量进行控制。</p><p>为了在发送端调节要发送的数据量，定义了一个<strong>拥塞窗口</strong>的概念。于是慢启动的时候，将这个拥塞窗口的大小设置为1个数据段发送数据，之后每收到一次ACK，拥塞窗口的值就加1。发送数据包时，将拥塞窗口的大小和接收端通知的窗口大小作比较，按照二者中的较小值，发送比其还要小的数据量。</p><blockquote><p>连续发包的情况也叫<strong>爆发（burst）</strong>，慢启动真是减少爆发等网络拥堵情况的一种机制。</p></blockquote><p>随着包的每次往返，拥塞窗口以指数函数增长，就有可能导致网络拥塞的发生，为了防止此类情况，引入<strong>慢启动阈值</strong>。只要拥塞窗口超过这个阈值，每次收到ACK时，只允许以如下比例放大拥塞窗口：$$\frac{1个数据段的字节数}{拥塞窗口(字节)}*1个数据段字节数$$</p><p>TCP通信开始时，并没有设置相应的慢启动阈值，而是在超时重发时，才会设置为当时拥塞窗口一半的大小。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/mobile-communication/">移动通信</category>
      
      
      <category domain="http://singlewang.top/tags/TCP/">TCP</category>
      
      <category domain="http://singlewang.top/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">拥塞控制</category>
      
      
      <comments>http://singlewang.top/2022/05/10/mobile-communication/TCP%E7%AA%97%E5%8F%A3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux驱动中的并发控制</title>
      <link>http://singlewang.top/2022/05/09/linux/linux-kernal/linux-kernal-driver/linux%E9%94%81/</link>
      <guid>http://singlewang.top/2022/05/09/linux/linux-kernal/linux-kernal-driver/linux%E9%94%81/</guid>
      <pubDate>Mon, 09 May 2022 12:20:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Linux驱动中的并发控制&quot;&gt;&lt;a href=&quot;#Linux驱动中的并发控制&quot; class=&quot;headerlink&quot; title=&quot;Linux驱动中的并发控制&quot;&gt;&lt;/a&gt;Linux驱动中的并发控制&lt;/h2&gt;&lt;h3 id=&quot;并发与竞态&quot;&gt;&lt;a href=&quot;#并发与竞</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Linux驱动中的并发控制"><a href="#Linux驱动中的并发控制" class="headerlink" title="Linux驱动中的并发控制"></a>Linux驱动中的并发控制</h2><h3 id="并发与竞态"><a href="#并发与竞态" class="headerlink" title="并发与竞态"></a>并发与竞态</h3><p><strong>并发</strong>指的是多个执行单元同时、并行被执行，而并发的执行单元对共享资源（硬件资源和软件上的全局变量、静态变量等）的访问很容易导致竞态。在linux内核中，主要的竞态发生于如下几种情况：</p><ol><li>对称多处理器(SMP)的多个CPU</li><li>单CPU内进程与抢占它的进程</li><li>中断(硬中断，软中断，Tasklet、底半部)与进程之间。</li></ol><p>解决竞态问题的途径是保证对共享资源的<strong>互斥访问</strong>，所谓<strong>互斥访问</strong>是指一个执行单元在访问共享资源的时候，其他的执行单元被禁止访问。</p><h3 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h3><p>在单CPU范围内避免竞态的一种简单方法是在进入临界区之前屏蔽系统的中断。中断屏蔽将使得中断与进程之间的并发不再发生。由于linux内核的进程调度等操作都依赖与中断实现，内核抢占进程之间的并发也就避免；<br>中断屏蔽的使用方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disable() <span class="comment">//屏蔽中断</span></span><br><span class="line"></span><br><span class="line">critical section <span class="comment">//临界区</span></span><br><span class="line"></span><br><span class="line">local_irq_enable()<span class="comment">//开中断</span></span><br></pre></td></tr></table></figure><p><code>local_irq_disable()</code>和<code>local_irq_enable()</code>都只能禁止和使能本CPU内的中断，并不能解决SMP多CPU引发的竞态。因此中断屏蔽一般与<strong>自旋锁</strong>联合使用。</p><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作指的是在执行过程中不会被别的代码路径所中断的操作。</p><p>Linux内核原子操作分为两类：</p><ol><li>针对位</li><li>针对整型</li></ol><h4 id="整型原子操作"><a href="#整型原子操作" class="headerlink" title="整型原子操作"></a>整型原子操作</h4><ol><li>设置原子变量的值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">atomic_set</span><span class="params">(<span class="type">atomic_t</span> *v <span class="type">int</span> i)</span>; <span class="comment">//设置原子变量的值为i；</span></span><br><span class="line"><span class="type">atomic_t</span> v = ATOMIC_INIT(<span class="number">0</span>); <span class="comment">//设置原子变量v并初始化为0；</span></span><br></pre></td></tr></table></figure></li><li>获取原子变量的值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_read</span>(<span class="type">atomic_t</span> *v); <span class="comment">//返回原子变量的值</span></span><br></pre></td></tr></table></figure></li><li>原子变量加&#x2F;减<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">atomic_add</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span> <span class="comment">//原子变量增加i</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">atomic_sub</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span> <span class="comment">//原子变量减少i</span></span><br></pre></td></tr></table></figure></li><li>原子变量自增&#x2F;自减<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">atomic_inc</span><span class="params">(<span class="type">atomic_t</span> *v)</span><span class="comment">//原子变量增加1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">atomic_dec</span><span class="params">(<span class="type">atomic_t</span> *v)</span><span class="comment">//原子变量减少1</span></span><br></pre></td></tr></table></figure></li><li>测试并操作<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atomic_inc_and_test</span><span class="params">(<span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_dec_and_test</span><span class="params">(<span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_sub_and_test</span><span class="params">(<span class="type">atomic_t</span> *v)</span>;</span><br></pre></td></tr></table></figure>上述操作对原子变量指向自增自减和减操作后测试其是否为0，为0则返回true。</li><li>操作并返回<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atomic_add_return</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_sub_return</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_inc_return</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_dec_return</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span>;</span><br></pre></td></tr></table></figure>上述对原子变量进行操作后返回新的值。</li></ol><h4 id="位原子操作"><a href="#位原子操作" class="headerlink" title="位原子操作"></a>位原子操作</h4><ol><li>设置位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span>;<span class="comment">//设置addr地址的第nr位，所谓设置位即将位写为1.</span></span><br></pre></td></tr></table></figure></li><li>清除位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clear_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span><span class="comment">//清除addr地址的第nr位即将位写为0</span></span><br></pre></td></tr></table></figure></li><li>改变位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span><span class="comment">//对addr地址的第nr位进行反置</span></span><br></pre></td></tr></table></figure></li><li>测试位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_bit(nr,<span class="type">void</span> *addr)<span class="comment">//返回addr地址的第nr位</span></span><br></pre></td></tr></table></figure></li><li>测试并操作位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test_and_set_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">test_and_clear_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">test_and_change_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span>;</span><br></pre></td></tr></table></figure>上述操作相当于先指向test_bit后再执行相关操作。</li></ol><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><h4 id="自旋锁的使用"><a href="#自旋锁的使用" class="headerlink" title="自旋锁的使用"></a>自旋锁的使用</h4><p><strong>自旋锁</strong>可以对临界资源进行互斥访问。为了获得一个自旋锁，在某CPU上运行的代码需先执行一个原子操作，该操作测试并设置某个内存变量。</p><ul><li>如果测试结果表明锁已经空闲，则程序获得这个自旋锁并继续执行；</li><li>如果测试结果表明锁被占用，程序将在一个小循环内重复 <strong>“测试并设置”</strong>，这就是所谓的<strong>自旋</strong>。</li></ul><p>linux系统中与自旋锁相关的操作有如下四种：</p><ol><li>定义自旋锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> spin;</span><br></pre></td></tr></table></figure></li><li>初始化自旋锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_init(lock);</span><br></pre></td></tr></table></figure></li><li>获得自旋锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spink_lock(lock);</span><br></pre></td></tr></table></figure>该宏用于获得自旋锁lock，如果能够立即获得，就马上返回，否则，将自旋在那儿，知道该自旋锁的保持者释放<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_try_lock(lock)</span><br></pre></td></tr></table></figure>该宏尝试获得自旋锁，如果能够获得，它获得锁并返回真，否则立即返回假，实际上不再“自旋”。</li><li>释放自旋锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_unlock(lock)</span><br></pre></td></tr></table></figure></li></ol><p>自旋锁一般如下使用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个自旋锁</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line">spin_lock_init(&amp;lock);</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock); <span class="comment">//获得自旋锁，保护临界区</span></span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock); <span class="comment">//解锁</span></span><br></pre></td></tr></table></figure><p>自旋锁主要针对SMP或单CPU但内核可抢占的情况，对于单CPU和内核不抢占的系统，自旋锁退化为空操作。</p><p>在使用自旋锁要注意如下几个问题：</p><ol><li>自旋锁实际上是忙等锁，只有在占用锁的时间极短的情况下，使用自旋锁才是合理的。否在将会降低系统的性能</li><li>自旋锁可能导致死锁，引发该问题最常见的情况是递归使用一个自旋锁。在自旋锁占用期间不嫩调用<code>copy_from_user()</code>,<code>copy_to_user()</code>,<code>kmalloc()</code>这些函数。</li></ol><h4 id="读写自旋锁"><a href="#读写自旋锁" class="headerlink" title="读写自旋锁"></a>读写自旋锁</h4><p>自旋锁的衍生锁<strong>读写自旋锁</strong>可允许读的并发，但是在写操作方面，只能最多有一个写进程。读和写不能同时进行。</p><ol><li><p>定义和初始化读写自旋锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rwlock_t</span> my_rwlock = RW_LOCK_UNLOCKED <span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">rwlock_t</span> my_rwlock;</span><br><span class="line">rwlock_init(&amp;my_rwlock)<span class="comment">//动态初始化</span></span><br></pre></td></tr></table></figure></li><li><p>读锁定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_lock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_lock_irqsave</span><span class="params">(<span class="type">rwlock_t</span> *lock,<span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_lock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_lock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure></li><li><p>读解锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_unlock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_unlock_irqsave</span><span class="params">(<span class="type">rwlock_t</span> *lock,<span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_unlock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_unlock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在读取共享资源之前，先调用读锁定函数，完成之后应调用读解锁函数。</p></blockquote></li><li><p>写锁定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_lock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_lock_irqsave</span><span class="params">(<span class="type">rwlock_t</span> *lock,<span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_lock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_lock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_trylock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure></li><li><p>写解锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_unlock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_unlock_irqsave</span><span class="params">(<span class="type">rwlock_t</span> *lock,<span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_unlock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_unlock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在对共享资源进行写之前，先调用写锁定函数，完成之后应调用写解锁函数。</p></blockquote></li></ol><p>读写锁使用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rwlock_t</span> lock;  <span class="comment">//定义rwlock</span></span><br><span class="line">rwlock_init(&amp;lock); <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">read_lock(&amp;lock);</span><br><span class="line">···<span class="comment">//临界资源</span></span><br><span class="line">read_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">write_lock_irqsave(&amp;lock,flags);</span><br><span class="line">···<span class="comment">//临界资源</span></span><br><span class="line">write_unlock_irqrestore(&amp;lock,flag);</span><br></pre></td></tr></table></figure><h4 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h4><p>顺序锁是读写锁的优化，锁使用顺序锁，读执行单元不会被写执行单元阻塞。如果读执行单元在读操作期间，写执行单元已经发送了写操作，那么读执行单元必须重新读取数据，以确保数据是完整的。</p><blockquote><p>相关操作日后待补充</p></blockquote><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量也是用来保护临界区的一种方法，只有得到信号量的进程才能执行临界区代码。<br>linux中信号量相关操作如下：</p><ol><li>定义信号量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span></span><br></pre></td></tr></table></figure></li><li>初始化信号量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem,<span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure>初始化信号量，并设置信号量的值为val;</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_MUTEX</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_MUTEX_LOCKED</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br></pre></td></tr></table></figure><p><code>init_MUTEX</code>初始化一个用于互斥的信号量，把信号量sem的值设置为1.<br><code>init_MUTEX_LOCKED</code>初始化一个信号量，把信号量sem的值设置为0.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_MUTEX(name)  <span class="comment">//宏，初始信号量为1</span></span><br><span class="line">DECLARE_MUTEX_LOCKED(name) <span class="comment">//宏，初始信号量为0</span></span><br></pre></td></tr></table></figure><ol start="3"><li>获得信号量</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;<span class="comment">//用于获得信号量，但是不能在中断上下文使用，会导致睡眠</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_interruptible</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;<span class="comment">//因为该函数进入睡眠的进程能被信号打断，而上面的不行。信号导致该函数返回值非0</span></span><br></pre></td></tr></table></figure><ol start="4"><li>释放信号量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="keyword">struct</span> semaphore * sem)</span>;<span class="comment">//释放信号量，唤醒等待者。</span></span><br></pre></td></tr></table></figure></li></ol><p>信号量使用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_MUTEX(mount_sem);<span class="comment">//定义</span></span><br><span class="line">down(&amp;mount_sem);<span class="comment">//获得信号量</span></span><br><span class="line"></span><br><span class="line">···<span class="comment">//临界区</span></span><br><span class="line">up(&amp;mount_Sem);<span class="comment">//释放信号量</span></span><br></pre></td></tr></table></figure><h4 id="完成量用于同步"><a href="#完成量用于同步" class="headerlink" title="完成量用于同步"></a>完成量用于同步</h4><p>***完成量(completion)***，用于一个执行单元等待另一个执行单元执行完某事。</p><p>linux中完成量操作有如下几种：</p><ol><li><p>定义完成量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">my_completion</span>;</span></span><br></pre></td></tr></table></figure></li><li><p>初始化完成量</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_completion(&amp;my_completion);</span><br></pre></td></tr></table></figure><p>也可通过如下宏实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_COMPLETION(my_completion);</span><br></pre></td></tr></table></figure><ol start="3"><li><p>等待完成量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_for_completion</span><span class="params">(<span class="keyword">struct</span> completion *c)</span>;<span class="comment">//等待一个完成量被唤醒</span></span><br></pre></td></tr></table></figure></li><li><p>唤醒完成量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">complete</span><span class="params">(<span class="keyword">struct</span> completion *c)</span>;  <span class="comment">//唤醒一个等待的执行单元</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">complete_all</span><span class="params">(<span class="keyword">struct</span> completion *c)</span>; <span class="comment">//释放所有等待统一完成量的执行单元</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>自旋锁和信号量选用的三项原则</strong></p><ul><li>使用信号量的开销是进程上下文切换时间Tsw，使用自旋锁的开销是等待获取自旋锁Tcs,若Tcs比较小，使用自旋锁，反之，使用信号量。</li><li>信号量保护的临界区可能包含引起阻塞的代码，而自旋锁绝对要避免用来保护这样的临界区</li><li>信号量存在于进程上下文，如果被保护的共享资源需要在中断或者软中断的情况下使用，则在二者之间只能选择自旋锁。</li></ul>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/linux-kernal-driver/">Linux内核驱动</category>
      
      
      <category domain="http://singlewang.top/tags/Linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/">Linux内核驱动</category>
      
      <category domain="http://singlewang.top/tags/Linux%E9%94%81/">Linux锁</category>
      
      <category domain="http://singlewang.top/tags/Linux%E5%B9%B6%E5%8F%91/">Linux并发</category>
      
      
      <comments>http://singlewang.top/2022/05/09/linux/linux-kernal/linux-kernal-driver/linux%E9%94%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>cpp之虚函数与多态</title>
      <link>http://singlewang.top/2022/05/05/cpp/cpp%E5%A4%9A%E6%80%81/</link>
      <guid>http://singlewang.top/2022/05/05/cpp/cpp%E5%A4%9A%E6%80%81/</guid>
      <pubDate>Thu, 05 May 2022 13:20:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h2&gt;&lt;p&gt;何为 &lt;em&gt;&lt;strong&gt;多态&lt;/strong&gt;&lt;/em&gt;,顾名思义是同一个事物在不同场景下的多种形态。&lt;br&gt;多态分类：&lt;/p&gt;
&lt;u</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>何为 <em><strong>多态</strong></em>,顾名思义是同一个事物在不同场景下的多种形态。<br>多态分类：</p><ul><li>静态多态(编译阶段)<ul><li>函数重载</li><li>泛型编程</li></ul></li><li>动态多态(运行阶段)<ul><li>虚函数</li></ul></li></ul><p><em><strong>为什么需要多态</strong></em><br>派生类对象的地址可以赋值给基类指针。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时并不确定要执行的是基类还是派生类的虚函数；而当程序运行到该语句时，如果基类指针指向的是一个基类对象，则基类的虚函数被调用，如果基类指针指向的是一个派生类对象，则派生类的虚函数被调用。这种机制就叫作 <strong>多态（polymorphism）</strong>。</p><h3 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h3><p>函数重载就是一个简单的静态多态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Add</span><span class="params">(<span class="type">double</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">//Add(10.0, 20.0);  //这是一个问题代码</span></span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">10.0</span>,<span class="number">20</span>);  <span class="comment">//正常代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>静态多态实在编译期间完成的，编译器会根据实参类型来调用合适的函数,如果有合适的函数就调用，如果没有就会发出警告或报错</em></p><h3 id="动态多态"><a href="#动态多态" class="headerlink" title="动态多态"></a>动态多态</h3><p>动态多态，看名字就知道和静态多态是相反的。<em>它是在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的&#x3D;&#x3D;虚函数&#x3D;&#x3D;</em></p><p><em><strong>动态多态的条件</strong></em></p><ul><li>基类中必须包含虚函数，并且派生类中一定要对基类中的虚函数进行重写</li><li>通过基类对象的指针或者引用调用虚函数。</li></ul><p>提到动态多态那么不得不提一嘴 <em><strong>虚函数</strong></em>。虚函数可以说对动态多态具有决定性的作用。有虚函数才能构成多态。使用虚函数的注意事项：</p><ol><li>只需要在虚函数的声明处加上 virtual 关键字，函数定义处可以加也可以不加。</li><li>可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽（覆盖）关系的同名函数都将自动成为虚函数。</li><li>当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。</li><li>只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）。</li><li>构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。</li><li>析构函数可以声明为虚函数，而且有时候必须要声明为虚函数。</li></ol><p><em><strong>那么虚函数的作用是什么呢？</strong></em></p><ol><li>定义子类对象，并调用对象中未被子类覆盖的基类函数A。同时在该函数A中，又调用了已被子类覆盖的基类函数B。那此时将会调用基类中的函数B，可我们本应该调用的是子类中的覆盖函数B。虚函数即能解决这个问题。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类 Father</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Father::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在函数中调用了，子类覆盖基类的函数display()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fatherShowDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Son</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重写基类中的display()函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Son::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son son;                    <span class="comment">// 子类对象</span></span><br><span class="line">    son.<span class="built_in">fatherShowDisplay</span>();    <span class="comment">// 通过基类中未被覆盖的函数，想调用子类中覆盖的display函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父类中的<code>display()</code>不是虚函数，则执行结果为<code>Father::display()</code>。反之，执行结果为<code>Son::display()</code>。</p><ol start="2"><li>在使用指向子类对象的基类指针，并调用子类中的覆盖函数时，如果该函数不是虚函数，那么将调用基类中的该函数；如果该函数是虚函数，则会调用子类中的该函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类 Father</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义了虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Father::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Son</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 覆盖基类中的display函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Son::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Father *fp;     <span class="comment">// 定义基类指针</span></span><br><span class="line">    Son son;        <span class="comment">// 子类对象</span></span><br><span class="line">    fp=&amp;son;        <span class="comment">// 使基类指针指向子类对象</span></span><br><span class="line">    fp-&gt;<span class="built_in">display</span>();  <span class="comment">// 通过基类指针想调用子类中覆盖的display函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父类中的<code>display()</code>不是虚函数，则执行结果为<code>Father::display()</code>。反之，执行结果为<code>Son::display()</code>。</p><blockquote><p>哪些函数不能定义为虚函数？（面试题）</p><ol><li>友元函数，它不是类的成员函数</li><li>全局函数</li><li>静态成员函数，它没有this指针</li><li>构造函数，拷贝构造函数，以及赋值运算符重载。</li></ol></blockquote><p><em><strong>纯虚函数和抽象类</strong></em><br><strong>纯虚函数</strong>:没有函数体的虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">( )</span> </span>= <span class="number">0</span> ; <span class="comment">//纯虚函数</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>包含纯虚函数的类叫做<strong>抽象类</strong></p><ul><li>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象</li><li>抽象类的指针和引用可以指向抽象类派生出来的类的对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;         <span class="comment">// 错，A 是抽象类，不能创建对象</span></span><br><span class="line">A * pa ;     <span class="comment">// ok,可以定义抽象类的指针和引用</span></span><br><span class="line">pa = <span class="keyword">new</span> A ; <span class="comment">// 错误, A 是抽象类，不能创建对象</span></span><br></pre></td></tr></table></figure><h3 id="多态的表现形式"><a href="#多态的表现形式" class="headerlink" title="多态的表现形式"></a>多态的表现形式</h3><p><em><strong>多态的表现形式一</strong></em></p><ul><li>&#x3D;&#x3D;派生类的指针&#x3D;&#x3D;可以赋给&#x3D;&#x3D;基类指针&#x3D;&#x3D;</li><li>通过基类指针调用基类和派生类中的同名&#x3D;&#x3D;虚函数时&#x3D;&#x3D;：</li></ul><ol><li>若该指针指向一个基类的对象，那么调用是基类的虚函数；</li><li>若该指针指向一个派生类的对象，那么调用的是派生类的虚函数。</li></ol><blockquote><p>调用哪个虚函数，取决于指针对象指向哪种类型的对象。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFather</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123; &#125; <span class="comment">// 虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSon</span> : <span class="keyword">public</span> CFather </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CSon son;</span><br><span class="line">    CFather *p = &amp;son;</span><br><span class="line">    p-&gt;<span class="built_in">Fun</span>(); <span class="comment">//调用哪个虚函数取决于 p 指向哪种类型的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针<code>p</code>指向的是<code>CSon</code>类对象，所以<code>p-&gt;Fun()</code>调用的是<code>CSon</code>类的<code>Fun</code>。</p><p><em><strong>多态的表现形式二</strong></em></p><ul><li>派生类的对象可以付给基类&#x3D;&#x3D;引用&#x3D;&#x3D;</li><li>通过基类引用调用基类和派生类中的同名&#x3D;&#x3D;虚函数&#x3D;&#x3D;时：</li></ul><ol><li>若该引用引用的是一个基类的对象，那么被调用的是基类的虚函数</li><li>若该引用引用的是派生类的对象，那么被调用的是派生类的虚函数。</li></ol><blockquote><p>调用哪个虚函数，取决于引用的对象是哪种类型的对象</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFather</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123; &#125; <span class="comment">// 虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSon</span> : <span class="keyword">public</span> CFather </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CSon son;</span><br><span class="line">    CFather &amp;r = son;</span><br><span class="line">    r.<span class="built_in">Fun</span>(); <span class="comment">//调用哪个虚函数取决于 r 引用哪种类型的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>r</code>引用的是<code>CSon</code>类对象，所以<code>r.Fun()</code>调用的是<code>CSon</code>类的<code>Fun</code>。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/CPP/">CPP</category>
      
      
      <category domain="http://singlewang.top/tags/cpp/">cpp</category>
      
      <category domain="http://singlewang.top/tags/%E5%A4%9A%E6%80%81/">多态</category>
      
      <category domain="http://singlewang.top/tags/%E8%99%9A%E5%87%BD%E6%95%B0/">虚函数</category>
      
      
      <comments>http://singlewang.top/2022/05/05/cpp/cpp%E5%A4%9A%E6%80%81/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
