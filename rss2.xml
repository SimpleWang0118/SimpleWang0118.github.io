<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Single Wang&#39;s Blog</title>
    <link>http://singlewang.top/</link>
    
    <atom:link href="http://singlewang.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>智者不入爱河，愚者重蹈覆辙</description>
    <pubDate>Mon, 16 May 2022 12:30:31 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Linux网络设备驱动</title>
      <link>http://singlewang.top/2022/05/11/linux/linux-kernal/linux-kernal-driver/linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</link>
      <guid>http://singlewang.top/2022/05/11/linux/linux-kernal/linux-kernal-driver/linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</guid>
      <pubDate>Wed, 11 May 2022 11:57:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;linux网络设备驱动&quot;&gt;&lt;a href=&quot;#linux网络设备驱动&quot; class=&quot;headerlink&quot; title=&quot;linux网络设备驱动&quot;&gt;&lt;/a&gt;linux网络设备驱动&lt;/h2&gt;&lt;h3 id=&quot;linux网络设备驱动的体系结构&quot;&gt;&lt;a href=&quot;#l</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="linux网络设备驱动"><a href="#linux网络设备驱动" class="headerlink" title="linux网络设备驱动"></a>linux网络设备驱动</h2><h3 id="linux网络设备驱动的体系结构"><a href="#linux网络设备驱动的体系结构" class="headerlink" title="linux网络设备驱动的体系结构"></a>linux网络设备驱动的体系结构</h3><p>linux网络设备体系结构从上往下分为4层，依次为网络协议接口层、网络设备接口层、提供实际功能的设备驱动功能层以及网路设备与媒介层。四层作用如下：</p><ol><li><strong>网络协议接口层</strong>向网络层协议提供统一的数据包发送接口，通过<code>dev_queue_xmit()</code>发送数据，通过<code>netif_rx()</code>接收数据。</li><li><strong>网络设备接口层</strong>向协议接口层提供统一的用于描述网络设备属性和操作的结构体<code>net_device</code>。</li><li><strong>设备驱动功能层</strong>个函数是网络接口层<code>net_device</code>数据结构的成员，通过<code>hard_start_xmit()</code>函数启动发送操作，并通过网络设备上的中断触发接收操作。</li><li><strong>网络设备与媒介层</strong>是完成数据包发送和接收的物理实体。对于Linux系统而言，网络设备和媒介都可以是虚拟的。</li></ol><h4 id="网络协议接口层"><a href="#网络协议接口层" class="headerlink" title="网络协议接口层"></a>网络协议接口层</h4><p>网络协议接口层最主要的功能是给上层协议提供了透明的数据包发送和接收接口。<br><code>dev_queue_xmit()</code>的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev_queue_xmit(<span class="keyword">struct</span> sk_buff *skb);</span><br></pre></td></tr></table></figure><p><code>netif_rx()</code>的函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">netif_rx</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><code>sk_buff</code>结构提非常重要，含义为<strong>套接字缓冲区</strong>，用于在Linux网路子系统中的各层之间传送数据。</p></blockquote><ol><li>套接字缓冲区成员<br>（1）各层协议头<code>h</code>、<code>nh</code>、<code>mac</code><br>传输层协议头<code>h</code>，网络层协议头<code>nh</code>，链路层协议头<code>mac</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udphdr</span> *<span class="title">uh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmphdr</span> *<span class="title">icmph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">igmphdr</span> *<span class="title">igmph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span>   * <span class="title">iph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipv6hdr</span> *<span class="title">ipv6h</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *raw; <span class="comment">//数据链路层头部 </span></span><br><span class="line">&#125;h;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipv6hdr</span> *<span class="title">ipv6h</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arphdr</span> *<span class="title">arph</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *raw;<span class="comment">//数据链路层头部</span></span><br><span class="line">&#125;nh;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *raw;</span><br><span class="line">&#125;mac;</span><br></pre></td></tr></table></figure></li></ol><p>(2)数据缓冲区指针<code>head、data、tail、end</code></p><ul><li><code>head</code>指针指向内存中已分配的用于承载网络数据缓冲区的起始地址。</li><li><code>data</code>指针指向对应当前协议层有效数据的起始地址</li><li><code>tail</code>指针指向对应当前协议层有效数据负载的结尾地址。</li><li><code>end</code>指针指向内存中分配的主机缓冲区的结尾</li></ul><p>(3)长度信息<code>len、data_len、truesize</code></p><ul><li><code>len</code>指数据包有效长度，包括协议头和负载(payload)</li><li><code>data_len</code>记录分片的数据长度</li><li><code>truesize</code>表示缓存区的整体长度。</li></ul><ol start="2"><li>套接字缓冲区操作</li></ol><p>(1)分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">alloc_skb</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> len,<span class="type">int</span> priority)</span>;<span class="comment">//priority为内存分配的优先级</span></span><br><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">dev_alloc_skb</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure><p>分配成功后，<code>sk_buff</code>的<code>data</code>，<code>tail</code>指针都指向存储空间的起始地址<code>head</code>。<code>len</code>的大小为0。</p><p>(2)释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_kfree_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_kfree_skb_irq</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dev_kfree_skb_any</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br></pre></td></tr></table></figure><p>上述函数用于释放分配的套接字缓冲区和数据缓冲区。linux内核使用<code>kfree_skb()</code>,网络设备驱动程序中必须使用其他三个。<code>dev_kfree_skb()</code>用于非中断上下文，<code>dev_kfree_skb_irq()</code>用于中断上下文，any均可采用。<br>(3)指针移动</p><ul><li>put操作<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_put</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len)</span>; <span class="comment">//会对数据进行检查</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *__skb_put(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len); <span class="comment">//不会对数据进行检查</span></span><br></pre></td></tr></table></figure></li></ul><p>上述函数将<code>tail</code>指针下移，增加<code>sk_buff</code>的<code>len</code>，并返回<code>skb-&gt;tail</code>的当前值。主要用于在缓冲区尾部添加数据。</p><ul><li><p>push操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_push</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *__skb_push(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len);</span><br></pre></td></tr></table></figure><p>主要用于在数据包发送给是添加头部。</p></li><li><p>pull操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_pull</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure><p>此函数将<code>data</code>指针下移，减小<code>len</code>的值，一般用于下层协议向上层协议移交数据包，使<code>data</code>指针指向上层协议的协议头</p></li><li><p>reserve操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skb_reserve</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,<span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure><p>主要用于在存储空间的头部预留<code>len</code>长度的空隙。</p></li></ul><h4 id="网络设备接口层"><a href="#网络设备接口层" class="headerlink" title="网络设备接口层"></a>网络设备接口层</h4><p><code>net_device</code>结构体在内核中指代一个网络设备，只需通过填充<code>net_device</code>的具体成员并注册即可实现硬件操作函数与内核的挂接</p><ol><li><p>全局信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[IFNAMESIZE];</span><br><span class="line"><span class="type">int</span> (*init)(<span class="keyword">struct</span> net_device *dev);</span><br></pre></td></tr></table></figure><p><code>name</code>是网络设备的名称。<code>init</code>为设备初始化函数指针，如果这个指针被设置了，则网络设备被注册时将调用该函数完成对<code>net_device</code>结构体的初始化。</p></li><li><p>硬件信息</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mem_end;<span class="comment">//共享内存的结束地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mem_start;<span class="comment">//共享内存的起始地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> base_addr;<span class="comment">//网络设备I/O基地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> irq;<span class="comment">//中断号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> if_port;<span class="comment">//使用的端口</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dma;<span class="comment">//分配给设备的DMA通道</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>接口信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> hard_header_len;<span class="comment">//网络设备的硬件头长度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> type<span class="comment">//接口的硬件类型</span></span><br><span class="line"><span class="type">unsigned</span> mtu; <span class="comment">//最大传输单元</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dev_addr[MAX_ADDR_LEN];<span class="comment">//存放硬件地址，需由驱动程序从硬件上读出并填充到dev_addr[]中。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> broadcast[MAX_ADDR_LEN];<span class="comment">//存放广播地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> flags;<span class="comment">//网络接口标志</span></span><br></pre></td></tr></table></figure></li><li><p>设备操作函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*open)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//打开网络接口设备</span></span><br><span class="line"><span class="type">int</span> (*stop)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//停止网络接口设备</span></span><br><span class="line"><span class="type">int</span> (*hard_start_xmit)(<span class="keyword">struct</span> sk_buff *skb,<span class="keyword">struct</span> net_device *dev);<span class="comment">//启动数据包的发送</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_dev_stats</span>* (*<span class="title">get_stats</span>)(<span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>);</span><span class="comment">//用于获得网络设备的状态信息，net_dev_stats保存了网络设备的详细的流量信息，如发送和接收到的数据包数、字节数等</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="设备驱动功能层。"><a href="#设备驱动功能层。" class="headerlink" title="设备驱动功能层。"></a>设备驱动功能层。</h4><p><code>net_device</code>结构体的成员需要被设备驱动功能层的具体数值和函数赋予，驱动开发主要就是在这一层进行。</p><h4 id="网络设备与媒介层"><a href="#网络设备与媒介层" class="headerlink" title="网络设备与媒介层"></a>网络设备与媒介层</h4><p>网络设备与媒介层直接对应于与实际的硬件设备。</p><h3 id="网络设备驱动的注册与注销"><a href="#网络设备驱动的注册与注销" class="headerlink" title="网络设备驱动的注册与注销"></a>网络设备驱动的注册与注销</h3><p>网络设备驱动的注册于注销分别使用<code>register_netdev()</code>和<code>unregister_netdev()</code>完成，这两个函数的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_netdev</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_netdev</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure><p><code>net_device</code>的成员可以里用下面的函数帮助我们填充</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> net_device *<span class="title function_">alloc_netdev</span><span class="params">(<span class="type">int</span> sizeof_priv,<span class="type">const</span> <span class="type">char</span> *name,<span class="type">void</span>(*setup)(<span class="keyword">struct</span> net_device*))</span>;</span><br><span class="line"><span class="keyword">struct</span> net_device *<span class="title function_">alloc_etherdev</span><span class="params">(<span class="type">int</span> sizeof_priv)</span>;</span><br></pre></td></tr></table></figure><p>释放net_device结构体的函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free_netdev(<span class="keyword">struct</span> net_device *dev);</span><br></pre></td></tr></table></figure><p><code>net_device</code>结构体的分配和网络设备驱动注册需在网络设备驱动程序的模块加载函数中进行，而<code>net_device</code>结构体的释放和网络设备驱动的注销需要在模块卸载函数中完成。</p><h3 id="网络设备的初始化"><a href="#网络设备的初始化" class="headerlink" title="网络设备的初始化"></a>网络设备的初始化</h3><p>网络设备的初始化主要需要完成如下几个方面的工作：</p><ul><li>进行硬件上的准备工作，检查网络设备是否存在。</li><li>进行软件接口上的准备工作，分配net_device结构体并对其数据和函数指针成员赋值</li><li>获得设备的私有信息指针并初始化其成员的值。如果私有信息中包括自旋锁或信号量等并发或同步机制，则需对其进行初始化。</li></ul><h3 id="网络设备的打开与释放"><a href="#网络设备的打开与释放" class="headerlink" title="网络设备的打开与释放"></a>网络设备的打开与释放</h3><p>网络设备的打开函数需要完成如下工作：</p><ul><li>使能设备使用的硬件资源，申请I&#x2F;O区域、中断和DMA通道等。</li><li>调用Linux内核提供的<code>netif_start_queue()</code>函数，激活设备发送队列。</li></ul><p>网络设备的关闭函数需要完成如下工作：</p><ul><li>调用Linux内核提供的<code>netif_stop_queue()</code>函数，停止设备传输包</li><li>释放设备所使用的I&#x2F;O区域、中断和DMA资源。</li></ul><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_start_queue</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">netif_stop_queue</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;</span><br></pre></td></tr></table></figure><h3 id="数据发送流程"><a href="#数据发送流程" class="headerlink" title="数据发送流程"></a>数据发送流程</h3><p>网络设备驱动完成数据包发送的流程如下：</p><ol><li>网络设备驱动程序从上层协议传递过来的<code>sk_buff</code>参数获得数据包的有效数据和长度，将有效数据放入临时缓冲区。</li><li>对于以太网，如果有效数据的长度小于以太网冲突检测锁要求数据帧的最小长度<code>ETH_ZLEN</code>,则给临时缓冲区的末尾填充0。</li><li>设置硬件的寄存器，驱使网络设备进行数据发送操作。</li></ol><p>数据包发送函数模板：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">xxx_tx</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,<span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> *data,shortpkt[ETH_ZLEN];</span><br><span class="line"></span><br><span class="line">    data = skb-&gt;data;</span><br><span class="line">    len = skb-&gt;len;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;ETH_ZLEN)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(shortpkt,<span class="number">0</span>,ETH_ZLEN);</span><br><span class="line">        <span class="built_in">memcpy</span>(shortpkt,skb-&gt;data,skb-&gt;len);</span><br><span class="line">        len=ETH_ZLEN;</span><br><span class="line">        data = shortpkt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev-&gt;trans_start = jiffies;<span class="comment">//记录发送时间戳</span></span><br><span class="line"></span><br><span class="line">    xxx_hw_tx(data,len,dev);<span class="comment">//设置硬件寄存器让硬件把数据包发送出去。</span></span><br><span class="line">    ···;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数据传输超时时，数据包发送超时处理函数<code>xxx_tx_timeout()</code>将被调用。这个函数需要Linux内核提供的<code>netif_wake_queue</code>函数重新启动设备发送队列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">xxx_tx_timeout</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ···</span><br><span class="line">    netif_wake_queue(dev);<span class="comment">//重新启动设备发送队列。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据接收流程"><a href="#数据接收流程" class="headerlink" title="数据接收流程"></a>数据接收流程</h3><p>网络设备接收数据的主要方法是由中断引发设备的中断处理函数，中断处理函数判断中断类型，如果为接收中断，则读取接收到的数据，分配<code>sk_buffer</code>数据结构和数据缓冲区，将接收到的数据复制到数据缓冲区，并调用<code>netif_rx()</code>函数将sk_buffer传递给上层协议。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">xxx_interrupt</span><span class="params">(<span class="type">int</span> irq,<span class="type">void</span> *dev_id)</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/linux-kernal-driver/">Linux内核驱动</category>
      
      
      <category domain="http://singlewang.top/tags/Linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/">Linux网络设备</category>
      
      <category domain="http://singlewang.top/tags/Linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/">Linux内核驱动</category>
      
      
      <comments>http://singlewang.top/2022/05/11/linux/linux-kernal/linux-kernal-driver/linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Markdown公式编辑</title>
      <link>http://singlewang.top/2022/05/11/markdown/markdown-base/markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/</link>
      <guid>http://singlewang.top/2022/05/11/markdown/markdown-base/markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/</guid>
      <pubDate>Wed, 11 May 2022 09:43:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;公式编辑&quot;&gt;&lt;a href=&quot;#公式编辑&quot; class=&quot;headerlink&quot; title=&quot;公式编辑&quot;&gt;&lt;/a&gt;公式编辑&lt;/h3&gt;&lt;p&gt;一般公式分为两种形式，&lt;strong&gt;行内公式&lt;/strong&gt;和&lt;strong&gt;行间公式&lt;/strong&gt;&lt;/p&gt;
&lt;ul</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="公式编辑"><a href="#公式编辑" class="headerlink" title="公式编辑"></a>公式编辑</h3><p>一般公式分为两种形式，<strong>行内公式</strong>和<strong>行间公式</strong></p><ul><li>行内公式：$\Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt,. $</li><li>行间公式：$$\Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt,.$$</li></ul><p>行内公式实在公式代码块的基础上前面加上$,后面加上$组成的eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,. $</span><br></pre></td></tr></table></figure><p>行间公式在前后加上$$。eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,.$$</span><br></pre></td></tr></table></figure><h4 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h4><table><thead><tr><th align="center">名称</th><th align="center">大写</th><th align="center">code</th><th align="center">小写</th><th align="center">code</th></tr></thead><tbody><tr><td align="center">alpha</td><td align="center">A</td><td align="center">A</td><td align="center">α</td><td align="center">\alpha</td></tr><tr><td align="center">beta</td><td align="center">B</td><td align="center">B</td><td align="center">β</td><td align="center">\beta</td></tr><tr><td align="center">gamma</td><td align="center">Γ</td><td align="center">\Gamma</td><td align="center">γ</td><td align="center">\gamma</td></tr><tr><td align="center">delta</td><td align="center">Δ</td><td align="center">\Delta</td><td align="center">δ</td><td align="center">\delta</td></tr><tr><td align="center">theta</td><td align="center">Θ</td><td align="center">\Theta</td><td align="center">θ</td><td align="center">\theta</td></tr><tr><td align="center">lambda</td><td align="center">Λ</td><td align="center">\Lambda</td><td align="center">λ</td><td align="center">\lambda</td></tr><tr><td align="center">sigma</td><td align="center">Σ</td><td align="center">\Sigma</td><td align="center">σ</td><td align="center">\sigma</td></tr><tr><td align="center">omega</td><td align="center">Ω</td><td align="center">\Omega</td><td align="center">ω</td><td align="center">\omega</td></tr></tbody></table><h4 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h4><p>上标<code>^</code>,下标<code>_</code>,例如<code>$x_i^2$</code>表示的是：$x_i^2$。<br>默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用<code>&#123;..&#125;</code>包裹起来的内容。</p><h4 id="小括号与方括号"><a href="#小括号与方括号" class="headerlink" title="小括号与方括号"></a>小括号与方括号</h4><p>使用原始的( ) ，[ ] 即可，如<code>$(2+3)[4+4]$ </code>:$(2+3)[4+4]$<br>使用\left(或\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如<code>$\left(\frac&#123;x&#125;&#123;y&#125;\right)$ </code>：$\left(\frac{x}{y}\right)$</p><h4 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h4><p>由于大括号{} 被用于分组，因此需要使用<code>\&#123;</code>和<code>\&#125;</code>表示大括号，也可以使用<code>\lbrace </code>和<code>\rbrace</code>来表示。如<code>$\&#123;a\*b\&#125;:a\∗b$ </code>或<code>$\lbrace a\*b\rbrace :a\*b$</code></p><h4 id="尖括号"><a href="#尖括号" class="headerlink" title="尖括号"></a>尖括号</h4><p>区分于小于号和大于号，使用<code>\langle</code> 和<code>\rangle</code> 表示左尖括号和右尖括号。如<code>$\langle x \rangle$</code> 表示：$\langle x \rangle$。</p><h4 id="上取整"><a href="#上取整" class="headerlink" title="上取整"></a>上取整</h4><p>使用<code>\lceil</code> 和 <code>\rceil</code> 表示。 如，<code>$\lceil x \rceil$</code>：$\lceil x \rceil$</p><h4 id="下取整"><a href="#下取整" class="headerlink" title="下取整"></a>下取整</h4><p>使用<code>\lfloor</code> 和 <code>\rfloor</code> 表示。如，<code>$\lfloor x \rfloor$</code>：$\lfloor x \rfloor$</p><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><p><code>\sum</code> 用来表示求和符号，其下标表示求和下限，上标表示上限。如:<br><code>$\sum_&#123;r=1&#125;^n$</code>表示：$\sum_{r&#x3D;1}^n$。</p><h4 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h4><p><code>\int</code> 用来表示积分符号，同样地，其上下标表示积分的上下限。如，<code>$\int_&#123;r=1&#125;^\infty$</code>：$\int_{r&#x3D;1}^\infty$。<br>多重积分同样使用 int ，通过 i 的数量表示积分导数：<br><code>$\iint$</code> ：$\iint$<br><code>$\iiint$</code> ：$\iiint$</p><h4 id="连乘"><a href="#连乘" class="headerlink" title="连乘"></a>连乘</h4><p><code>$\prod &#123;a+b&#125;$</code>，输出：$\prod {a+b}$。<br><code>$\prod_&#123;i=1&#125;^&#123;K&#125;$</code>，输出：$\prod_{i&#x3D;1}^{K}$。<br><code>$$\prod_&#123;i=1&#125;^&#123;K&#125;$$</code>，输出：$$\prod_{i&#x3D;1}^{K}$$</p><h4 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h4><ul><li>第一种，使用<code>\frac ab</code>，<code>\frac</code>作用于其后的两个组<code>a </code>，<code>b</code> ，结果为$\frac ab$。如果你的分子或分母不是单个字符，请使用{..}来分组，比如<code>$\frac &#123;a+c+1&#125;&#123;b+c+2&#125;$</code>表示$\frac {a+c+1}{b+c+2}$。</li><li>第二种，使用<code>\over</code>来分隔一个组的前后两部分，如<code>$&#123;a+1\over b+1&#125;$</code>：${a+1\over b+1}$。</li></ul><h4 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h4><p>根式使用<code>\sqrt</code> 来表示。<br>如开4次方：<code>$\sqrt[4]&#123;\frac xy&#125;$</code> ：$\sqrt[4]{\frac xy}$。<br>开平方：<code>$\sqrt &#123;a+b&#125;$</code>：$\sqrt {a+b}$。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/markdown/">Markdown</category>
      
      <category domain="http://singlewang.top/categories/markdown/markdown-base/">Markdown基础</category>
      
      
      <category domain="http://singlewang.top/tags/%E6%95%99%E7%A8%8B/">教程</category>
      
      <category domain="http://singlewang.top/tags/Markdown%E5%85%AC%E5%BC%8F/">Markdown公式</category>
      
      
      <comments>http://singlewang.top/2022/05/11/markdown/markdown-base/markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TCP窗口与拥塞控制</title>
      <link>http://singlewang.top/2022/05/10/mobile-communication/TCP%E7%AA%97%E5%8F%A3/</link>
      <guid>http://singlewang.top/2022/05/10/mobile-communication/TCP%E7%AA%97%E5%8F%A3/</guid>
      <pubDate>Tue, 10 May 2022 11:47:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;TCP的特点及其目的&quot;&gt;&lt;a href=&quot;#TCP的特点及其目的&quot; class=&quot;headerlink&quot; title=&quot;TCP的特点及其目的&quot;&gt;&lt;/a&gt;TCP的特点及其目的&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;TCP&lt;/strong&gt;和&lt;strong&gt;UDP&lt;/stro</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="TCP的特点及其目的"><a href="#TCP的特点及其目的" class="headerlink" title="TCP的特点及其目的"></a>TCP的特点及其目的</h3><p><strong>TCP</strong>和<strong>UDP</strong>协议都位于传输层中，TCP主要提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p><p><em>TCP是面向连接的可靠的流协议，流就是指不简短的数据结构。采用TCP发送消息时，虽然可以保证发送的顺序，但是还是犹如没有任何间隔的数据流发送给接收端</em></p><blockquote><p><strong>连接</strong>是指各种设备，线路，或网络中进行通信的两个应用程序为了相互传递消息而转悠的、虚拟的通信线路，也叫虚拟电路。</p></blockquote><p>TCP为提供可靠性传输，实行“顺序控制”或“重传控制”机制。此外还有“流控制”，“拥塞控制”等众多功能。</p><h3 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h3><p>在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知，这个消息叫做<strong>确认应答（ACK）</strong>,如果有确认应答，说明数据已经成功到达对端，反之，则数据丢失的可能性很大，倘若在一段时间内没有ACK,则发送端进行数据的重发。</p><p>未收到ACK,有如下几种情况：</p><ol><li>发出去的数据包丢失</li><li>接收端发回来的ACK在途中丢失。</li></ol><p>虽然在发送端可以按照机制重传，但是对于接收端会重复收到相同的数据，为了对上层应用提供可靠的传输，必须放弃重复的数据包。需要引入一种机制识别是否已经接收数据，判断是否需要接收。</p><p>使用<strong>序列号</strong>解决上述问题。</p><p>序列号时按顺序发送给数据的每一个字节都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序号作为ACK返回，这样就可以是心啊可靠传输。</p><h3 id="重发超时如何确定"><a href="#重发超时如何确定" class="headerlink" title="重发超时如何确定"></a>重发超时如何确定</h3><p><strong>重发超时</strong>指在重发数据之前，等待ACK的那个特定时间间隔，如果超过了这个时间还未收到ACK，发送端就进行数据重发。</p><p>最理想的时间是，找一个最小时间，能保证 <em><strong>确认应答一定能在这个时间内返回</strong></em>。但是TCP要求在任何网络环境下都要提供高性能通信，无论网络拥塞情况如何，都要保持这一特性。因此每次发包时都会计算<strong>往返时间（RTT）</strong>及其偏差，将这个RTT和偏差相加，重发超时的时间就是比这个总和稍微大一点的值。</p><p>在linux系统中，一般以0.5秒为单位进行控制。最初的数据包的重发超时一般设置为6s。<br>数据被重发之后还是收不到ACK，则进行再次重发，但是等待的时间以2倍，4倍指数函数进行增长。达到一定次数后，如果仍然欸有收到ACK，则通知应用通信异常，强行关闭。</p><h3 id="TCP以段为单位发送数据"><a href="#TCP以段为单位发送数据" class="headerlink" title="TCP以段为单位发送数据"></a>TCP以段为单位发送数据</h3><p>建立TCP连接的同时，可以确定发送数据包的单位，称其为<strong>最大消息长度</strong>(MSS)。最理想的情况时最大消息长度正好是IP中不会被分片处理的最大数据长度。</p><p>MSS实在三次握手的时候，在两端主机之间被计算得出。两端主机在建立连接的时候，在TCP首部写入MSS选项，告诉对方自己的接口能适应的MSS的大小，然后选一个较小的值使用。</p><h3 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h3><p>TCP以段为单位，每发一个段进行一次ACK的处理。但是这样一来，包的往返时间越长通信性能就越低。</p><p>于是乎，TCP引入<strong>窗口</strong>这个概念，即发送端主机，发送了一个段后不必一直等待ACK,而是继续发送。<br><strong>窗口大小</strong>就是指无需等待确认应答就可以继续阿松数据的最大值。这个机制实现使用了大量的<strong>缓冲区</strong>。<br>在窗口内的数据即便没有收到确认应答也可以发送出去。而在滑动窗口以外的部分包括尚未发送的数据以及已经确认对端已收到的数据。当数据发出后若收到确认则不必重发，此时数据就可以从缓冲区清除。<br>这种机制也被称为 <strong>滑动窗口控制</strong>。</p><h3 id="窗口控制与重发控制"><a href="#窗口控制与重发控制" class="headerlink" title="窗口控制与重发控制"></a>窗口控制与重发控制</h3><p>窗口控制时，若出现段丢失该怎么办？</p><ol><li><p><strong>确认应答未能返回的情况</strong><br>这种情况下，数据已经到达对端，不需要进行重发，窗口在一定程度上较大时，即使有少部分的确认应答丢失也不会进行数据重发。可以通过下一个确认应答进行确认。</p></li><li><p><strong>报文段丢失的情况</strong><br>当某一报文段丢失后，发送段会一直收到某个序号的ACK，同一个序号的ACK会被重复不断地返回。而发送端主机如果连续三次收到同一个ACK，就会将其对应的数据进行重发。这种机制被称为 <strong>高速重发控制</strong></p></li></ol><h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><p><strong>流控制</strong>是一种可以让发送端根据接收端的实际接收能力控制发送的数据量的机制。具体操作是接收端主机向发送店主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。该大小限度被称为<strong>窗口大小</strong>。</p><p>TCP首部中，专门有一个字段来通知窗口大小，<em><strong>这个字段的值越大，说明网络的吞吐量越高</strong></em>。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>一般来说，计算机网络都处在一个共享的环境，如果当其他主机之间的通信使得网络拥堵，此时如果突然发送大量的数据，极有可能导致网络瘫痪。</p><p>TCP为了防止此类问题的出现，通信一开始通过一个<strong>慢启动</strong>的算法，对发送数据量进行控制。</p><p>为了在发送端调节要发送的数据量，定义了一个<strong>拥塞窗口</strong>的概念。于是慢启动的时候，将这个拥塞窗口的大小设置为1个数据段发送数据，之后每收到一次ACK，拥塞窗口的值就加1。发送数据包时，将拥塞窗口的大小和接收端通知的窗口大小作比较，按照二者中的较小值，发送比其还要小的数据量。</p><blockquote><p>连续发包的情况也叫<strong>爆发（burst）</strong>，慢启动真是减少爆发等网络拥堵情况的一种机制。</p></blockquote><p>随着包的每次往返，拥塞窗口以指数函数增长，就有可能导致网络拥塞的发生，为了防止此类情况，引入<strong>慢启动阈值</strong>。只要拥塞窗口超过这个阈值，每次收到ACK时，只允许以如下比例放大拥塞窗口：$$\frac{1个数据段的字节数}{拥塞窗口(字节)}*1个数据段字节数$$</p><p>TCP通信开始时，并没有设置相应的慢启动阈值，而是在超时重发时，才会设置为当时拥塞窗口一半的大小。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/mobile-communication/">移动通信</category>
      
      
      <category domain="http://singlewang.top/tags/TCP/">TCP</category>
      
      <category domain="http://singlewang.top/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">拥塞控制</category>
      
      
      <comments>http://singlewang.top/2022/05/10/mobile-communication/TCP%E7%AA%97%E5%8F%A3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux驱动中的并发控制</title>
      <link>http://singlewang.top/2022/05/09/linux/linux-kernal/linux-kernal-driver/linux%E9%94%81/</link>
      <guid>http://singlewang.top/2022/05/09/linux/linux-kernal/linux-kernal-driver/linux%E9%94%81/</guid>
      <pubDate>Mon, 09 May 2022 12:20:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Linux驱动中的并发控制&quot;&gt;&lt;a href=&quot;#Linux驱动中的并发控制&quot; class=&quot;headerlink&quot; title=&quot;Linux驱动中的并发控制&quot;&gt;&lt;/a&gt;Linux驱动中的并发控制&lt;/h2&gt;&lt;h3 id=&quot;并发与竞态&quot;&gt;&lt;a href=&quot;#并发与竞</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Linux驱动中的并发控制"><a href="#Linux驱动中的并发控制" class="headerlink" title="Linux驱动中的并发控制"></a>Linux驱动中的并发控制</h2><h3 id="并发与竞态"><a href="#并发与竞态" class="headerlink" title="并发与竞态"></a>并发与竞态</h3><p><strong>并发</strong>指的是多个执行单元同时、并行被执行，而并发的执行单元对共享资源（硬件资源和软件上的全局变量、静态变量等）的访问很容易导致竞态。在linux内核中，主要的竞态发生于如下几种情况：</p><ol><li>对称多处理器(SMP)的多个CPU</li><li>单CPU内进程与抢占它的进程</li><li>中断(硬中断，软中断，Tasklet、底半部)与进程之间。</li></ol><p>解决竞态问题的途径是保证对共享资源的<strong>互斥访问</strong>，所谓<strong>互斥访问</strong>是指一个执行单元在访问共享资源的时候，其他的执行单元被禁止访问。</p><h3 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h3><p>在单CPU范围内避免竞态的一种简单方法是在进入临界区之前屏蔽系统的中断。中断屏蔽将使得中断与进程之间的并发不再发生。由于linux内核的进程调度等操作都依赖与中断实现，内核抢占进程之间的并发也就避免；<br>中断屏蔽的使用方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disable() <span class="comment">//屏蔽中断</span></span><br><span class="line"></span><br><span class="line">critical section <span class="comment">//临界区</span></span><br><span class="line"></span><br><span class="line">local_irq_enable()<span class="comment">//开中断</span></span><br></pre></td></tr></table></figure><p><code>local_irq_disable()</code>和<code>local_irq_enable()</code>都只能禁止和使能本CPU内的中断，并不能解决SMP多CPU引发的竞态。因此中断屏蔽一般与<strong>自旋锁</strong>联合使用。</p><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作指的是在执行过程中不会被别的代码路径所中断的操作。</p><p>Linux内核原子操作分为两类：</p><ol><li>针对位</li><li>针对整型</li></ol><h4 id="整型原子操作"><a href="#整型原子操作" class="headerlink" title="整型原子操作"></a>整型原子操作</h4><ol><li>设置原子变量的值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">atomic_set</span><span class="params">(<span class="type">atomic_t</span> *v <span class="type">int</span> i)</span>; <span class="comment">//设置原子变量的值为i；</span></span><br><span class="line"><span class="type">atomic_t</span> v = ATOMIC_INIT(<span class="number">0</span>); <span class="comment">//设置原子变量v并初始化为0；</span></span><br></pre></td></tr></table></figure></li><li>获取原子变量的值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_read</span>(<span class="type">atomic_t</span> *v); <span class="comment">//返回原子变量的值</span></span><br></pre></td></tr></table></figure></li><li>原子变量加&#x2F;减<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">atomic_add</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span> <span class="comment">//原子变量增加i</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">atomic_sub</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span> <span class="comment">//原子变量减少i</span></span><br></pre></td></tr></table></figure></li><li>原子变量自增&#x2F;自减<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">atomic_inc</span><span class="params">(<span class="type">atomic_t</span> *v)</span><span class="comment">//原子变量增加1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">atomic_dec</span><span class="params">(<span class="type">atomic_t</span> *v)</span><span class="comment">//原子变量减少1</span></span><br></pre></td></tr></table></figure></li><li>测试并操作<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atomic_inc_and_test</span><span class="params">(<span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_dec_and_test</span><span class="params">(<span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_sub_and_test</span><span class="params">(<span class="type">atomic_t</span> *v)</span>;</span><br></pre></td></tr></table></figure>上述操作对原子变量指向自增自减和减操作后测试其是否为0，为0则返回true。</li><li>操作并返回<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atomic_add_return</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_sub_return</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_inc_return</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_dec_return</span><span class="params">(<span class="type">int</span> i,<span class="type">atomic_t</span> *v)</span>;</span><br></pre></td></tr></table></figure>上述对原子变量进行操作后返回新的值。</li></ol><h4 id="位原子操作"><a href="#位原子操作" class="headerlink" title="位原子操作"></a>位原子操作</h4><ol><li>设置位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span>;<span class="comment">//设置addr地址的第nr位，所谓设置位即将位写为1.</span></span><br></pre></td></tr></table></figure></li><li>清除位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clear_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span><span class="comment">//清除addr地址的第nr位即将位写为0</span></span><br></pre></td></tr></table></figure></li><li>改变位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span><span class="comment">//对addr地址的第nr位进行反置</span></span><br></pre></td></tr></table></figure></li><li>测试位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_bit(nr,<span class="type">void</span> *addr)<span class="comment">//返回addr地址的第nr位</span></span><br></pre></td></tr></table></figure></li><li>测试并操作位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test_and_set_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">test_and_clear_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">test_and_change_bit</span><span class="params">(nr,<span class="type">void</span> *addr)</span>;</span><br></pre></td></tr></table></figure>上述操作相当于先指向test_bit后再执行相关操作。</li></ol><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><h4 id="自旋锁的使用"><a href="#自旋锁的使用" class="headerlink" title="自旋锁的使用"></a>自旋锁的使用</h4><p><strong>自旋锁</strong>可以对临界资源进行互斥访问。为了获得一个自旋锁，在某CPU上运行的代码需先执行一个原子操作，该操作测试并设置某个内存变量。</p><ul><li>如果测试结果表明锁已经空闲，则程序获得这个自旋锁并继续执行；</li><li>如果测试结果表明锁被占用，程序将在一个小循环内重复 <strong>“测试并设置”</strong>，这就是所谓的<strong>自旋</strong>。</li></ul><p>linux系统中与自旋锁相关的操作有如下四种：</p><ol><li>定义自旋锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> spin;</span><br></pre></td></tr></table></figure></li><li>初始化自旋锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_init(lock);</span><br></pre></td></tr></table></figure></li><li>获得自旋锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spink_lock(lock);</span><br></pre></td></tr></table></figure>该宏用于获得自旋锁lock，如果能够立即获得，就马上返回，否则，将自旋在那儿，知道该自旋锁的保持者释放<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_try_lock(lock)</span><br></pre></td></tr></table></figure>该宏尝试获得自旋锁，如果能够获得，它获得锁并返回真，否则立即返回假，实际上不再“自旋”。</li><li>释放自旋锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_unlock(lock)</span><br></pre></td></tr></table></figure></li></ol><p>自旋锁一般如下使用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个自旋锁</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line">spin_lock_init(&amp;lock);</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock); <span class="comment">//获得自旋锁，保护临界区</span></span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock); <span class="comment">//解锁</span></span><br></pre></td></tr></table></figure><p>自旋锁主要针对SMP或单CPU但内核可抢占的情况，对于单CPU和内核不抢占的系统，自旋锁退化为空操作。</p><p>在使用自旋锁要注意如下几个问题：</p><ol><li>自旋锁实际上是忙等锁，只有在占用锁的时间极短的情况下，使用自旋锁才是合理的。否在将会降低系统的性能</li><li>自旋锁可能导致死锁，引发该问题最常见的情况是递归使用一个自旋锁。在自旋锁占用期间不嫩调用<code>copy_from_user()</code>,<code>copy_to_user()</code>,<code>kmalloc()</code>这些函数。</li></ol><h4 id="读写自旋锁"><a href="#读写自旋锁" class="headerlink" title="读写自旋锁"></a>读写自旋锁</h4><p>自旋锁的衍生锁<strong>读写自旋锁</strong>可允许读的并发，但是在写操作方面，只能最多有一个写进程。读和写不能同时进行。</p><ol><li><p>定义和初始化读写自旋锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rwlock_t</span> my_rwlock = RW_LOCK_UNLOCKED <span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">rwlock_t</span> my_rwlock;</span><br><span class="line">rwlock_init(&amp;my_rwlock)<span class="comment">//动态初始化</span></span><br></pre></td></tr></table></figure></li><li><p>读锁定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_lock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_lock_irqsave</span><span class="params">(<span class="type">rwlock_t</span> *lock,<span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_lock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_lock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure></li><li><p>读解锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_unlock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_unlock_irqsave</span><span class="params">(<span class="type">rwlock_t</span> *lock,<span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_unlock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_unlock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在读取共享资源之前，先调用读锁定函数，完成之后应调用读解锁函数。</p></blockquote></li><li><p>写锁定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_lock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_lock_irqsave</span><span class="params">(<span class="type">rwlock_t</span> *lock,<span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_lock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_lock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_trylock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure></li><li><p>写解锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_unlock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_unlock_irqsave</span><span class="params">(<span class="type">rwlock_t</span> *lock,<span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_unlock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_unlock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在对共享资源进行写之前，先调用写锁定函数，完成之后应调用写解锁函数。</p></blockquote></li></ol><p>读写锁使用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rwlock_t</span> lock;  <span class="comment">//定义rwlock</span></span><br><span class="line">rwlock_init(&amp;lock); <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">read_lock(&amp;lock);</span><br><span class="line">···<span class="comment">//临界资源</span></span><br><span class="line">read_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">write_lock_irqsave(&amp;lock,flags);</span><br><span class="line">···<span class="comment">//临界资源</span></span><br><span class="line">write_unlock_irqrestore(&amp;lock,flag);</span><br></pre></td></tr></table></figure><h4 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h4><p>顺序锁是读写锁的优化，锁使用顺序锁，读执行单元不会被写执行单元阻塞。如果读执行单元在读操作期间，写执行单元已经发送了写操作，那么读执行单元必须重新读取数据，以确保数据是完整的。</p><blockquote><p>相关操作日后待补充</p></blockquote><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量也是用来保护临界区的一种方法，只有得到信号量的进程才能执行临界区代码。<br>linux中信号量相关操作如下：</p><ol><li>定义信号量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span></span><br></pre></td></tr></table></figure></li><li>初始化信号量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem,<span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure>初始化信号量，并设置信号量的值为val;</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_MUTEX</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_MUTEX_LOCKED</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br></pre></td></tr></table></figure><p><code>init_MUTEX</code>初始化一个用于互斥的信号量，把信号量sem的值设置为1.<br><code>init_MUTEX_LOCKED</code>初始化一个信号量，把信号量sem的值设置为0.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_MUTEX(name)  <span class="comment">//宏，初始信号量为1</span></span><br><span class="line">DECLARE_MUTEX_LOCKED(name) <span class="comment">//宏，初始信号量为0</span></span><br></pre></td></tr></table></figure><ol start="3"><li>获得信号量</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;<span class="comment">//用于获得信号量，但是不能在中断上下文使用，会导致睡眠</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_interruptible</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;<span class="comment">//因为该函数进入睡眠的进程能被信号打断，而上面的不行。信号导致该函数返回值非0</span></span><br></pre></td></tr></table></figure><ol start="4"><li>释放信号量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="keyword">struct</span> semaphore * sem)</span>;<span class="comment">//释放信号量，唤醒等待者。</span></span><br></pre></td></tr></table></figure></li></ol><p>信号量使用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_MUTEX(mount_sem);<span class="comment">//定义</span></span><br><span class="line">down(&amp;mount_sem);<span class="comment">//获得信号量</span></span><br><span class="line"></span><br><span class="line">···<span class="comment">//临界区</span></span><br><span class="line">up(&amp;mount_Sem);<span class="comment">//释放信号量</span></span><br></pre></td></tr></table></figure><h4 id="完成量用于同步"><a href="#完成量用于同步" class="headerlink" title="完成量用于同步"></a>完成量用于同步</h4><p>***完成量(completion)***，用于一个执行单元等待另一个执行单元执行完某事。</p><p>linux中完成量操作有如下几种：</p><ol><li><p>定义完成量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">my_completion</span>;</span></span><br></pre></td></tr></table></figure></li><li><p>初始化完成量</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_completion(&amp;my_completion);</span><br></pre></td></tr></table></figure><p>也可通过如下宏实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_COMPLETION(my_completion);</span><br></pre></td></tr></table></figure><ol start="3"><li><p>等待完成量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_for_completion</span><span class="params">(<span class="keyword">struct</span> completion *c)</span>;<span class="comment">//等待一个完成量被唤醒</span></span><br></pre></td></tr></table></figure></li><li><p>唤醒完成量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">complete</span><span class="params">(<span class="keyword">struct</span> completion *c)</span>;  <span class="comment">//唤醒一个等待的执行单元</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">complete_all</span><span class="params">(<span class="keyword">struct</span> completion *c)</span>; <span class="comment">//释放所有等待统一完成量的执行单元</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>自旋锁和信号量选用的三项原则</strong></p><ul><li>使用信号量的开销是进程上下文切换时间Tsw，使用自旋锁的开销是等待获取自旋锁Tcs,若Tcs比较小，使用自旋锁，反之，使用信号量。</li><li>信号量保护的临界区可能包含引起阻塞的代码，而自旋锁绝对要避免用来保护这样的临界区</li><li>信号量存在于进程上下文，如果被保护的共享资源需要在中断或者软中断的情况下使用，则在二者之间只能选择自旋锁。</li></ul>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/linux-kernal-driver/">Linux内核驱动</category>
      
      
      <category domain="http://singlewang.top/tags/Linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/">Linux内核驱动</category>
      
      <category domain="http://singlewang.top/tags/Linux%E9%94%81/">Linux锁</category>
      
      <category domain="http://singlewang.top/tags/Linux%E5%B9%B6%E5%8F%91/">Linux并发</category>
      
      
      <comments>http://singlewang.top/2022/05/09/linux/linux-kernal/linux-kernal-driver/linux%E9%94%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>cpp之虚函数与多态</title>
      <link>http://singlewang.top/2022/05/05/cpp/cpp%E5%A4%9A%E6%80%81/</link>
      <guid>http://singlewang.top/2022/05/05/cpp/cpp%E5%A4%9A%E6%80%81/</guid>
      <pubDate>Thu, 05 May 2022 13:20:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h2&gt;&lt;p&gt;何为 &lt;em&gt;&lt;strong&gt;多态&lt;/strong&gt;&lt;/em&gt;,顾名思义是同一个事物在不同场景下的多种形态。&lt;br&gt;多态分类：&lt;/p&gt;
&lt;u</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>何为 <em><strong>多态</strong></em>,顾名思义是同一个事物在不同场景下的多种形态。<br>多态分类：</p><ul><li>静态多态(编译阶段)<ul><li>函数重载</li><li>泛型编程</li></ul></li><li>动态多态(运行阶段)<ul><li>虚函数</li></ul></li></ul><p><em><strong>为什么需要多态</strong></em><br>派生类对象的地址可以赋值给基类指针。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时并不确定要执行的是基类还是派生类的虚函数；而当程序运行到该语句时，如果基类指针指向的是一个基类对象，则基类的虚函数被调用，如果基类指针指向的是一个派生类对象，则派生类的虚函数被调用。这种机制就叫作 <strong>多态（polymorphism）</strong>。</p><h3 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h3><p>函数重载就是一个简单的静态多态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Add</span><span class="params">(<span class="type">double</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">//Add(10.0, 20.0);  //这是一个问题代码</span></span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">10.0</span>,<span class="number">20</span>);  <span class="comment">//正常代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>静态多态实在编译期间完成的，编译器会根据实参类型来调用合适的函数,如果有合适的函数就调用，如果没有就会发出警告或报错</em></p><h3 id="动态多态"><a href="#动态多态" class="headerlink" title="动态多态"></a>动态多态</h3><p>动态多态，看名字就知道和静态多态是相反的。<em>它是在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的&#x3D;&#x3D;虚函数&#x3D;&#x3D;</em></p><p><em><strong>动态多态的条件</strong></em></p><ul><li>基类中必须包含虚函数，并且派生类中一定要对基类中的虚函数进行重写</li><li>通过基类对象的指针或者引用调用虚函数。</li></ul><p>提到动态多态那么不得不提一嘴 <em><strong>虚函数</strong></em>。虚函数可以说对动态多态具有决定性的作用。有虚函数才能构成多态。使用虚函数的注意事项：</p><ol><li>只需要在虚函数的声明处加上 virtual 关键字，函数定义处可以加也可以不加。</li><li>可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽（覆盖）关系的同名函数都将自动成为虚函数。</li><li>当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。</li><li>只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）。</li><li>构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。</li><li>析构函数可以声明为虚函数，而且有时候必须要声明为虚函数。</li></ol><p><em><strong>那么虚函数的作用是什么呢？</strong></em></p><ol><li>定义子类对象，并调用对象中未被子类覆盖的基类函数A。同时在该函数A中，又调用了已被子类覆盖的基类函数B。那此时将会调用基类中的函数B，可我们本应该调用的是子类中的覆盖函数B。虚函数即能解决这个问题。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类 Father</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Father::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在函数中调用了，子类覆盖基类的函数display()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fatherShowDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Son</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重写基类中的display()函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Son::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son son;                    <span class="comment">// 子类对象</span></span><br><span class="line">    son.<span class="built_in">fatherShowDisplay</span>();    <span class="comment">// 通过基类中未被覆盖的函数，想调用子类中覆盖的display函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父类中的<code>display()</code>不是虚函数，则执行结果为<code>Father::display()</code>。反之，执行结果为<code>Son::display()</code>。</p><ol start="2"><li>在使用指向子类对象的基类指针，并调用子类中的覆盖函数时，如果该函数不是虚函数，那么将调用基类中的该函数；如果该函数是虚函数，则会调用子类中的该函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类 Father</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义了虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Father::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Son</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 覆盖基类中的display函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Son::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Father *fp;     <span class="comment">// 定义基类指针</span></span><br><span class="line">    Son son;        <span class="comment">// 子类对象</span></span><br><span class="line">    fp=&amp;son;        <span class="comment">// 使基类指针指向子类对象</span></span><br><span class="line">    fp-&gt;<span class="built_in">display</span>();  <span class="comment">// 通过基类指针想调用子类中覆盖的display函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父类中的<code>display()</code>不是虚函数，则执行结果为<code>Father::display()</code>。反之，执行结果为<code>Son::display()</code>。</p><blockquote><p>哪些函数不能定义为虚函数？（面试题）</p><ol><li>友元函数，它不是类的成员函数</li><li>全局函数</li><li>静态成员函数，它没有this指针</li><li>构造函数，拷贝构造函数，以及赋值运算符重载。</li></ol></blockquote><p><em><strong>纯虚函数和抽象类</strong></em><br><strong>纯虚函数</strong>:没有函数体的虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">( )</span> </span>= <span class="number">0</span> ; <span class="comment">//纯虚函数</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>包含纯虚函数的类叫做<strong>抽象类</strong></p><ul><li>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象</li><li>抽象类的指针和引用可以指向抽象类派生出来的类的对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;         <span class="comment">// 错，A 是抽象类，不能创建对象</span></span><br><span class="line">A * pa ;     <span class="comment">// ok,可以定义抽象类的指针和引用</span></span><br><span class="line">pa = <span class="keyword">new</span> A ; <span class="comment">// 错误, A 是抽象类，不能创建对象</span></span><br></pre></td></tr></table></figure><h3 id="多态的表现形式"><a href="#多态的表现形式" class="headerlink" title="多态的表现形式"></a>多态的表现形式</h3><p><em><strong>多态的表现形式一</strong></em></p><ul><li>&#x3D;&#x3D;派生类的指针&#x3D;&#x3D;可以赋给&#x3D;&#x3D;基类指针&#x3D;&#x3D;</li><li>通过基类指针调用基类和派生类中的同名&#x3D;&#x3D;虚函数时&#x3D;&#x3D;：</li></ul><ol><li>若该指针指向一个基类的对象，那么调用是基类的虚函数；</li><li>若该指针指向一个派生类的对象，那么调用的是派生类的虚函数。</li></ol><blockquote><p>调用哪个虚函数，取决于指针对象指向哪种类型的对象。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFather</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123; &#125; <span class="comment">// 虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSon</span> : <span class="keyword">public</span> CFather </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CSon son;</span><br><span class="line">    CFather *p = &amp;son;</span><br><span class="line">    p-&gt;<span class="built_in">Fun</span>(); <span class="comment">//调用哪个虚函数取决于 p 指向哪种类型的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针<code>p</code>指向的是<code>CSon</code>类对象，所以<code>p-&gt;Fun()</code>调用的是<code>CSon</code>类的<code>Fun</code>。</p><p><em><strong>多态的表现形式二</strong></em></p><ul><li>派生类的对象可以付给基类&#x3D;&#x3D;引用&#x3D;&#x3D;</li><li>通过基类引用调用基类和派生类中的同名&#x3D;&#x3D;虚函数&#x3D;&#x3D;时：</li></ul><ol><li>若该引用引用的是一个基类的对象，那么被调用的是基类的虚函数</li><li>若该引用引用的是派生类的对象，那么被调用的是派生类的虚函数。</li></ol><blockquote><p>调用哪个虚函数，取决于引用的对象是哪种类型的对象</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFather</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123; &#125; <span class="comment">// 虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSon</span> : <span class="keyword">public</span> CFather </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CSon son;</span><br><span class="line">    CFather &amp;r = son;</span><br><span class="line">    r.<span class="built_in">Fun</span>(); <span class="comment">//调用哪个虚函数取决于 r 引用哪种类型的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>r</code>引用的是<code>CSon</code>类对象，所以<code>r.Fun()</code>调用的是<code>CSon</code>类的<code>Fun</code>。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/CPP/">CPP</category>
      
      
      <category domain="http://singlewang.top/tags/cpp/">cpp</category>
      
      <category domain="http://singlewang.top/tags/%E5%A4%9A%E6%80%81/">多态</category>
      
      <category domain="http://singlewang.top/tags/%E8%99%9A%E5%87%BD%E6%95%B0/">虚函数</category>
      
      
      <comments>http://singlewang.top/2022/05/05/cpp/cpp%E5%A4%9A%E6%80%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux内核协议栈-cp3</title>
      <link>http://singlewang.top/2022/05/04/linux/linux-kernal/linx-kernal-proto/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp3/</link>
      <guid>http://singlewang.top/2022/05/04/linux/linux-kernal/linx-kernal-proto/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp3/</guid>
      <pubDate>Wed, 04 May 2022 12:17:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;3-配置系统&quot;&gt;&lt;a href=&quot;#3-配置系统&quot; class=&quot;headerlink&quot; title=&quot;3.配置系统&quot;&gt;&lt;/a&gt;3.配置系统&lt;/h2&gt;&lt;h3 id=&quot;3-1配置过程分析&quot;&gt;&lt;a href=&quot;#3-1配置过程分析&quot; class=&quot;headerlink</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="3-配置系统"><a href="#3-配置系统" class="headerlink" title="3.配置系统"></a>3.配置系统</h2><h3 id="3-1配置过程分析"><a href="#3-1配置过程分析" class="headerlink" title="3.1配置过程分析"></a>3.1配置过程分析</h3><h4 id="3-1-1配置如何下达到内核"><a href="#3-1-1配置如何下达到内核" class="headerlink" title="3.1.1配置如何下达到内核"></a>3.1.1配置如何下达到内核</h4><p>我们假设在安装我们的 Linux 系统时，没有配置 IP 地址，也没有挂上网线，完完全全是一台“裸机”， 这样方便我们跟踪系统到底做了什么。<br>使用<code>ifconfig -a</code>查看网络配置<br>使用<code>strace ifconfig eth0 192.168.18.2 netmask 255.255.255.0</code>配置号ip和网络掩码<br>在大部分系统上是没有 ifconfig 的源代码的，那么为了查看 ifconfig 内部完成了什么操作时，可以用strace命令查看。<br>把 ifconfig 内部调用的系统接口整理如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="type">int</span> argc, <span class="type">char</span> **argv ) &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span> </span><br><span class="line">    <span class="type">char</span> host[<span class="number">128</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aftype</span> *<span class="title">ap</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hwtype</span> *<span class="title">hw</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span> </span><br><span class="line">    <span class="type">char</span> **spp; </span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">    fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);</span><br><span class="line">    ifr.ifr_name = “eth0”; </span><br><span class="line"> </span><br><span class="line">    ap = inet_aftype = &#123;</span><br><span class="line">    <span class="string">&quot;inet&quot;</span>, <span class="literal">NULL</span>, <span class="comment">/*&quot;DARPA Internet&quot;, */</span> AF_INET, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>), INET_print, INET_sprint, INET_input, INET_reserror, <span class="literal">NULL</span> <span class="comment">/*INET_rprint */</span> , <span class="literal">NULL</span> <span class="comment">/*INET_rinput */</span> , INET_getnetmask,</span><br><span class="line"><span class="number">-1</span>, <span class="comment">/* 这个值会被赋成 fd，即刚才打开的 socket */</span> <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line">    host = “<span class="number">192.168</span><span class="number">.18</span><span class="number">.2</span>”; </span><br><span class="line">    ap-&gt;input(<span class="number">0</span>, host, &amp;sa);<span class="comment">/* 在此 sa-&gt;sa_family=AF_INET，af-&gt;sa_data 已经被设置成 192.168.1.1 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">char</span> *) &amp;ifr.ifr_addr, (<span class="type">char</span> *) &amp;sa, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)); </span><br><span class="line">    ioctl (fd, SIOCSIFADDR, &amp;ifr);</span><br><span class="line">    ioctl (skfd, SIOCGIFFLAGS, &amp;ifr); </span><br><span class="line">    ioctl (skfd, SIOCSIFFLAGS, &amp;ifr);</span><br><span class="line">    host = “<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>”;</span><br><span class="line">    ioctl (skfd, SIOCSIFNETMASK, ifr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可以看出 ifconfig 实际调用了 2 个系统函数：socket 和 ioctl。</p><h4 id="3-1-2socket系统调用"><a href="#3-1-2socket系统调用" class="headerlink" title="3.1.2socket系统调用"></a>3.1.2socket系统调用</h4><p>内核中与socket对应的系统调用时sys_socket,所谓的船舰套接字，就是在sockfs这个文件系统中创建一个节点。该节点是一个文件，不过这个文件具有非普通文件的属性，于是起名socket。<br>从进程角度看，一个套接口就是一个特殊的已打开文件。<br>socket函数本身经过glibc库对其封装，通过int 0x80产生一个软件中断，由内核导向执行sys_socket。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/linx-kernal-proto/">Linux内核协议栈</category>
      
      
      <category domain="http://singlewang.top/tags/kernal/">kernal</category>
      
      <category domain="http://singlewang.top/tags/linux%E5%8D%8F%E8%AE%AE%E6%A0%88/">linux协议栈</category>
      
      <category domain="http://singlewang.top/tags/%E5%86%85%E6%A0%B8/">内核</category>
      
      
      <comments>http://singlewang.top/2022/05/04/linux/linux-kernal/linx-kernal-proto/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>c++遇到的bug-1</title>
      <link>http://singlewang.top/2022/05/03/cpp/cpp-bug/c++bug-1/</link>
      <guid>http://singlewang.top/2022/05/03/cpp/cpp-bug/c++bug-1/</guid>
      <pubDate>Tue, 03 May 2022 12:54:00 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;&lt;code&gt;reference to local variable ‘c’ returned [-Wreturn-local-addr]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;函数的返回值为函数内部定义变量的引用，但函数在调用完毕后，函数内部定义的变量空间被</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li><code>reference to local variable ‘c’ returned [-Wreturn-local-addr]</code></li></ol><p>函数的返回值为函数内部定义变量的引用，但函数在调用完毕后，函数内部定义的变量空间被释放，无法访问，从而造成的错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix&amp; Matrix::<span class="keyword">operator</span>+(<span class="type">const</span> Matrix&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix result;</span><br><span class="line"><span class="comment">//其他操作</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>改正方法一</strong></em>：给返回变量定义加上static限定符，保证在函数调用完后不释放空间<br>Matrix&amp; Matrix::operator+(const Matrix&amp; rhs)<br>{<br>    static Matrix result;<br>    &#x2F;&#x2F;其他操作<br>    return result;<br>}</p><p><em><strong>改正方法二</strong></em>：去掉返回值的引用，保证函数外部无法访问返回值的空间，只能得到其内容<br>Matrix Matrix::operator+(const Matrix&amp; rhs)<br>{<br>    static Matrix result;<br>    &#x2F;&#x2F;其他操作<br>    return result;<br>}</p><ol start="2"><li><p>LNK2019<br>即使包含了头文件依然会报无法解析的命令,原因可能是没添加相应的.lib文件</p></li><li><p>不允许指针指向不完整的类类型<br>一般是没有包含相应的头文件</p></li></ol>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/cpp/">C++</category>
      
      <category domain="http://singlewang.top/categories/cpp/cpp-bug/">C++BUG</category>
      
      
      <category domain="http://singlewang.top/tags/cpp/">cpp</category>
      
      <category domain="http://singlewang.top/tags/bug/">bug</category>
      
      
      <comments>http://singlewang.top/2022/05/03/cpp/cpp-bug/c++bug-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>git学习</title>
      <link>http://singlewang.top/2022/05/03/git%E5%AD%A6%E4%B9%A0/</link>
      <guid>http://singlewang.top/2022/05/03/git%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Tue, 03 May 2022 12:51:00 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;初始化一个git目录    &lt;code&gt;git init&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加文件到Git仓库，分两步：&lt;br&gt; 使用命令&lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt;，注意，可反复多次使用，添加多个文件；&lt;br&gt; 使用命令&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>初始化一个git目录    <code>git init</code></li><li>添加文件到Git仓库，分两步：<br> 使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；<br> 使用命令<code>git commit -m &lt;message&gt;</code>提交完成。-m后面输入的是本次提交的说明</li><li>要随时掌握工作区的状态，使用<code>git status</code>命令。<br> 如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li><li>添加远程库<code>git remote add origin git@github.com:SimpleWang0118/C-Game.git</code><br> 添加后，远程库的名字就是<code>origin</code><br> 把本地库的所有内容推送到远程库上（第一次）<code>git push -u origin master</code><br> 只要本地作了提交，就可以通过命令 <code>git push origin master</code>推送至远程库上</li><li>查看远程库信息<code>git remote -v</code></li><li>删除远程库<code>eg git remote rm origin</code></li><li><code>git commit</code>提示<code>Your branch is up-to-date with &#39;origin/master&#39;</code><br> 首先建立一个分支：<code>git branch new branch</code><br> 然后检查分支是否创建成功: <code>git branch</code> *代表的是当前你所在的工作分支<br> 然后切换到你的新分支: <code>git checkout newbranch</code><br> 然后将你的改动提交到新分支上: git add .     git commit -m “18.03.01”<br> 然后切换到主分支:<code>git checkout master</code><br> 然后将新分支提交的改动合并到主分支上:<code>git merge newbranch</code><br> 然后就可以push代码了:<code>git push -u origin master</code><br> 最后还可以删除这个分支:<code>git branch -D newbranch</code></li></ol>]]></content:encoded>
      
      
      
      <category domain="http://singlewang.top/tags/git/">git</category>
      
      <category domain="http://singlewang.top/tags/github/">github</category>
      
      
      <comments>http://singlewang.top/2022/05/03/git%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>刷机教程</title>
      <link>http://singlewang.top/2022/05/03/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</link>
      <guid>http://singlewang.top/2022/05/03/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</guid>
      <pubDate>Tue, 03 May 2022 08:34:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;1、首先解锁手机BL锁，进入开发者选项，然后需要到相应的手机官网下载解锁工具。&lt;br&gt;2、安装对应手机的rec软件，之后进入rec，先双清，即首先清除数据，再格式化&lt;br&gt;3、下载对应的系统压缩包&lt;br&gt;4、在rec软件中安装压缩包即可。&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>1、首先解锁手机BL锁，进入开发者选项，然后需要到相应的手机官网下载解锁工具。<br>2、安装对应手机的rec软件，之后进入rec，先双清，即首先清除数据，再格式化<br>3、下载对应的系统压缩包<br>4、在rec软件中安装压缩包即可。</p>]]></content:encoded>
      
      
      
      <category domain="http://singlewang.top/tags/%E5%88%B7%E6%9C%BA/">刷机</category>
      
      
      <comments>http://singlewang.top/2022/05/03/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux内核协议栈-cp2</title>
      <link>http://singlewang.top/2022/05/03/linux/linux-kernal/linx-kernal-proto/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp2/</link>
      <guid>http://singlewang.top/2022/05/03/linux/linux-kernal/linx-kernal-proto/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp2/</guid>
      <pubDate>Tue, 03 May 2022 08:34:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;2-系统初始化&quot;&gt;&lt;a href=&quot;#2-系统初始化&quot; class=&quot;headerlink&quot; title=&quot;2.系统初始化&quot;&gt;&lt;/a&gt;2.系统初始化&lt;/h2&gt;&lt;h3 id=&quot;2-1-系统初始化流程简介&quot;&gt;&lt;a href=&quot;#2-1-系统初始化流程简介&quot; class</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="2-系统初始化"><a href="#2-系统初始化" class="headerlink" title="2.系统初始化"></a>2.系统初始化</h2><h3 id="2-1-系统初始化流程简介"><a href="#2-1-系统初始化流程简介" class="headerlink" title="2.1 系统初始化流程简介"></a>2.1 系统初始化流程简介</h3><p>在系统启动过程中，我们要关注这几个方面： </p><ol><li>中断系统及调度系统 </li><li>文件系统的初始化 </li><li>设备管理系统的初始化</li><li>网络协议的初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kernel_thread</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> * arg, <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br></pre></td></tr></table></figure><p><code>kernel_thread</code>创建一个线程，定义在arch&#x2F;i386&#x2F;kernel&#x2F;process.c中，Linux 的内核线程是没有虚拟存储空间的进程，它们运行在内核中，直接使用物理地址空间。</p><h3 id="2-2内核文件解读"><a href="#2-2内核文件解读" class="headerlink" title="2.2内核文件解读"></a>2.2内核文件解读</h3><h4 id="2-2-1ELF文件格式"><a href="#2-2-1ELF文件格式" class="headerlink" title="2.2.1ELF文件格式"></a>2.2.1ELF文件格式</h4><p>ELF 是*nix 系统上可执行文件的标准格式，它取代了out格式的可执行文件，原因在于它的可扩展性。<br>ELF文件有三种不同的形式：</p><ol><li>Relocatable：由编译器和汇编器生成，由 linker 处理它。 </li><li>Executable：所有的重定位和符号解析都完成了，也许共享库的符号要在运行时刻解析。</li><li>Shared Object：包含 linker 需要的符号信息和运行时刻所需的代码。</li></ol><p>ELF 文件有双重性质：一方面，编译器、汇编器、连接器都把它看作是逻辑段（sections）的集合， 另一方面 loader 把它看作段（segments）的集合。Section 是给 linker 做进一步处理的，而 segments 是被映射到内存中去的。</p><p>一个 segment 可以由几个 sections 组成。为了定位不同 segment&#x2F;section，可执行文件用一个 table 来记录各个 segment&#x2F;section 的位置和描述。</p><h4 id="2-2-2Link-Scripts知识"><a href="#2-2-2Link-Scripts知识" class="headerlink" title="2.2.2Link Scripts知识"></a>2.2.2Link Scripts知识</h4><p>为什么我们编出来的代码肯定是在用户地址空间运行，而内核编出来的代码 却一定是运行在内核空间？<br>主要是因为链接器的作用。不能简单地认为链接器仅仅完成将各 obj 文件拼在一起的任务，而且它还指定每个段被装入内存的真正地址。</p><p>可以用<code>ld -verbose</code>查看<code>ld script</code></p><h3 id="2-3中断及任务调度管理"><a href="#2-3中断及任务调度管理" class="headerlink" title="2.3中断及任务调度管理"></a>2.3中断及任务调度管理</h3><h4 id="2-3-1中断及软中断模型"><a href="#2-3-1中断及软中断模型" class="headerlink" title="2.3.1中断及软中断模型"></a>2.3.1中断及软中断模型</h4><p>Linux 支持 CPU 的外部硬件中断和内部中断。&#x3D;&#x3D;内部中断包含系统调用陷入和异常&#x3D;&#x3D;，在一般的嵌入式操作系统（比如 VxWorks）中是没有系统调用这个概念的。</p><ul><li>&#x3D;&#x3D;系统调用&#x3D;&#x3D;就是软件有计划地调用 CPU 提供的特殊指令，触发 CPU 内部产生一个中断，于是完成一次核内核外运行空间的切换，具体可以参考许多书籍。</li><li>&#x3D;&#x3D;异常&#x3D;&#x3D;就是软件无意的执行了一个非法指令（比如除 0）从而造成 CPU 内部引发一次中断。</li></ul><p>&#x3D;&#x3D;外部中断&#x3D;&#x3D;特指外部设备发出的中断信号。但这几种中断的 CPU 处理过程基本相同，即：在执行完当 前指令后，或在执行当前指令期间，根据中断源所提供的“中断向量”，在内存中找到相应的 ISR（中断<br>服务例程）然后调用之。</p><h5 id="2-3-1-1中断系统和软中断"><a href="#2-3-1-1中断系统和软中断" class="headerlink" title="2.3.1.1中断系统和软中断"></a>2.3.1.1中断系统和软中断</h5><p>IRQ 是设备相关的号码，一般生产厂商都会使自己的设备分配到一个合适的号码。<br>&#x3D;&#x3D;中断向量&#x3D;&#x3D;就是操作系统中关于如何处理中断的内存组织结构，它们之间存在某种映射关系，这种关系是由CPU体系结构以及操作系统决定的。</p><blockquote><p>中断向量号0x80是系统调用号</p></blockquote><p>软中断是在处理完所有的中断之后才会处理的。目前linux内核中定义了6种软中断。在<code>start_kernel</code>函数中调用的<code>softirp_init</code>只初始化了两个。</p><p>Tasklet机制是一种比较特殊的软中断。指一小段可以执行的代码。通常以函数的形式出现。从某种程度上讲tasklet机制是linux内核对BH机制的一种扩展。它呈现出以下两个特点:</p><ol><li>与一般的软中断不同，某一段 tasklet 代码在某个时刻只能在一个 CPU 上运行，而不像一般的软 中断服务函数（即 softirq_action 结构中的 action 函数指针）那样在同一时刻可以被多个 CPU 并发地执行。</li><li>与BH机制不同，不同的 tasklet 代码在同一时刻可以在多个 CPU上并发地执行，而不像BH机制 那样必须严格地串行化执行（也即在同一时刻系统中只能有一个 CPU 执行BH函数）。</li></ol><h3 id="2-4虚拟文件系统"><a href="#2-4虚拟文件系统" class="headerlink" title="2.4虚拟文件系统"></a>2.4虚拟文件系统</h3><p>VFS（虚拟文件系统）在 Linux 及Unix 家族中是非常重要的概念，可以说它是操作系统的骨架。VFS 只存在与内存中，它在系统启动时被创建，系统关闭时注销。<br>&#x3D;&#x3D;VFS 的作用就是屏蔽各类文件系统的差异， 给用户、应用程序、甚至 Linux 其他管理模块提供统一的接口集合。&#x3D;&#x3D;</p><p>VFS 描述文件系统使用超级块和 inode 的方式，所谓超级块就是对所有文件系统的管理机构，每种 文件系统都要把自己的信息挂到 <code>super_blocks</code> 这么一个全局链表上。内核中是分成 2 个步骤完成：首先 每个文件系统必须通过 <code>register_filesystem</code> 函数将自己的 <code>file_system_type</code> 挂接到 <code>file_systems</code> 这个全局变量上，然后调用 <code>kern_mount</code> 函数把自己的文件相关操作函数集合表挂到 <code>super_blocks</code> 上。</p><h3 id="2-5网络协议栈各部分初始化"><a href="#2-5网络协议栈各部分初始化" class="headerlink" title="2.5网络协议栈各部分初始化"></a>2.5网络协议栈各部分初始化</h3><p>初始化大致的顺序：</p><ol><li>core_initcall:sock_init()</li><li>fs_initcall:inet_init()</li><li>subsys_initcall:net_dev_init()</li><li>device_initcall:设备驱动初始化</li></ol><h4 id="2-5-1网络基础系统初始化"><a href="#2-5-1网络基础系统初始化" class="headerlink" title="2.5.1网络基础系统初始化"></a>2.5.1网络基础系统初始化</h4><p>第一个步骤使用<code>core_initcall</code>初始化宏修饰<code>sock_init</code>函数，此函数知识分配一些内存空间，以及创建一个sock_fs_type的二年间系统。</p><blockquote><p>基本的socket初始化必须在每一个TCP&#x2F;IP成员协议能注册到socket层之前完成。</p></blockquote><p>当执行<code>do_initcalls</code>时才是真正初始化那些特定协议。</p><h4 id="2-5-2网络内存管理"><a href="#2-5-2网络内存管理" class="headerlink" title="2.5.2网络内存管理"></a>2.5.2网络内存管理</h4><h5 id="2-5-2-1-sk-buff结构"><a href="#2-5-2-1-sk-buff结构" class="headerlink" title="2.5.2.1 sk_buff结构"></a>2.5.2.1 sk_buff结构</h5><p>数据包在应用层称为data，在TCP层成为segment，在IP层称为packet，在数据链路层称为frame。Linux内核中<code>sk_buff&#123;&#125;</code>存放网络接收到或需要发送的数据，因此其必须要有足够的扩展性。<br>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 <code>skb-&gt;data</code> 的值，来逐步剥离协议首部；<br>而要发送报文时，各协议创建<code>sk_buff&#123;&#125;</code>，在经过各下层协议时，通过减少 <code>skb-&gt;data</code><br>的值来增加协议首部。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span>&#123;</span></span><br><span class="line">    <span class="comment">/*这两个成员必须放在前面*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    _u32    qlen;<span class="comment">/*该sk_buff_head引导的一个链表的节点的个数*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当接收一个报文时，创建一个<code>sk_buff&#123;&#125;</code>(sk_buff的内容过多，暂不列出),然后更具地址类型指定该skb实际属于哪一种的报文类型，然后上层协议栈采取相应的处理方式处理该skb。</p><p>其中<code>len</code>是指数据包全部数据的长度，包括<code>data</code>指向的数据和end后面的分片的数据的总长，而<code>data_len</code>只包括分片的数据的长度。<code>truesize</code>的最终值时<code>len+sizof(struct sk_buff)</code>。</p><p>两个后备高速缓存的区别：</p><ul><li><code>skbuff_head_cache</code> 在创建时指定的单位内存区域的大小是<code>sizeof(struct sk_buff)</code>，可以容纳任意数目的<code>struct sk_buff</code>。</li><li><code>skbuff_fclone_cache</code>在创建时指定的单位内存区域大小时<code>2*sizeof(struct sk_buff)+sizeof(atomic_t)</code>。</li></ul><p>创建一个套接字缓冲区，最常用的操作是<code>alloc_skb</code>。它是在<code>skbuff_head_cache</code>中创建。</p><blockquote><p>GSO(Generic Segmentation Offload):<br>协议栈的效率提高的一个策略：尽可能晚的推迟分段，最理想的是在网卡驱动里分段，在网卡驱动里把大包拆开，组成SG list，或在一块预先分配好的内存中重组分段，然后交给网卡。</p></blockquote><h5 id="2-5-2-2-内存管理函数"><a href="#2-5-2-2-内存管理函数" class="headerlink" title="2.5.2.2 内存管理函数"></a>2.5.2.2 内存管理函数</h5><p>在<code>sk_buff&#123;&#125;</code>中的 4 个指针 data、head、tail、end 初始化的时候，data、head、tail 都是指向申请到的 数据区的头部，end 指向数据区的尾部。一般都是通过 data 和 tail 来获得在 sk_buff中 可用的数据区的开始和结尾。而 head 和 end 就表示 sk_buff中存在的数据包最大可扩展的空间范围。</p><p> skb_clone 和 skb_copy 的区别：</p><ul><li>前者基本在 <code>skbuff_fclone_cache</code> 中分配内存，除非 一定要对一个不是可以被克隆的对象进行克隆，那么才会在 <code>skbuff_head_cache</code> 中分配内存，而且只是 <code>sk_buff&#123;&#125;</code>结构的复制，没有涉及到真正数据区（data）的复制；</li><li>后者必定在 <code>skbuff_head_cache</code> 中进行，<br>不仅复制 <code>sk_buff&#123;&#125;</code>，而且复制了数据区。</li></ul><h4 id="2-5-3-网络文件系统初始化"><a href="#2-5-3-网络文件系统初始化" class="headerlink" title="2.5.3 网络文件系统初始化"></a>2.5.3 网络文件系统初始化</h4><p>在 <code>linux</code> 系统中，<code>socket</code> 属于文件系统的一部分，网络通信可以被看作对文件的读取。这种特殊的文件系统叫 <code>sockfs</code>。</p><p>初始化文件系统，首先是调用 <code>register_filesystem(&amp;sock_fs_type)</code>;把文件系统类型注册到 <code>file_systems</code> 链表上，然后调用 <code>kern_mount(&amp;sock_fs_type)</code>;把该文件系统注册到 <code>super_blocks</code> 上。</p><p>在系统初始化的时候要通过 <code>kern_mount</code> 安装此文件系统。所谓创建一个套接字就是在 <code>sockfs</code>文件系统中创建一个特殊文件。</p><h4 id="2-5-4-网络协议初始化"><a href="#2-5-4-网络协议初始化" class="headerlink" title="2.5.4 网络协议初始化"></a>2.5.4 网络协议初始化</h4><p>初始化第二个大步骤就是使用 <code>fs_initcall</code> 初始化宏修饰 <code>inet_init</code> 函数，它初始化和协议本身相关的东西。这一步才真正设计到“栈”的概念。在这之前，必须要知道两个概念–地址族和套接字类型。Linux 将不同的地址族抽象统一为 BSD 套接字接口，应用程序关心的只是BSD套接字接口，通过参数来指定所使用的套接字地址族。</p><p>Linux 内核中为了支持多个地址族，定义了这么一个变量：<code>static struct net_proto_family *net_families[NPROTO]</code>，NPROTO 等于 32，也就是说 Linux 内核支持最多 32 种地址族。</p><p>我们常用的就是 PF_UNIX（1）、PF_INET（2）、PF_NETLINK（16），Linux 还有一个自有的 PF_PACKET（17）。</p><blockquote><p>网络协议的初始化是在网络设备的初始化之前完成的，在 Linux 系统中并不是说网络设备不存在就不需要网络协议了，而是在没有网络设备存在的时候，照样可以完成网络的工作，只不过网络系统物理上只存在于本机一台机器中而已。</p></blockquote><p>一进入初始化就调用 <code>proto_register</code>3次，先后为 tcp、udp、raw的 <code>proto&#123;&#125;</code>结构申请空间并将其挂到一 个全局链表 <code>proto_list</code> 上。这三个 proto 全局变量非常重要，是连接传输层和 IP 层的纽带。</p><p><code>sock_register</code>函数，它把 <code>inet_family_ops</code> 塞入 <code>net_families</code> 数组中，这个 <code>inet_family_ops</code>是如下定义的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> =</span> &#123; </span><br><span class="line">    .family = PF_INET, </span><br><span class="line">    .create = inet_create, </span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户创建 socket 时，先指定 INET 地址族，在指定套接字 类型。换句话说这是数据流发送的流向。</p><p>socket层必须区分哪一个用户应该接收这个包，这叫做<em><strong>socket解复用</strong></em>。</p><p>之后就是初始化第二个方面的必要步骤:注册接收函数<br>Linux 区分永久和非永久协议。永久协议包括像UDP和TCP，这是TCP&#x2F;IP 协议实现的基本部分，去掉一个永久协议是不允许的。所以，UDP和TCP是不能unregistered。此机制由2个函数和一个维护注册协议的数据结构组成。一个负责注册协议，另一个负责注销。每一个注册的协议都放在一个表里，叫<br><em><strong>协议切换表</strong></em>。</p><p>对于发送过程，直接调用IP层函数，而对于内核接收过程则分为2层：上层需要一个接收函数解复用传输协议报文，下层需要一个接收函数解复用网络层报文。报文从设备层送到上层之前，必须区分是IP报文还是ARP报文。</p><p>标识一个套接字的三元组:&lt;地址族，类型，具体协议&gt;。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/linux/">Linux</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/">Linux内核</category>
      
      <category domain="http://singlewang.top/categories/linux/linux-kernal/linx-kernal-proto/">Linux内核协议栈</category>
      
      
      <category domain="http://singlewang.top/tags/kernal/">kernal</category>
      
      <category domain="http://singlewang.top/tags/linux%E5%8D%8F%E8%AE%AE%E6%A0%88/">linux协议栈</category>
      
      <category domain="http://singlewang.top/tags/%E5%86%85%E6%A0%B8/">内核</category>
      
      
      <comments>http://singlewang.top/2022/05/03/linux/linux-kernal/linx-kernal-proto/linux%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88-cp2/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
