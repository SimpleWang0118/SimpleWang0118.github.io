<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Single Wang&#39;s Blog</title>
    <link>http://singlewang.top/</link>
    
    <atom:link href="http://singlewang.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>这一次，你彻彻底底的抛弃了我，但我不恨你，反而谢谢你，让我明白自己在你心中的位置，从此相逢是路人。</description>
    <pubDate>Thu, 03 Nov 2022 12:58:49 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title></title>
      <link>http://singlewang.top/2022/11/03/OFDMA/</link>
      <guid>http://singlewang.top/2022/11/03/OFDMA/</guid>
      <pubDate>Thu, 03 Nov 2022 12:59:25 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;OFDMA&quot;&gt;&lt;a href=&quot;#OFDMA&quot; class=&quot;headerlink&quot; title=&quot;OFDMA&quot;&gt;&lt;/a&gt;OFDMA&lt;/h2&gt;&lt;p&gt;在802.11ax协议中引入了OFDMA技术，所以我们需要定义&lt;strong&gt;时频资源块&lt;/strong&gt;的概念，这</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="OFDMA"><a href="#OFDMA" class="headerlink" title="OFDMA"></a>OFDMA</h2><p>在802.11ax协议中引入了OFDMA技术，所以我们需要定义<strong>时频资源块</strong>的概念，这些时频资源块都是彼此<strong>正交</strong>的。802.11ax中的OFDMA实际上是借鉴LTE的，但是没有LTE资源块那么复杂（比如RE，RB，CP，REG，CCE这些），802.11ax中仅仅有<strong>RU（Resource unit）</strong>的概念。</p><h3 id="OFDMA简介"><a href="#OFDMA简介" class="headerlink" title="OFDMA简介"></a>OFDMA简介</h3><p><img data-src="C:\Users\SimpleWang\AppData\Roaming\Typora\typora-user-images\image-20221103203708938.png" alt="image-20221103203708938"></p><p>我们以上图为例，左图是OFDM的工作模式，右图是OFDMA的工作模式。图中一共有4个用户节点，分别以4种颜色进行标识。图中横轴为<strong>时域</strong>，纵轴为<strong>频域</strong>（即对应不同的子载波）。</p><p><strong>OFDMA相比OFDM一般有两点好处：</strong></p><ol><li>资源的更细腻分配。特别是在部分节点信道状态不太好的情况下，可以根据注水定理的思想（即根据信道质量分配发送功率），来更细腻化的分配信道时频资源。</li><li>能够更好的提供QOS。因为初始的802.11是占据整个信道的，如果有一个QOS数据包需要发送，其一定要等之前的发送者释放完整个信道才行，所以会存在较长的延迟。在OFDMA的情况下，由于一个发送者只占据部分信道，所以能够减少QOS节点接入的延迟。</li></ol><h3 id="OFDMA与OFDM子载波的区别"><a href="#OFDMA与OFDM子载波的区别" class="headerlink" title="OFDMA与OFDM子载波的区别"></a>OFDMA与OFDM子载波的区别</h3><p>OFDM和OFDMA技术的实现是通过<strong>快速傅里叶变换（FFT）</strong>和<strong>快速傅里叶逆变换（IFFT）</strong>来构成的。在OFDM中，信道被分成了多个子载波，每一个子载波是正交的，不会互相干扰，所以其子载波之间是没有保护间隔的。在OFDMA中，也会分配一个子载波作为Null子载波，其不承载任何数据，用来防止载波间干扰（Inter-Carrier Interference ，ICI）。</p><p><img data-src="C:\Users\SimpleWang\AppData\Roaming\Typora\typora-user-images\image-20221103203946270.png" alt="image-20221103203946270"></p><p>如上图所示，一个20 MHz的信道，在802.11n&#x2F;ac有64个子载波组成，每个OFDM子载波是312.5KHz。其中有52个子载波用于承载数据（data subcarriers），4个子载波用作<strong>导频</strong>（pilot subcarriers），八个子载波用作<strong>保护频带</strong>（unused subcarriers）。OFDM子载波可以称为OFDM subcarriers或者OFDM tones。</p><p><img data-src="C:\Users\SimpleWang\AppData\Roaming\Typora\typora-user-images\image-20221103204124943.png" alt="image-20221103204124943"></p><p>802.11ax引入了更长的OFDM Symbol时间（12.8μs），这是传统OFDM Symbol的四倍时间（传统为3.2μs）。子载波间隔在数值上等于OFDM Symbol的倒数。由于OFDM Symbol变长了，单个子载波带宽（或者说子载波间隔）从312.5KHz细化到78.125KHz。更窄的子载波间隔，允许会提供更高的频域分辨率，提升均衡能力，并且增强信道鲁棒性。如上图所示，在子载波带宽变成78.125KHz间隔后，一个20MHz信道一共可以包含256个子载波。</p><h3 id="RU-Resource-unit"><a href="#RU-Resource-unit" class="headerlink" title="RU(Resource unit)"></a>RU(Resource unit)</h3><p>在802.11ax中，一个最小的时频单位为RU。与LTE中的RE（Resource Element）和RB（Resource Block）不同，LTE中的RE和RB都是一个固定值，我们列举如下：</p><ul><li>RE：时域上对应1个symbol，频域上对应1个sub-carrier。</li><li>·RB：对应时域上1个slot内（即半个子帧长度0.5ms）中，频率上对应12个sub-carrier，一般是7*12个RE。</li></ul><p>在802.11ax中RU是一个相对的概念，即存在很多种不同大小的RU，如下图所示：</p><p><img data-src="C:\Users\SimpleWang\AppData\Roaming\Typora\typora-user-images\image-20221103204300079.png" alt="image-20221103204300079"></p><p>图中，一共定义了6中RU类型，分别是26，52，106，242，484以及996个子载波的RU。</p><h2 id="导频子载波"><a href="#导频子载波" class="headerlink" title="导频子载波"></a>导频子载波</h2><p>导频子载波是用来做信道估计的，利用估计出的信道系数完成解调的工作。信道估计目前理解应该就是<strong>估计信道系数h</strong>，即如果发送信号已知，比如说x，理论上的接收信号应该是<strong>y&#x3D;h*x+n</strong>，假设n&#x3D;0，即不考虑噪声，那么信道系数就可以等于<strong>h&#x3D;y&#x2F;x</strong>。如果这个时候我们可以测量接收信号y^，那么就可以获得信道系数h^&#x3D;y^&#x2F;x。同时在一般使用中，我们强调<strong>导频都是一个序列</strong>，即一个已知序列，然后我们是采用相关的方法来进行上述的操作的。主要好处在于，首先相当于多个时刻的值做叠加，更稳定一些，同时由于噪声与设置的序列一般是无关的，那么其相关值即趋近与0，所以也能够避免噪声的干扰，增加准确性。</p><p><strong>在802.11协议中，基本都是固定子载波作为导频</strong>，并且用其作为信道估计。同时除了导频，802.11协议中也会采用<strong>LTF（长训练字段）</strong>做一个粗估计，方法也是同样采用固定的序列。</p><p>由于802.11ax还是一个分布式接入的工作，所以Pilot是包含在每一个RU内部的。</p><p>在802.11中，始终是用特定的子载波作为导频子载波，从而完成信道估计的功能，在802.11ax中，导频子载波的分配如下：</p><p><img data-src="C:\Users\SimpleWang\AppData\Roaming\Typora\typora-user-images\image-20221103204854641.png" alt="image-20221103204854641"></p><p>其中红色的直线即代表导频子载波的位置，其导频资源是均匀分布在整个信道上的。比如在RU为26个子载波的情况下，每一个RU中都包含了2个pilot，在RU为52个子载波的情况下，每一个RU包含4个pilot。通过这些pilot的设置，在传输过程中，接收方才可以有效地估计信道，并完成解调的工作。</p><p>对于导频的插入，OFDM和OFDMA的导频插入方式基本是一样的。但是对于不同的场景有不同的插入方式。</p>]]></content:encoded>
      
      
      
      
      <comments>http://singlewang.top/2022/11/03/OFDMA/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title></title>
      <link>http://singlewang.top/2022/11/03/netfilter%E5%A4%9A%E6%A0%B8%E7%BB%91%E5%AE%9A/</link>
      <guid>http://singlewang.top/2022/11/03/netfilter%E5%A4%9A%E6%A0%B8%E7%BB%91%E5%AE%9A/</guid>
      <pubDate>Thu, 03 Nov 2022 12:59:20 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;以下内容参考来源与一篇论文《一种基于X86架构的多核绑定技术》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;netfilter多核绑定&quot;&gt;&lt;a href=&quot;#netfilter多核绑定&quot; class=&quot;headerlink&quot; title=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>以下内容参考来源与一篇论文《一种基于X86架构的多核绑定技术》</p></blockquote><h2 id="netfilter多核绑定"><a href="#netfilter多核绑定" class="headerlink" title="netfilter多核绑定"></a>netfilter多核绑定</h2><p>当数据堆被分配完成后，内核调用<code>ip_rcv()</code>函数对所有的数据包进行检测后进入<code>Netfilter</code>数据包检测流程。</p><p>多核绑定的技术主要是将某个线程绑定到指定的CPU上核上，确认绑定后，该进程的执行过程都在一个指定的一个或多个CPU上进行调度。</p><p><code>ip_rcv</code>函数是<code>netfilter</code>的起始调用函数，是内核协议栈函数。只需要将该函数多线程化，然后将每个线程绑定到单独的核上。</p><p>通过<code>kthread_create(int)(*threadfn)(void *data),void *data,const char *namefmt,···)</code>创建内核线程，线程创建后需要将kthread_create()返回的<code>task_struct</code>指针传给<code>wake_up_process</code>，然后通过此函数运行线程。<code>kbind()</code>绑定内核线程到指定的核，绑定成功后会在n个绑定的核上执行独立的netfilter，</p><blockquote><p>在处理netfilter连接跟踪时，保证所有核上执行的netfilter使用的都是同一个连接跟踪结构，不会破坏数据包连接跟踪的一致性。</p></blockquote><p>基于多核绑定技术架构图：</p><p><img data-src="C:\Users\SimpleWang\AppData\Roaming\Typora\typora-user-images\image-20221103202234404.png" alt="image-20221103202234404"></p><h2 id="DMA队列映射"><a href="#DMA队列映射" class="headerlink" title="DMA队列映射"></a>DMA队列映射</h2><p>Linux2.6.11版本内核中网卡接收数据的流程：</p><ol><li>数据到达网卡</li><li>网卡立刻产生一个中断指令发送给CPU</li><li>CPU执行I&#x2F;O指令，从网卡I&#x2F;O区域中去读取数据。</li></ol><p>但是这种网卡驱动存在两个性能问题：</p><ul><li><p>针对大流量数据的接收，网卡会产生大量的中断，CPU在中断上下文中频繁操作，会浪费大量的系统资源来处理中断本身。可以使用<em><strong>轮询技术NAPI</strong></em>。该技术有两个重要步骤：</p><ol><li><p>内核屏蔽网卡中断</p></li><li><p>内核设定一定时间自动访问网卡</p></li></ol></li><li><p>传统网卡驱动每次访问I&#x2F;O区域的数据时都需要CPU去存取。该操作会消耗大量CPU资源。可以采取的一种方法是<em><strong>在内存中建立一个环形缓冲队列，使用DMA控制器建立队列与网卡的映射关系，进而是网卡数据的存取工作完全由DMA控制器接管</strong></em>，具体步骤如下：</p><ol><li>内核在主内存中为收发数据建立一个环形的缓冲队列（通常叫<strong>DMA环形缓冲区</strong>），用<strong>SKB</strong>来描述一个数据缓冲，建立多个SKB,然后将他们组织成一个环形双向链表。</li><li>内核调用函数<code>dma_map_single</code>,将这个双向链表<code>DMA Buffer</code>缓冲队列与网卡映射。</li><li>网卡收到数据，就直接放进这个环形缓冲区，也就是主内存，然后向系统产生一个<strong>中断</strong>。</li><li>内核收到数据，取消DMA映射，接下来内核就可以直接从主内存中读取数据。</li></ol></li></ul>]]></content:encoded>
      
      
      
      
      <comments>http://singlewang.top/2022/11/03/netfilter%E5%A4%9A%E6%A0%B8%E7%BB%91%E5%AE%9A/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>IP协议</title>
      <link>http://singlewang.top/2022/09/28/mobile-communication/IP%E7%9B%B8%E5%85%B3/</link>
      <guid>http://singlewang.top/2022/09/28/mobile-communication/IP%E7%9B%B8%E5%85%B3/</guid>
      <pubDate>Wed, 28 Sep 2022 12:16:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;TCP&amp;#x2F;IP的心脏是网络层，这一层主要由IP和ICMP两个协议组成。&lt;/p&gt;
&lt;h2 id=&quot;IP协议-网际协议&quot;&gt;&lt;a href=&quot;#IP协议-网际协议&quot; class=&quot;headerlink&quot; title=&quot;IP协议-网际协议&quot;&gt;&lt;/a&gt;IP协议-网际协议&lt;/h</description>
        
      
      
      
      <content:encoded><![CDATA[<p>TCP&#x2F;IP的心脏是网络层，这一层主要由IP和ICMP两个协议组成。</p><h2 id="IP协议-网际协议"><a href="#IP协议-网际协议" class="headerlink" title="IP协议-网际协议"></a>IP协议-网际协议</h2><h3 id="IP相当于OSI的第三层"><a href="#IP相当于OSI的第三层" class="headerlink" title="IP相当于OSI的第三层"></a>IP相当于OSI的第三层</h3><p>网络层的主要作用是实现<strong>“终端节点之间的通信”</strong>，也叫做<em>点对点通信</em>，网络层的下一层数据链路层的作用在互连同一种数据链路的节点之间进行包传递。</p><h3 id="网络层与数据链路层的关系"><a href="#网络层与数据链路层的关系" class="headerlink" title="网络层与数据链路层的关系"></a>网络层与数据链路层的关系</h3><p>数据链路层提供两个直连设备的通信，而IP则负责在没有直连的两个网络之间进行通信。</p><h2 id="IP基础知识"><a href="#IP基础知识" class="headerlink" title="IP基础知识"></a>IP基础知识</h2><p>IP大致分为三大作用模块，分别是IP寻址、路由以及IP分包与组包。</p><h3 id="IP地址属于网络层地址"><a href="#IP地址属于网络层地址" class="headerlink" title="IP地址属于网络层地址"></a>IP地址属于网络层地址</h3><p>在TCP&#x2F;IP通信中所有主机或路由器必须设定自己的IP地址。在网桥或集线器等物理层或数据链路层转发设备中，不需要设置IP地址。</p><h3 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h3><p>路由控制是指将分组数据发送到最终目的地址的功能。<br>一跳是指利用数据链路层以下分层的功能传输数据帧的一个区间。</p><p>为了将数据包发给目标主机，所有主机都维护着一张路由控制表，该表记录IP数据在下一步应该发给哪个路由器。</p><h3 id="IP属于面向无连接型"><a href="#IP属于面向无连接型" class="headerlink" title="IP属于面向无连接型"></a>IP属于面向无连接型</h3><p>IP面向无连接，即在发包之前不需要建立与对端目标地址之间的连接。原因是：</p><ol><li>简化</li><li>提速</li></ol><p>IP提供尽力服务，上一层的TCP采用面向有连接型</p><h2 id="IP地址的基础知识"><a href="#IP地址的基础知识" class="headerlink" title="IP地址的基础知识"></a>IP地址的基础知识</h2><p>IP地址由网络号和主机号两部分组成。在相同的网络号下不能有相同的主机号，在整个互连的网络中，IP地址具有唯一性。</p><p>IP地址分为A、B、C、D四类:</p><ol><li>A类地址首位以0开头，网络号为1~8位，一个网段内可容纳16777214个主机地址</li><li>B类地址前两位以10开始，网络号位1~16位，一个网段内可容纳65534个主机。</li><li>C类地址以110开始，网络号位1~24位，一个网段内可容纳254个主机地址</li><li>D类地址以1110开始，网络号位1~32位，没有主机号，常被用于多播。</li></ol><p><strong>广播地址</strong><br>广播地址即IP主机地址部分全部为1。<br>分为本地广播和直接广播。<br>路由器不转发广播的包。</p><p><strong>IP多播</strong><br>多播用于将包发送给特定组内的所有主机。同时发送能够提高效率。<br>多播使用D类地址，对于多播，所有的主机必须属于224.0.0.1的组，所有的路由器必须属于224.0.0.2的组。</p><p><strong>路由控制</strong><br>路由控制表中记录着网络地址与下一步应该发送至路由器的地址</p><p>默认路由：0.0.0.0&#x2F;0<br>主机路由：IP地址&#x2F;32，意味整个IP地址所有位都将参与路由。多被用于不希望通过网络地址路由的情况<br>环回地址：127.0.0.1.与该地址具有相同意义的是一个叫做localhost的主机名。使用这个IP或主机名时，数据包不会流向网络。</p><h2 id="IP分割处理与再构成处理"><a href="#IP分割处理与再构成处理" class="headerlink" title="IP分割处理与再构成处理"></a>IP分割处理与再构成处理</h2><p>任何一台主机都有必要对IP分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发出去才会处理。<br>报文重组只能由目标机进行。路由器只做分片不进行重组</p><p><strong>路径MTU发现</strong><br>路径MTU是指从发送端主机到接收端主机之间不需要分片时最大MTU的大小。而路径MTU发现从主机按照路径MTU的大小将数据报分片后进行发送，可以避免在中途的路由器进行分片。</p><h2 id="IPV4首部"><a href="#IPV4首部" class="headerlink" title="IPV4首部"></a>IPV4首部</h2><p>IP头部长度为20字节，其中包括：</p><ol><li><strong>首部长度</strong>,由4比特构成，单位为4字节。对于没有可选项的IP包，首部长度设置为”5”，当没有可选项时IP首部为20字节</li><li><strong>区分服务TOS</strong>,由8比特构成，表明服务指令</li><li><strong>总长度</strong>，表示IP首部与数据部分合起来的总字节数，长16比特。IP包的最大长度为65535</li><li><strong>标识ID</strong>，由16比特构成，用于分片重组。同一个分片的标识相同，每发送一个IP包，它的值也逐渐递增。</li><li><strong>标志Flags</strong>，由3比特构成，表示包被分片的相关信息。</li><li><strong>片偏移</strong>,由13比特构成，用来标识被分片的每一个分段相对于原始数据的位置。</li><li><strong>生存时间</strong>，由8比特构成，指可以中转多少个路由器，每经过一个路由器，TTL减少1，直到变成0丢弃该包。</li><li><strong>协议</strong>，由8比特构成，标识IP首部的下一个首部属于哪个协议。</li><li><strong>首部校验和</strong>，由16比特构成，只校验数据包的首部，不校验数据部分，主要用来保护IP数据报不被破坏。</li><li><strong>源地址</strong></li><li><strong>目的地址</strong></li><li><strong>可选项</strong></li><li><strong>填充</strong>，在有可选项的情况下，首部长度可能不是32比特的整数倍，通过此字段填充0.</li><li><strong>数据</strong>，存入数据。</li></ol>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/mobile-communication/">移动通信</category>
      
      
      <category domain="http://singlewang.top/tags/IP/">IP</category>
      
      <category domain="http://singlewang.top/tags/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/">无线通信</category>
      
      
      <comments>http://singlewang.top/2022/09/28/mobile-communication/IP%E7%9B%B8%E5%85%B3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>套接字编程简介</title>
      <link>http://singlewang.top/2022/09/28/UNIX-netcoding/%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</link>
      <guid>http://singlewang.top/2022/09/28/UNIX-netcoding/%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</guid>
      <pubDate>Wed, 28 Sep 2022 11:47:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;socket函数&quot;&gt;&lt;a href=&quot;#socket函数&quot; class=&quot;headerlink&quot; title=&quot;socket函数&quot;&gt;&lt;/a&gt;socket函数&lt;/h3&gt;&lt;p&gt;为了执行网络I&amp;#x2F;O，一个进程必须做的第一件事情就是调用socket函数，指定期望的</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h3><p>为了执行网络I&#x2F;O，一个进程必须做的第一件事情就是调用socket函数，指定期望的通信协议类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> family,<span class="type">int</span> type,<span class="type">int</span> protocol)</span>;<span class="comment">//成功返回非负的描述符，出错则为-1</span></span><br></pre></td></tr></table></figure><p>family参数为协议族，type为套接字类型，protocol为某个协议类型常值。</p><p><em>family常值有：</em><br>AF_INET       IPV4协议<br>AF_INET6      IPV6协议<br>AF_LOCAL      UNIX域协议<br>AF_ROUTE      路由套接字<br>AF_KEY        密钥套接字</p><p><em>type常值有：</em><br>SOCK_STREAM        字节流套接字<br>SOCK_DGRAM         数据报套接字<br>SOCK_SEQPACKET     有序分组套接字<br>SOCK_RAW           原始套接字</p><p><em>protocol常值有：</em><br>IPPROTO_CP         TCP传输协议<br>IPPROTO_UDP        UDP传输协议<br>IPPROTO_SCTP       SCTP传输协议</p><p>socket函数成功时返回一个小的非负整数值，称为<em>套接字描述符</em>，简称<em>sockfd</em>。</p><p><strong>AF_XXX和PF_XXX</strong></p><blockquote><p>AF_前缀表示地址族，PF前缀表示协议族。</p></blockquote><h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><p>TCP客户用connect函数来建立与TCP服务器的连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">const</span> <span class="keyword">struct</span> sockaddr* servaddr,<span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>客户在调用connect函数前不必非要调用bind函数，如果需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。</p><p>调用connect函数会激发TCP的<strong>三次握手</strong>,出错返回有以下几种情况：</p><ol><li>若客户没有收到SYN分节的响应，则返回ETMIEOUT.</li><li>若对客户的SYN的响应时RST,则表明该服务器主机在我们指定的端口上没有进程在等待与之连接。返回ECONNREFUSED。<blockquote><p>产生RST的条件是：</p><ul><li>目的地为某端口的SYN到达，然而该端口上没有正在监听的服务器。</li><li>TCP想取消一个已有连接。</li><li>TCP收到一个根本不存在的连接上的分节</li></ul></blockquote></li><li>客户发出的SYN在某个路由器上引发了“目的地不可达”ICMP错误，则认为是一种软错误。返回EHOSTUNREACH或ENETUNREACH.</li></ol><h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><p>bind函数把一个本地地址赋予一个套接字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">const</span> <span class="keyword">struct</span> sockaddr *myaddr,<span class="type">socklen_t</span> addrlen)</span>;<span class="comment">//成功返回0，出错返回-1；</span></span><br></pre></td></tr></table></figure><p>第二个参数指向特定于协议的地址结构的指针，第三个参数是该地址结构的长度。对于TCP,bind函数可以指定一个端口号，或指定一个IP地址，也可以二者都指定或都不指定。</p><p>假如不指定端口时，内核会给它一个临时端口。为了得到这个临时端口值，必须调用函数<code>getsockname</code>返回协议地址。</p><h3 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h3><p>listen函数仅由TCP服务器调用，主要有两个作用：</p><ol><li>linsten函数把一个未连接的套接字转换成为一个被动套接字。调用listen导致套接字从CLOSED状态转换到LISTEN状态。</li><li>本函数的第二个参数规定了内核应该为相应套接字排队的最大连接个数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">int</span> backlog)</span>;<span class="comment">//成功返回0，出错返回-1.</span></span><br></pre></td></tr></table></figure>本函数通常应该在调用socket和bind函数之后，在accept之前。</li></ol><h3 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h3><p>accept函数由TCP服务器调用，用于完成连接队列头返回下一个已完成连接。如果已完成连接队列为空，那么进程被投入睡眠。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd,<span class="keyword">struct</span> sockaddr *cliaddr,<span class="type">socklen_t</span> *addrlen)</span>;<span class="comment">//成功返回非负描述符，出错返回-1.</span></span><br></pre></td></tr></table></figure><p>cliaddr和addrlen用来返回已连接的客户端进程的协议地址。</p><h3 id="fork和exec函数"><a href="#fork和exec函数" class="headerlink" title="fork和exec函数"></a>fork和exec函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unisted.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//在子进程中为0，在父进程中为子进程ID,出错返回-1.</span></span><br></pre></td></tr></table></figure><p>fork函数用来派生新进程。<br>调用一次，返回两次。在父进程中返回一次，返回值时子进程的进程ID号，在子进程返回一次，返回值是0。子进程可以通过调用<code>getppid</code>获取父进程的进程ID.</p><p>fork有两个典型用法</p><ol><li>一个进程创建一个自身的副本，每个副本都可以在另一个副本执行其他任务的同时处理各自的某个操作。</li><li>一个进程想要执行另一个程序。</li></ol><p>exec函数把当前进程映像替换成新的程序文件，而且该新进程通常从main函数开始执行。进程ID并不改变。称调用exec的进程为<em>调用进程</em>。</p><h3 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h3><p>通常用close函数关闭套接字，并终止TCP连接。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/UNIX-netcoding/">UNIX网络编程</category>
      
      
      <category domain="http://singlewang.top/tags/UNIX/">UNIX</category>
      
      <category domain="http://singlewang.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</category>
      
      
      <comments>http://singlewang.top/2022/09/28/UNIX-netcoding/%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>套接字编程</title>
      <link>http://singlewang.top/2022/09/26/UINX-envcoding/UINX-%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/</link>
      <guid>http://singlewang.top/2022/09/26/UINX-envcoding/UINX-%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/</guid>
      <pubDate>Mon, 26 Sep 2022 13:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;文件和目录&quot;&gt;&lt;a href=&quot;#文件和目录&quot; class=&quot;headerlink&quot; title=&quot;文件和目录&quot;&gt;&lt;/a&gt;文件和目录&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;文件系统&lt;br&gt;UINX所有东西的起点称为&lt;code&gt;root&lt;/code&gt;的目录，这个目录的名称是一个</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><ol><li>文件系统<br>UINX所有东西的起点称为<code>root</code>的目录，这个目录的名称是一个<code>/</code>字符。</li><li>文件名<br>目录中的各个名字称为文件名，只有<code>/</code>和空字符不能出现在文件名中。<br><code>.</code>指向当前目录，<code>..</code>指向父目录。</li><li>路径名<br>以斜线开头的路径称为<strong>绝对路径名</strong>，否则称为<strong>相对路径名</strong>。相对路径名指向相对于当前目录的文件。</li></ol><h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><ol><li>文件描述符</li></ol><p><strong>文件描述符</strong>通常是一个小的非负整数，内核用以标识一个特定进程正在访问的文件。当内核打开一个现有文件或创建一个新文件时，都会返回一个文件描述符<br>2. 不带缓冲的I&#x2F;O<br>函数<code>open、read、write、lseek、close</code>提供了不带缓冲的I&#x2F;O.</p><h3 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h3><ol><li>程序<br>程序指存储在某个目录中的可执行文件。</li><li>进程和进程ID<br>程序的执行实例被称为<strong>进程</strong>，UNIX确保每个进程都有一个唯一的数字标识符，称为<strong>进程ID</strong>。进程ID是一个非负整数。</li><li>进程控制<br>三个用于进程控制的主要函数：<code>fork、exec、waitpid</code>。<br>fork创建一个新进程。新进程时调用进程的一个副本，称调用进程为父进程，新创建的进程为子进程。fork对父进程返回新的子进程的进程ID,对子进程则返回0。</li></ol><p>wait返回子进程的终止状态，其参数为要等待的进程。<br>4. 线程和线程ID<br>通常一个进程只有一个控制线程。一个进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性。线程ID只在它所属的进程内起作用。</p><h3 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h3><p>UNIX系统函数出错时，通常会返回一个负值。<br>C标准定义了两个函数，用于打印出错信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;</span><br></pre></td></tr></table></figure><p>strerror将errnum映射为一个出错消息字符串，返回此字符串的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span></span><br></pre></td></tr></table></figure><p>首先输出由msg指向的字符串，然后指对于errno的出错消息</p><h3 id="时间值"><a href="#时间值" class="headerlink" title="时间值"></a>时间值</h3><p><strong>进程时间</strong>用以度量进程使用的中央处理器资源。以时钟滴答计算。<br>用clock_t保存这种时间值。<br>当度量一个进程的执行时间时，UNIX为一个进程维护三个进程时间值：</p><ul><li>时钟时间</li><li>用户CPU时间</li><li>系统CPU时间</li></ul><p>时钟时间时进程运行的时间总量，其值与系统中同时运行的进程数有关。<br>用户CPU时间时钟执行用户指令所用的时间量。<br>系统CPU时间时为该进程执行内核程序所经历的时间。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%EF%BC%8C%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">UNIX环境编程，第一章基础知识</category>
      
      
      <category domain="http://singlewang.top/tags/UNIX/">UNIX</category>
      
      <category domain="http://singlewang.top/tags/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">高级编程</category>
      
      
      <comments>http://singlewang.top/2022/09/26/UINX-envcoding/UINX-%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>IP协议相关技术</title>
      <link>http://singlewang.top/2022/09/26/mobile-communication/IP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/</link>
      <guid>http://singlewang.top/2022/09/26/mobile-communication/IP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/</guid>
      <pubDate>Mon, 26 Sep 2022 13:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;DNS&lt;/strong&gt;&lt;br&gt;DNS就是一个域名解析，主要是为了将容易记住的域名解析为不容易记住的IP地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ARP&lt;/strong&gt;&lt;br&gt;ARP是地址解析协议，主要是把IP地址映射成为下一个应该接收数据包的网络设备对应的M</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>DNS</strong><br>DNS就是一个域名解析，主要是为了将容易记住的域名解析为不容易记住的IP地址。</p><p><strong>ARP</strong><br>ARP是地址解析协议，主要是把IP地址映射成为下一个应该接收数据包的网络设备对应的MAC地址。如果目标主机不在同一个链路上，可以通过ARP查找下一跳路由器的MAC地址。</p><p>工作机制：从一个IP地址发送一个ARP请求包了解接收方的MAC地址，目标地址将自己的MAC地址填入ARP响应包返回到发送方。</p><p>通常会把获得的MAC地址缓存到一张ARP缓存表中，以便后续直接进行发送。每执行依次ARP，对应的缓存内容都会被清除。</p><p><strong>RARP</strong><br>RARP是将ARP反过来，从MAC地址获得IP地址</p><p><strong>ICMP</strong><br>ICMP的主要功能包括：</p><ol><li>确定IP包是否成功送达目标地址</li><li>通知在发送过程中IP包被废弃的具体原因。</li><li>改善网络设置</li></ol><blockquote><p>通常ping包就是ICMP协议</p></blockquote><p>ICMP消息大致分为两类：</p><ol><li>通知出错原因的错误消息</li><li>用于诊断的查询消息</li></ol><p>主要的ICMP消息：</p><ol><li>ICMP目标不可达<br>主要出现在IP路由器无法将IP数据包发送给目标地址时，会给发送端主机返回一个<em>目标不可达</em>的ICMP消息。</li><li>ICMP重定向消息<br>如果路由器发现发送端主机使用了次优的路径发送数据，就会返回一个<em>ICMP重定向</em>，消息中包含了最合适的路由信息和源数据。</li><li>ICMP超时消息<br>IP包中有一个字段叫做TTL，它的值每经过一次路由就会减一，到0时改包就会被丢弃。此时IP路由器将会发送一个ICMP超时的消息给发送端主机，并通知该包已被丢弃。</li><li>ICM回送消息<br>用于进行通信的主机或路由器之间，判断所发哦那个的数据包是否已经成功到达对端的一种消息。网络上常用的<code>ping</code>命令就是利用这个消息实现的。</li></ol><p><strong>DHCP</strong><br>DHCP为了实现自动设置IP地址，统一管理IP地址分配。有了DHCP只要计算机连接到网络，就可以进行TCP&#x2F;IP通信。</p><p><strong>IP隧道</strong><br>在网络层的首部后面继续追加网络层首部的通信方法就叫做<em>IP隧道</em>。也就是IP首部的后面还是IP首部，IP首部的后面是IPv6的首部。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/TCP-IP/">TCP/IP</category>
      
      
      <category domain="http://singlewang.top/tags/IP/">IP</category>
      
      
      <comments>http://singlewang.top/2022/09/26/mobile-communication/IP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>套接字编程简介</title>
      <link>http://singlewang.top/2022/09/26/UNIX-netcoding/UNIX-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <guid>http://singlewang.top/2022/09/26/UNIX-netcoding/UNIX-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <pubDate>Mon, 26 Sep 2022 11:47:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;套接字编程&quot;&gt;&lt;a href=&quot;#套接字编程&quot; class=&quot;headerlink&quot; title=&quot;套接字编程&quot;&gt;&lt;/a&gt;套接字编程&lt;/h2&gt;&lt;h3 id=&quot;IPV4套接字地址结构&quot;&gt;&lt;a href=&quot;#IPV4套接字地址结构&quot; class=&quot;headerlink</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h2><h3 id="IPV4套接字地址结构"><a href="#IPV4套接字地址结构" class="headerlink" title="IPV4套接字地址结构"></a>IPV4套接字地址结构</h3><p>ipv4套接字地址结构通常也称为“网际套接字地址结构”，以<code>sockaddr_in</code>命名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> sin_len;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;  <span class="comment">//无符号短整数</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;  <span class="comment">//</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="通用套接字地址结构"><a href="#通用套接字地址结构" class="headerlink" title="通用套接字地址结构"></a>通用套接字地址结构</h3><p>当作为一个参数传递进任何套接字函数时，套接字地址总是以引用形式来传递。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> sa_len;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ul><li>从进程到内核传递套接字结构的函数有三个：<code>bind、connect、sendto</code>。</li><li>从内核到进程传递套接字地址结构的函数有4个：<code>accept、recvfrom、getsockname、getpeername</code>。</li></ul></blockquote><h3 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h3><p>内存中存储有两种方式:</p><ul><li>小端字节序，低序字节存储在低地址</li><li>大端字节序，高序字节存储在低地址<br>我们某个给定系统所用的字节称为<strong>主机字节序</strong>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*输出主机字节序*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;udp.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">short</span> s;</span><br><span class="line">        <span class="type">char</span>  c[<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125;un;</span><br><span class="line">    un.s=<span class="number">0x0102</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s:&quot;</span>,CPU_VENDOR_OS);<span class="comment">//CPU_VENDOR_OS标识了CPU类型、厂家、操作系统版本</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">sizeof</span>(<span class="type">short</span>==<span class="number">2</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;un.c[<span class="number">1</span>]==<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;big-endian\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">2</span>&amp;&amp;un.c[<span class="number">1</span>]==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;little-endian\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;unknown&quot;</span>\n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网络协议也必须指定一个网络字节序，使用如下四个函数进行两个字节序之间的转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> host16bitvalue)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> host32bitvalue)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> net16bitvalue)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> net32bitvalue)</span>;</span><br></pre></td></tr></table></figure><h3 id="字节操纵函数"><a href="#字节操纵函数" class="headerlink" title="字节操纵函数"></a>字节操纵函数</h3><p>字节操纵函数不对数据做解释，也不假设数据是以空字符串结束的C字符串。</p><p>Berkely函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bzero</span><span class="params">(<span class="type">void</span> *dest,<span class="type">size_t</span> nbytes)</span>;<span class="comment">//将目标字节串中指定数目的字节置为0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bcopy</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *src,<span class="type">void</span> *dest,<span class="type">size_t</span> nbyte)</span>;<span class="comment">//将指定数目的字节从源字节串移到目标字节串</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptrl,<span class="type">const</span> <span class="type">void</span> *ptr2,<span class="type">size_t</span> nbyte)</span>;<span class="comment">//比较两个任意的字节串，相同返回0</span></span><br></pre></td></tr></table></figure><p>ANSI C 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *dest,<span class="type">int</span> c,<span class="type">size_t</span> len)</span>;<span class="comment">//将目标字节串中指定数目的字节置为c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memcpy</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *dest,<span class="type">void</span> *src,<span class="type">size_t</span> nbyte)</span>;<span class="comment">//将指定数目的字节从源字节串移到目标字节串,与bcopy的源和目的相反。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptrl,<span class="type">const</span> <span class="type">void</span> *ptr2,<span class="type">size_t</span> nbyte)</span>;<span class="comment">//比较两个任意的字节串，相同返回0，否则返回一个非0值，若ptrl字节串大于ptr2，则大于0，反之小于0</span></span><br></pre></td></tr></table></figure><p><strong>inet_aton、inet_addr、inet_ntoa</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *strptr,<span class="keyword">struct</span> in_addr *addptr)</span>;<span class="comment">//将点分十进制串转换成32位的网络字节序二进制值，通过指针addrptr存储，陈工返回1。</span></span><br><span class="line"></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *strptr)</span>;<span class="comment">//进行相同的转换，返回值为32位的网络字节序二进制值。但是不能处理ipv4的广播地址。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_ntoa</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> inaddr inaddr)</span>;<span class="comment">//将一个32位的网络字节序二进制ipv4地址转换成相应的点分十进制。</span></span><br></pre></td></tr></table></figure><p><strong>inet_pton、inet_ntop</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> family,<span class="type">const</span> <span class="type">char</span> *strptr,<span class="type">void</span> *addrptr)</span>;<span class="comment">//转换由strptr指向的字符串，通过addrptr指针存放二进制结果。成功返回1，</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> family,<span class="type">const</span> <span class="type">void</span> *addrptr,<span class="type">char</span> *strptr,<span class="type">size_t</span> len)</span>;<span class="comment">//与inet_pton相反。</span></span><br></pre></td></tr></table></figure><p><strong>readn、write、readline</strong></p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/UNIX-netcoding/">UNIX网络编程</category>
      
      
      <category domain="http://singlewang.top/tags/UNIX/">UNIX</category>
      
      <category domain="http://singlewang.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</category>
      
      
      <comments>http://singlewang.top/2022/09/26/UNIX-netcoding/UNIX-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>终于等到你，还好我没放弃</title>
      <link>http://singlewang.top/2022/08/14/informal-essay/life/%E7%BB%88%E4%BA%8E%E7%AD%89%E5%88%B0%E4%BD%A0/</link>
      <guid>http://singlewang.top/2022/08/14/informal-essay/life/%E7%BB%88%E4%BA%8E%E7%AD%89%E5%88%B0%E4%BD%A0/</guid>
      <pubDate>Sun, 14 Aug 2022 15:30:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;时间把你和我变成我们&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;&lt;em&gt;&lt;strong&gt;因为有你&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;&lt;em&gt;&lt;strong&gt;所以步履不停&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;今天，我终于和我心心念念的那个女孩儿在一起了。我等了这</description>
        
      
      
      
      <content:encoded><![CDATA[<p><em><strong>时间把你和我变成我们</strong></em><br><em><strong>因为有你</strong></em><br><em><strong>所以步履不停</strong></em><br>今天，我终于和我心心念念的那个女孩儿在一起了。我等了这一刻太久太久，如果用一句歌词来形容的话，可能就是“终于等到你，还好我没放弃~”，她叫韩林秀，听名字就知道是一个知书达理的女孩，我和她的故事从初二开始，想听吗？那就搬上你的小板凳，听我娓娓道来。</p><p>10年前，有个初二的学生因为学习原因被父亲转了班级，并不是他学习不好，他是那个班的第一，只是因为那个班的学习氛围不好，他的爸爸为了让他有一个更好的成绩，有一个更好的前途，给他安排了转班。尽管有百般不舍，毕竟谁也不愿意突然转到一个陌生的班级，重新认识一些不认识的同学，属实难为这个学生了，但是碍于父亲的强势，不得已转了班级。那天，他走的很静，在班级里没有留下什么惊涛骇浪，只是第二天同学们才发现他的桌仓已经空了。可他却不知道，这次转班却会让他认识生命中胜似亲人重要的一个人。</p><p>转的班级并没有影响他的学习，还是像往常一样早早的来到新转的班级晨读，直到吃早饭的时候，”可以麻烦你交一下语文作业吗？”，他猛然抬头，映入眼帘的是一位清纯可爱的女生，眼睛很好看，笑起来也好看，那一刻，他发现自己已经沉沦在她的微笑中，沉迷于她灵动的眼睛。尽管就是这普普通通的一眼，就已经注定了和她的故事不可能普普通通。没错这位女生就是我的女朋友，这个转班的同学就是我。我和她的故事开始于庆城中学的八年级4班。这时起我就开始默默关注着她，她的一举一动，一颦一笑都会使我的心神荡漾。</p><p>从我们相识到现在已经有了差不多10年，韩林秀–一个刻在我骨子里的名字，从我见到她的那一刻起，我就觉得我注定要和她发生些什么。有人说，爱情是人的自由意志的沉沦，确实如此，有时候爱情就是这么不讲道理，但正因为如此，才使得那么多人向往，无数人幻想着能收获属于自己的那一份甜甜的爱情，我也不例外，但是在今天，一直以来出现在我梦中的她终于走进了现实。</p><p>&#x2F;<em><strong>过去</strong></em>&#x2F;<br>有些遗憾的是，在高中时期，那个情窦初开的时期，我们没能在一个班级，我在1班，她在4班，虽然隔了不远，但是却让我们有了些许距离，我不知道她的日常，她呢，也不了解我的生活，只是偶尔的碰面会让我们寒暄几句。我隐藏着自己对她的爱慕，但也仅仅只是对她隐藏了，毕竟我周围的同学也已经知道我喜欢她，常常调侃到“王力恒的心，路人皆知。”我也没有去争些什么，毕竟这是事实，我就是喜欢她，我想得到她的关注，于是我当了班长，想着能够凭借这个机会和她多有些接触。有时候和她短短的几句话就能让我开心一整天。运动会的开幕式有她的节目，我还特意拿着相机去拍她，我不在意别人的目光，我在意的只有她。还有运动会期间，她在写给运动员的加油词，我也想拍她，但是又怕被发现，现在想想真是为我的怂而着急。但还是让我同学帮忙拍了几张，现在还在我的电脑中。可尽管如此我们能够相处的时间还是太短，毕竟我们不在一个班级。时间就如白驹过隙般从笔尖溜走，写下的是充满期冀的未来。高三的时间更是飞快，整天就是刷题，考试，讲试卷。不过她也找过我讲题，那我当然得好好表现一下了，毕竟谁不想在自己喜欢的女生面前出风头呢。可我又怕自己讲错，那可就尴尬了。不过所幸她问的题也不是很难，我讲的很慢，一是怕她听不明白，二还是想多珍惜和她相处的时间，因为我知道，高考过后我们见面可能真的就越来越少了。高考结束后，我们去了不同的地方，我在武汉，她在河南。就这样在我们面临的第一个重要的人生关卡，我们分道扬镳了。</p><p>当她告诉我愿意和我一起尝试一下，面对一个美好的未来的时候，我竟然有些恍惚，我掐了掐自己，我好怕这是一个梦，我怕像之前无数次那样，醒来之后，梦里的一切都化为乌有。还好，这次醒来，她真的在我身边。真的一种喜极而泣的感觉涌上心头。回想起我第一次和她正面告白的时候，应该是在大二的寒假，放假回来，她在学车，那天我鼓足勇气，和她一起走了走，我们聊了很多，可是当我要说出口的时候，她逃避了，真像一只受了惊吓的小鹿，逃进了冰天雪地的树林，哦，对了，那天刚好下了一点小雪。我在雪中迟迟不肯离去，但是我还是想对她说出我的心里话，我说了很长的一段话，虽然只有十几分钟，但是这十几分钟我却删了又说，说了又删，我忐忑，想表达我全部热烈而又真诚的爱意，却又害怕语言不得体，当颤抖的手按下发送键时，我心中充满了喜悦，那时想至少这辈子应该没有遗憾了吧。但是不出意外的话要出意外了，第一次正面的告白以失败告终。但我并不想着放弃，之后的一段时间我们断断续续的联系着，后来看见她有了男朋友，我的热情仿佛被泼了一盆冷水，本来刚刚燃起的火苗瞬间被熄灭。我知道，此时我不该再区打扰她了，于是慢慢的，我和她淡了联系。直到某天夜里，我梦见了她，我梦见她来我的学校找我，醒来之后，直觉告诉我她应该有什么事，果不其然，在后来不久我们又有了联系，与她的聊天中我知道，她分手，当得知这个消息的时候，我不知道自己该是开心还是难过，于我自己而言，我知道我又有了机会，可是与她而言，应该会很伤心吧。慢慢的我们又开始聊天，一起玩游戏，一切似乎又在朝着美好的方向发展。那时由于疫情的原因我们都在家里复习考研，所以我又鼓起勇气约她出来，想和她再一次告白，我没有了之前的胆怯，直接告诉她我的心意。但是她的回答依旧是那么斩钉截铁，说我们不可能。此时的我的心中仿佛有雨雪在冷冷的拍。我知道，我又失败了，想着又要好久才能缓过来吧。之后我们还是像往常一样聊天，但是总觉得哪里不对劲。可能是我还心存侥幸，觉得我和她还是朋友，还有机会。然而就是这份侥幸，让我又有了一份不可名状的勇气，迎来了我的第三次告白。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/informal-essay/">随笔</category>
      
      <category domain="http://singlewang.top/categories/informal-essay/life/">生活感悟</category>
      
      
      <category domain="http://singlewang.top/tags/%E5%BF%83%E5%BE%97/">心得</category>
      
      <category domain="http://singlewang.top/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/">生活感悟</category>
      
      
      <comments>http://singlewang.top/2022/08/14/informal-essay/life/%E7%BB%88%E4%BA%8E%E7%AD%89%E5%88%B0%E4%BD%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>嵌入式系统开发-ch1</title>
      <link>http://singlewang.top/2022/06/25/embedded/%E5%B5%8C%E5%85%A5%E5%BC%8F-ch1/</link>
      <guid>http://singlewang.top/2022/06/25/embedded/%E5%B5%8C%E5%85%A5%E5%BC%8F-ch1/</guid>
      <pubDate>Sat, 25 Jun 2022 12:20:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;嵌入式系统及其应用&quot;&gt;&lt;a href=&quot;#嵌入式系统及其应用&quot; class=&quot;headerlink&quot; title=&quot;嵌入式系统及其应用&quot;&gt;&lt;/a&gt;嵌入式系统及其应用&lt;/h2&gt;&lt;h3 id=&quot;嵌入式系统&quot;&gt;&lt;a href=&quot;#嵌入式系统&quot; class=&quot;header</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="嵌入式系统及其应用"><a href="#嵌入式系统及其应用" class="headerlink" title="嵌入式系统及其应用"></a>嵌入式系统及其应用</h2><h3 id="嵌入式系统"><a href="#嵌入式系统" class="headerlink" title="嵌入式系统"></a>嵌入式系统</h3><p><em>什么是嵌入式系统</em><br>嵌入式系统是嵌入式计算机系统的简称，是一种嵌入在设备（或系统）内部，为特定应用而设计开发的专用计算机系统。</p><p>&#x3D;&#x3D;特点&#x3D;&#x3D;</p><ol><li>专用性</li><li>隐蔽性</li><li>资源受限</li><li>高可靠性</li><li>实时性</li><li>软件固化</li></ol><p>广义：凡是带有微处理器的专用软硬件系统都可称为嵌入式系统<br>狭义：使用嵌入式微处理器构成的具有自己的操作系统和特定功能、用于特定场合的独立系统</p><h3 id="嵌入式系统的组成与分类"><a href="#嵌入式系统的组成与分类" class="headerlink" title="嵌入式系统的组成与分类"></a>嵌入式系统的组成与分类</h3><p><em>嵌入式系统的逻辑组成</em><br>嵌入式系统由硬件和软件两部分组成。<br>&#x3D;&#x3D;处理器&#x3D;&#x3D;<br>硬件的主体是中央处理器（Central Processing Uint,CPU）,主要负责运行系统软件和应用软件。<br>CPU的字长由4位、8位、16位、32位、64位之分，目前嵌入式系统中使用最多的是8位和16位的CPU，通用计算机的CPU则以64位为主。<br>嵌入式系统的性能很大取决于CPU,影响程序执行速度的因素包括：</p><ol><li>主频（CPU时钟频率），指CPU中门电路的工作频率，主频越高，执行指令的时间越短</li><li>指令系统</li><li>高速缓冲存储器的容量与结构</li><li>逻辑结构</li></ol><p>&#x3D;&#x3D;存储器&#x3D;&#x3D;<br>存储器：</p><ul><li>易失性存储器<ul><li>SRAM，电路复杂，集成度低，成本高，工作速度快</li><li>DRAM，电路简单，集成度高，成本低</li></ul></li><li>非易失性存储器<ul><li>EEPROM</li><li>Flash ROM</li><li>磁盘等</li></ul></li></ul><p>&#x3D;&#x3D;I&#x2F;O设备与I&#x2F;O接口&#x3D;&#x3D;<br>嵌入式常用的I&#x2F;O接口有：</p><ul><li>通用串行总线式接口：USB2.0,USB3.0,IEEE 1394,以太网接口</li><li>异步串行接口：RS-232-C,RS-485</li><li>视频信号接口：VGA,DVI,HDMI</li><li>工业总线接口：CAN,1553B,LIN接口</li><li>无线接口:蓝牙，wifi接口，zigbee接口</li></ul><p>&#x3D;&#x3D;总线&#x3D;&#x3D;<br>数据总线简称总线，是用来在嵌入式系统各组件间进行数据传输，又传输线和控制电路组成</p><p>&#x3D;&#x3D;软件&#x3D;&#x3D;<br>低端嵌入式系统软件很简单，只需配置一个监控程序，若干驱动程序和事件处理程序即可。<br>高端嵌入式系统比较复杂。通常由板级支持包、设备驱动程序、实时操作系统（核心）、中间件及嵌入式应用软件组成，以安卓软件为例，主要由4层组成。最底层是各种驱动程序和Linux内核。第二层是系统库和Android的运行环境。第三层是应用软件框架。第四层是应用程序</p><p><em>嵌入式处理芯片</em><br>嵌入式系统中的CPU一般具有4个特点</p><ol><li>支持实时处理</li><li>低功耗</li><li>结构可扩展</li><li>集成了测试电路</li></ol><p>目前嵌入式处理芯片有一下四种产品类型：</p><ol><li>微处理器</li><li>数字信号处理器</li><li>微控制器（单片机）</li><li>片上系统</li></ol><blockquote><p>第一个公认的现代嵌入式系统是20世纪60年代初美国麻省理工学院开发的阿波罗导航计算机。</p></blockquote><h2 id="嵌入式系统和数字媒体"><a href="#嵌入式系统和数字媒体" class="headerlink" title="嵌入式系统和数字媒体"></a>嵌入式系统和数字媒体</h2><h3 id="数字（电子）文本"><a href="#数字（电子）文本" class="headerlink" title="数字（电子）文本"></a>数字（电子）文本</h3><p>文字信息在计算机中统称为文本，文本是基于特定字符集的一个字符流，每个字符均使用二进制编码表示。<br><em>字符集及其编码</em></p><ol><li>西文字符的编码<br>目前使用最广泛的西文字符集及其编码是ASCII字符集和ASCII码，即美国标准信息交换码。共有128个字符，包括96个可打印字符和32个控制字符</li><li>汉字的编码<br>我国目前广泛使用的汉字编码国家标准有GB2312和GB18030</li><li>USC和Unicode编码</li></ol><p><em>文本的类型</em><br>根据是否具有排版格式可分为：</p><ul><li>简单文本</li><li>丰富格式文本<br>根据文本内容的组织方式来分：</li><li>线性文本</li><li>超文本</li></ul><p><strong>简单文本</strong>：由变大文本内容的一连串字符的编码组成，几乎不包含任何其他的格式信息和结构信息。通常称为纯文本，其文件后缀名是.txt，呈现为线性结构。<br><strong>丰富格式文本</strong>：即常说的富文本，由排版格式等<br><strong>超文本</strong>：采用网状结构来组织信息，文本中各个部分按照其内容逻辑进行连接，例如www网页。</p><h3 id="数字图像"><a href="#数字图像" class="headerlink" title="数字图像"></a>数字图像</h3><p><em>数字图像的获取和主要参数</em><br>图像获取过程的核心是模拟信号的数字化，处理过程大致分为4步：</p><ol><li>扫描</li><li>分色</li><li>取样</li><li>量化<br>图像的基本单位称为像素，彩色图像的像素通常由R、G、B三个分量组成。<br>数字图像在计算机中的表示方法是：</li></ol><ul><li>灰度图像采用一个矩阵表示</li><li>彩色图像用一组矩阵表示，每个矩阵称为一个位平面</li><li>矩阵的行数成文垂直分辨率</li><li>矩阵的列数称为水平分辨率</li></ul><p>数字图像的主要参数如下：</p><ul><li>图像大小，也叫做图像分辨率</li><li>位平面数目，像素分量的数目</li><li>像素深度，指像素用多少个二进制来表示</li><li>颜色模型，例如RGB,CMYK（打印机使用）</li></ul><p><em>数字图像常用文件格式及其应用</em><br>一幅图像的数据量按照如下公式计算（字节位单位）：<br>    <strong>图像数据量&#x3D;图像水平分辨率x图像垂直分率x像素深度&#x2F;8</strong></p><p>数据压缩分为两种类型，一种是无损压缩，另一种是有损压缩。</p><p><strong>无损压缩</strong>：指使用压缩后的数据还原图像时，与原始图像完全一样。例如行程长度编码（RLE），哈夫曼编码等。<br><strong>有损压缩</strong>：指还原的图像与原始图像有一点误差，按时不影响使用，如变换编码，矢量编码。</p><h3 id="数字音频与数字视频"><a href="#数字音频与数字视频" class="headerlink" title="数字音频与数字视频"></a>数字音频与数字视频</h3><p><em>音频&#x2F;视频的数字化</em><br>音频时20hz-20khz的的模拟信号。<br>声音信号数字化的过程如下：</p><ol><li>取样，把时间上连续的声音信号离散为不连续的一系列的样本</li><li>量化</li><li>编码</li></ol><p>视频信号以帧为单位进行，每帧彩色画面有Y（亮度）、UV(色度)三个分量。</p><p><em>数字音频常用文件格式及其应用</em><br>数字音频的主要参数：</p><ul><li>取样频率</li><li>量化位数</li><li>声道数目</li><li>压缩编码方法</li><li>比特率，也称为码率，每秒钟的数据量<br>数字音频未压缩前，码率的计算公式为：<br>  波形声音的码率&#x3D;取样频率x量化位数x声道数(b&#x2F;s)</li></ul><h2 id="数字通信与计算机网络"><a href="#数字通信与计算机网络" class="headerlink" title="数字通信与计算机网络"></a>数字通信与计算机网络</h2><h3 id="数字通信"><a href="#数字通信" class="headerlink" title="数字通信"></a>数字通信</h3><p><em>模拟通信与数字通信</em><br>通信需基本任务时传递信息，至少需要三要素组成：<br>信息的发送者（信源），信息的接收者（信宿），信息的传输通道（信道）。</p><p>通信中信息必须以电或光的形式进行传播，信号的形式有两种：<strong>模拟信号</strong>和<strong>数字信号</strong>。<br>模拟信号通过连续的物理量来表示信息。<br>数字信号电平高低或电流大小只是有限个状态。<br>第一代个人移动通信采用的是模拟传输技术。我国使用的GSM和CDMA都是第二代移动通信系统，简称2G。我国3G通信目前有三种技术标准，中国移动–TD-SCDMA,中国电信–CDMA2000,中国联通–WCDMA。</p>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/embeded/">embeded</category>
      
      
      <category domain="http://singlewang.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</category>
      
      <category domain="http://singlewang.top/tags/%E8%80%83%E8%AF%95/">考试</category>
      
      
      <comments>http://singlewang.top/2022/06/25/embedded/%E5%B5%8C%E5%85%A5%E5%BC%8F-ch1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>c++primer之语句</title>
      <link>http://singlewang.top/2022/06/25/cpp/cpp_primer_ch5/</link>
      <guid>http://singlewang.top/2022/06/25/cpp/cpp_primer_ch5/</guid>
      <pubDate>Sat, 25 Jun 2022 11:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h2&gt;&lt;h3 id=&quot;简单语句&quot;&gt;&lt;a href=&quot;#简单语句&quot; class=&quot;headerlink&quot; title=&quot;简单语句&quot;&gt;&lt;/a&gt;简单语句&lt;/h</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h3><p>正常人都知道一些简单语句，不再赘述。<br><em>空语句</em><br>空语句只有一个单独的分号<br>eg：<code>;</code><br>常见情况是，当循环的全部工作在条件部分可以完成时，通常使用空语句。</p><p><em>别漏写分号，也别多写分号</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(iter!=a.<span class="built_in">end</span>());<span class="comment">//循环体是空语句</span></span><br><span class="line">    ++iter; <span class="comment">//递增运算不属于循环</span></span><br></pre></td></tr></table></figure><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition1)</span><br><span class="line">    statement; <span class="comment">//没有else分支</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(condition2)</span><br><span class="line">    statement1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statement2；</span><br></pre></td></tr></table></figure><p>除此之外，还有嵌套if-else，但是很简单不再赘述。</p><p><strong>悬垂else</strong>：指当if分支多余else分支时，if和else分匹配问题。</p><p>c++规定else与离其最近的尚未匹配的if匹配。<br>通常用花括号控制执行的路径。</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> acnt=<span class="number">0</span>,ecnt=<span class="number">0</span>,icnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">switch</span> (ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        acnt++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        ecnt++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        icnt++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>case的标签必须是整型常量表达式。<br>有时候，我们需要多个值共享一组操作时可以省略掉break语句，只在最后一个符合条件的语句中加break。</p></blockquote><p>一般不要省略break语句。</p><h3 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h3><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure><p>只要condition的求值结果为真就会一直执行statement。<br>当不确定要迭代多少次时，使用while比较合适。</p><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p><em>传统for语句</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(init-statement;condition;express)</span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure><p>for语句头中定义的对象只在for循环体内可见。</p><p><em>范围for语句</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaratioin:expression)</span><br><span class="line">    statement</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;r:v)</span><br><span class="line">    r*=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>expression表示的必须是一个序列，比如数组、vector、string等类型的对象。<br>declaration定义一个变量，序列中的每个元素都能转换成该变量的类型。</p><h4 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h4><p>do while语句与while语句很相似区别是do while语句先执行循环体后检查条件，至少会执行一次循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">    statement</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(condition)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>do while语句最后用一个分号结束</p></blockquote><h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><h4 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h4><p>break语句负责中止离它最近的循环语句，并从这些语句之后的第一天语句开始继续执行。</p><h4 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h4><p>continue语句终止最近的循环中的当前迭代并立即开始下一次迭代。只能出现在for、while、do while循环的内部。<br>continue终止当前迭代，但是仍然执行循环。</p><h4 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> lable;</span><br><span class="line"></span><br><span class="line">lable: <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><blockquote><p>一般不要在程序中使用goto语句，会使得程序即难理解又难修改。</p></blockquote><h3 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h3><p>异常处理机制由异常检测和异常处理两部分协作完成。<br>异常处理包括：</p><ul><li>throw表达式：异常检测部分使用throw表达式来表示它遇到了无法处理的问题。</li><li>try语句块：以关键字try开始，以一个或者多个catch子语句结束。</li></ul><h4 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a!=b)</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;error&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果a不等于b，则抛出一个类型为runtime_error的异常。抛出异常将终止当前的函数，并把控制权交给能处理该异常的代码。</p><p>runtime_error是标准库异常类型的一种。</p><h4 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h4><p>通用形式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    program-statement</span><br><span class="line">&#125;   <span class="built_in">catch</span>(expression)&#123;</span><br><span class="line">    handler</span><br><span class="line">&#125;   <span class="built_in">catch</span>(expression2)&#123;</span><br><span class="line">    handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h4><table><thead><tr><th align="center">异常类型</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">exception</td><td align="center">最常见的问题</td></tr><tr><td align="center">runtime_error</td><td align="center">只有在允许时才能检测出的问题</td></tr><tr><td align="center">range_error</td><td align="center">生成结果超出范围</td></tr><tr><td align="center">logic_error</td><td align="center">程序逻辑错误</td></tr><tr><td align="center">invalid_argument</td><td align="center">无效参数</td></tr><tr><td align="center">length_error</td><td align="center">试图创建一个超出该类型最大长度的对象</td></tr><tr><td align="center">out_of_range</td><td align="center">使用一个超出范围的值</td></tr><tr><td align="center">domain_error</td><td align="center">参数对应的结果不存在</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="http://singlewang.top/categories/CPP/">CPP</category>
      
      
      <category domain="http://singlewang.top/tags/cpp/">cpp</category>
      
      
      <comments>http://singlewang.top/2022/06/25/cpp/cpp_primer_ch5/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
